# `grype\cmd\grype\cli\ui\handle_update_vulnerability_database.go`

```go
package ui

import (
    "fmt"

    tea "github.com/charmbracelet/bubbletea"
    "github.com/dustin/go-humanize"
    "github.com/wagoodman/go-partybus"
    "github.com/wagoodman/go-progress"

    "github.com/anchore/bubbly/bubbles/taskprogress"
    "github.com/anchore/grype/grype/event/parsers"
    "github.com/anchore/grype/internal/log"
)

// 定义一个结构体用于表示数据库下载进度的阶段
type dbDownloadProgressStager struct {
    prog progress.StagedProgressable
}

// 实现阶段方法，根据当前阶段返回相应的字符串
func (s dbDownloadProgressStager) Stage() string {
    // 获取当前阶段
    stage := s.prog.Stage()
    if stage == "downloading" {
        // 如果当前阶段是下载中，则根据下载进度返回相应的字符串
        // 注意：由于验证已经包含在下载进度中，因此在这个阶段没有可见性。
        // 因此，当下载的最后一个字节被下载时（通常是最长的时间，因为 go-downloader 在做这项工作），我们报告“验证”。
        if s.prog.Current() >= s.prog.Size()-1 {
            return "validating"
        }
        // 显示下载的中间进度
        return fmt.Sprintf("%s / %s", humanize.Bytes(uint64(s.prog.Current())), humanize.Bytes(uint64(s.prog.Size())))
    }
    return stage
}

// 处理更新漏洞数据库的事件
func (m *Handler) handleUpdateVulnerabilityDatabase(e partybus.Event) ([]tea.Model, tea.Cmd) {
    // 解析更新漏洞数据库的事件
    prog, err := parsers.ParseUpdateVulnerabilityDatabase(e)
    if err != nil {
        // 如果解析失败，则记录错误并返回空
        log.WithFields("error", err).Warn("unable to parse event")
        return nil, nil
    }

    // 创建一个新的任务进度
    tsk := m.newTaskProgress(
        taskprogress.Title{
            Default: "Vulnerability DB",
        },
        taskprogress.WithStagedProgressable(prog), // 忽略事件提供的静态阶段
        taskprogress.WithStager(dbDownloadProgressStager{prog: prog}),
    )

    tsk.HideStageOnSuccess = false

    // 返回任务进度模型
    return []tea.Model{tsk}, nil
}
```