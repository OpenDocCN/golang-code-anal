# `grype\cmd\grype\cli\ui\handle_update_vulnerability_database.go`

```
package ui

import (
	"fmt"  // 导入 fmt 包，用于格式化输出
	tea "github.com/charmbracelet/bubbletea"  // 导入 bubbletea 包，用于构建终端用户界面
	"github.com/dustin/go-humanize"  // 导入 go-humanize 包，用于格式化数据大小
	"github.com/wagoodman/go-partybus"  // 导入 go-partybus 包，用于事件总线
	"github.com/wagoodman/go-progress"  // 导入 go-progress 包，用于显示进度条

	"github.com/anchore/bubbly/bubbles/taskprogress"  // 导入 taskprogress 包，用于任务进度显示
	"github.com/anchore/grype/grype/event/parsers"  // 导入 parsers 包，用于解析事件
	"github.com/anchore/grype/internal/log"  // 导入 log 包，用于日志记录
)

type dbDownloadProgressStager struct {
	prog progress.StagedProgressable  // 定义 dbDownloadProgressStager 结构体，包含进度条对象
}

func (s dbDownloadProgressStager) Stage() string {
// 获取当前程序的阶段
stage := s.prog.Stage()
// 如果阶段是"downloading"
if stage == "downloading" {
    // 注意：由于验证已经内置到下载进度中，因此在这个阶段没有可见性。
    // 因此，当下载的最后一个字节被下载时（通常是最长的，因为go-downloader正在执行这项工作），我们报告"validating"。
    if s.prog.Current() >= s.prog.Size()-1 {
        return "validating"
    }
    // 显示下载的中间进度
    return fmt.Sprintf("%s / %s", humanize.Bytes(uint64(s.prog.Current())), humanize.Bytes(uint64(s.prog.Size())))
}
// 返回阶段
return stage
}

func (m *Handler) handleUpdateVulnerabilityDatabase(e partybus.Event) ([]tea.Model, tea.Cmd) {
    // 解析更新漏洞数据库的事件
    prog, err := parsers.ParseUpdateVulnerabilityDatabase(e)
    // 如果出现错误，记录警告并返回空
    if err != nil {
        log.WithFields("error", err).Warn("unable to parse event")
        return nil, nil
    }
```

// 创建一个新的任务进度对象，并设置标题为“Vulnerability DB”
tsk := m.newTaskProgress(
    taskprogress.Title{
        Default: "Vulnerability DB",
    },
    // 使用自定义的进度条，忽略事件提供的静态阶段
    taskprogress.WithStagedProgressable(prog),
    // 使用自定义的阶段器来更新进度
    taskprogress.WithStager(dbDownloadProgressStager{prog: prog}),
)

// 在成功时显示阶段
tsk.HideStageOnSuccess = false

// 返回更新后的模型和空错误
return []tea.Model{tsk}, nil
```