# `grype\cmd\grype\cli\ui\handle_vulnerability_scanning_started_test.go`

```
package ui

import (
    "sort" // 导入排序包
    "testing" // 导入测试包
    "time" // 导入时间包

    tea "github.com/charmbracelet/bubbletea" // 导入bubbletea包
    "github.com/gkampitakis/go-snaps/snaps" // 导入snaps包
    "github.com/stretchr/testify/require" // 导入require包
    "github.com/wagoodman/go-partybus" // 导入go-partybus包
    "github.com/wagoodman/go-progress" // 导入go-progress包

    "github.com/anchore/bubbly/bubbles/taskprogress" // 导入taskprogress包
    "github.com/anchore/grype/grype/event" // 导入event包
    "github.com/anchore/grype/grype/event/monitor" // 导入monitor包
    "github.com/anchore/grype/grype/vulnerability" // 导入vulnerability包
)

func TestHandler_handleVulnerabilityScanningStarted(t *testing.T) {
    tests := []struct { // 定义测试用例结构体
        name       string // 测试用例名称
        eventFn    func(*testing.T) partybus.Event // 事件处理函数
        iterations int // 迭代次数
    }{
        {
            name: "vulnerability scanning in progress", // 测试用例名称
            eventFn: func(t *testing.T) partybus.Event { // 事件处理函数
                return partybus.Event{ // 返回事件对象
                    Type:  event.VulnerabilityScanningStarted, // 事件类型
                    Value: getVulnerabilityMonitor(false), // 获取漏洞监控对象
                }
            },
        },
        {
            name: "vulnerability scanning complete", // 测试用例名称
            eventFn: func(t *testing.T) partybus.Event { // 事件处理函数
                return partybus.Event{ // 返回事件对象
                    Type:  event.VulnerabilityScanningStarted, // 事件类型
                    Value: getVulnerabilityMonitor(true), // 获取漏洞监控对象
                }
            },
        },
    }
    # 遍历测试用例集合
    for _, tt := range tests {
        # 使用测试用例的名称创建子测试，并执行匿名函数
        t.Run(tt.name, func(t *testing.T) {
            # 根据测试用例的事件函数创建事件
            e := tt.eventFn(t)
            # 创建默认处理程序配置的处理程序
            handler := New(DefaultHandlerConfig())
            # 设置处理程序的窗口大小
            handler.WindowSize = tea.WindowSizeMsg{
                Width:  100,
                Height: 80,
            }

            # 处理事件，获取模型列表
            models, _ := handler.Handle(e)
            # 断言模型列表的长度为2
            require.Len(t, models, 2)

            # 创建子测试 "task line"，并执行匿名函数
            t.Run("task line", func(t *testing.T) {
                # 将模型列表中的第一个模型断言为任务进度模型
                tsk, ok := models[0].(taskprogress.Model)
                require.True(t, ok)

                # 运行模型并获取结果
                got := runModel(t, tsk, tt.iterations, taskprogress.TickMsg{
                    Time:     time.Now(),
                    Sequence: tsk.Sequence(),
                    ID:       tsk.ID(),
                })
                # 记录结果
                t.Log(got)
                # 断言结果与快照匹配
                snaps.MatchSnapshot(t, got)
            })

            # 创建子测试 "tree"，并执行匿名函数
            t.Run("tree", func(t *testing.T) {
                # 将模型列表中的第二个模型断言为漏洞进度树
                log, ok := models[1].(vulnerabilityProgressTree)
                require.True(t, ok)
                # 运行模型并获取结果
                got := runModel(t, log, tt.iterations, vulnerabilityProgressTreeTickMsg{
                    Time:     time.Now(),
                    Sequence: log.sequence,
                    ID:       log.id,
                })
                # 记录结果
                t.Log(got)
                # 断言结果与快照匹配
                snaps.MatchSnapshot(t, got)
            })

        })
    }
# 获取漏洞监控器，根据是否完成参数来设置不同的进度
func getVulnerabilityMonitor(completed bool) monitor.Matching {
    # 创建一个手动进度监控器，用于包的处理进度
    pkgs := &progress.Manual{}
    pkgs.SetTotal(-1)
    # 如果完成参数为真，则设置包的处理进度为 2000 并标记为已完成，否则设置为 300
    if completed {
        pkgs.Set(2000)
        pkgs.SetCompleted()
    } else {
        pkgs.Set(300)
    }

    # 创建一个手动进度监控器，用于漏洞的发现进度
    vulns := &progress.Manual{}
    vulns.SetTotal(-1)
    # 如果完成参数为真，则设置漏洞的发现进度为 45 并标记为已完成，否则设置为 40
    if completed {
        vulns.Set(45)
        vulns.SetCompleted()
    } else {
        vulns.Set(40)
    }

    # 创建一个手动进度监控器，用于已修复漏洞的进度
    fixed := &progress.Manual{}
    fixed.SetTotal(-1)
    # 如果完成参数为真，则设置已修复漏洞的进度为 35 并标记为已完成，否则设置为 30
    if completed {
        fixed.Set(35)
        fixed.SetCompleted()
    } else {
        fixed.Set(30)
    }

    # 创建一个手动进度监控器，用于忽略漏洞的进度
    ignored := &progress.Manual{}
    ignored.SetTotal(-1)
    # 如果完成参数为真，则设置忽略漏洞的进度为 5 并标记为已完成，否则设置为 4
    if completed {
        ignored.Set(5)
        ignored.SetCompleted()
    } else {
        ignored.Set(4)
    }

    # 创建一个手动进度监控器，用于丢弃漏洞的进度
    dropped := &progress.Manual{}
    dropped.SetTotal(-1)
    # 如果完成参数为真，则设置丢弃漏洞的进度为 3 并标记为已完成，否则设置为 2
    if completed {
        dropped.Set(3)
        dropped.SetCompleted()
    } else {
        dropped.Set(2)
    }

    # 创建一个漏洞严重程度到手动进度监控器的映射
    bySeverityWriter := map[vulnerability.Severity]*progress.Manual{
        vulnerability.CriticalSeverity:   {},
        vulnerability.HighSeverity:       {},
        vulnerability.MediumSeverity:     {},
        vulnerability.LowSeverity:        {},
        vulnerability.NegligibleSeverity: {},
        vulnerability.UnknownSeverity:    {},
    }

    # 获取所有漏洞严重程度并按照相反的顺序排序
    allSeverities := vulnerability.AllSeverities()
    sort.Sort(sort.Reverse(vulnerability.Severities(allSeverities)))

    # 初始化计数器
    var count int64 = 1
    # 遍历所有漏洞严重程度，为每个严重程度的手动进度监控器添加计数
    for _, sev := range allSeverities {
        bySeverityWriter[sev].Add(count)
        count++
    }
    # 为未知严重程度的手动进度监控器添加计数
    bySeverityWriter[vulnerability.UnknownSeverity].Add(count)

    # 创建一个漏洞严重程度到进度监控器的映射
    bySeverity := map[vulnerability.Severity]progress.Monitorable{}

    # 将漏洞严重程度到手动进度监控器的映射转换为漏洞严重程度到进度监控器的映射
    for k, v := range bySeverityWriter {
        bySeverity[k] = v
    }

    # 返回包处理进度、漏洞发现进度、已修复漏洞进度、忽略漏洞进度、丢弃漏洞进度和漏洞严重程度到进度监控器的映射
    return monitor.Matching{
        PackagesProcessed: pkgs,
        MatchesDiscovered: vulns,
        Fixed:             fixed,
        Ignored:           ignored,
        Dropped:           dropped,
        BySeverity:        bySeverity,
    }
}
```