# `grype\cmd\grype\cli\ui\handle_vulnerability_scanning_started_test.go`

```
package ui
// 导入所需的包

import (
	"sort"
	"testing"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/gkampitakis/go-snaps/snaps"
	"github.com/stretchr/testify/require"
	"github.com/wagoodman/go-partybus"
	"github.com/wagoodman/go-progress"

	"github.com/anchore/bubbly/bubbles/taskprogress"
	"github.com/anchore/grype/grype/event"
	"github.com/anchore/grype/grype/event/monitor"
	"github.com/anchore/grype/grype/vulnerability"
)

// 定义测试函数，用于处理漏洞扫描开始事件
func TestHandler_handleVulnerabilityScanningStarted(t *testing.T) {
// 定义一个测试用例的结构体数组，每个结构体包含名称、事件函数和迭代次数
tests := []struct {
    name       string           // 测试用例名称
    eventFn    func(*testing.T) partybus.Event  // 事件函数，返回一个事件对象
    iterations int              // 迭代次数
}{
    {
        name: "vulnerability scanning in progress",  // 第一个测试用例的名称
        eventFn: func(t *testing.T) partybus.Event {  // 第一个测试用例的事件函数
            return partybus.Event{  // 返回一个事件对象
                Type:  event.VulnerabilityScanningStarted,  // 事件类型为漏洞扫描开始
                Value: getVulnerabilityMonitor(false),  // 事件值为获取漏洞监控对象（假设为假）
            }
        },
    },
    {
        name: "vulnerability scanning complete",  // 第二个测试用例的名称
        eventFn: func(t *testing.T) partybus.Event {  // 第二个测试用例的事件函数
            return partybus.Event{  // 返回一个事件对象
                Type:  event.VulnerabilityScanningStarted,  // 事件类型为漏洞扫描开始
                Value: getVulnerabilityMonitor(true),  // 事件值为获取漏洞监控对象（假设为真）
# 遍历测试用例列表
for _, tt := range tests {
    # 使用测试名称创建子测试
    t.Run(tt.name, func(t *testing.T) {
        # 根据测试用例创建事件
        e := tt.eventFn(t)
        # 创建新的处理程序
        handler := New(DefaultHandlerConfig())
        # 设置窗口大小
        handler.WindowSize = tea.WindowSizeMsg{
            Width:  100,
            Height: 80,
        }

        # 处理事件并获取模型
        models, _ := handler.Handle(e)
        # 断言模型列表长度为2
        require.Len(t, models, 2)

        # 创建子测试，测试任务行
        t.Run("task line", func(t *testing.T) {
            # 将模型转换为任务进度模型
            tsk, ok := models[0].(taskprogress.Model)
            require.True(t, ok)
// 在测试中运行模型，并获取结果
got := runModel(t, tsk, tt.iterations, taskprogress.TickMsg{
    Time:     time.Now(),
    Sequence: tsk.Sequence(),
    ID:       tsk.ID(),
})
// 记录获取的结果
t.Log(got)
// 使用快照断言来比较获取的结果
snaps.MatchSnapshot(t, got)

// 在子测试中运行模型，并获取结果
t.Run("tree", func(t *testing.T) {
    // 将模型转换为漏洞进度树模型
    log, ok := models[1].(vulnerabilityProgressTree)
    require.True(t, ok)
    got := runModel(t, log, tt.iterations, vulnerabilityProgressTreeTickMsg{
        Time:     time.Now(),
        Sequence: log.sequence,
        ID:       log.id,
    })
    // 记录获取的结果
    t.Log(got)
    // 使用快照断言来比较获取的结果
    snaps.MatchSnapshot(t, got)
})
// 获取漏洞监控器，根据是否完成设置不同的数值
func getVulnerabilityMonitor(completed bool) monitor.Matching {
    // 创建一个手动控制的进度条，设置总数为-1
    pkgs := &progress.Manual{}
    pkgs.SetTotal(-1)
    // 如果完成了，则设置进度为2000，并标记为已完成
    if completed {
        pkgs.Set(2000)
        pkgs.SetCompleted()
    } else {
        // 如果未完成，则设置进度为300
        pkgs.Set(300)
    }

    // 创建另一个手动控制的进度条，设置总数为-1
    vulns := &progress.Manual{}
    vulns.SetTotal(-1)
    // 如果完成了，则设置进度为45，并标记为已完成
    if completed {
        vulns.Set(45)
        vulns.SetCompleted()
    }
# 如果条件成立，设置漏洞数量为40
} else {
    vulns.Set(40)
}

# 创建一个手动进度条对象，设置总数为-1
fixed := &progress.Manual{}
fixed.SetTotal(-1)
# 如果已完成，设置进度为35，并标记为已完成
if completed {
    fixed.Set(35)
    fixed.SetCompleted()
} else {
    # 如果未完成，设置进度为30
    fixed.Set(30)
}

# 创建另一个手动进度条对象，设置总数为-1
ignored := &progress.Manual{}
ignored.SetTotal(-1)
# 如果已完成，设置进度为5，并标记为已完成
if completed {
    ignored.Set(5)
    ignored.SetCompleted()
} else {
    # 如果未完成，设置进度为4
    ignored.Set(4)
	}

	// 创建一个手动进度对象，用于跟踪已丢弃的漏洞数量
	dropped := &progress.Manual{}
	// 设置总数为-1，表示未知数量
	dropped.SetTotal(-1)
	// 如果已完成，则设置已丢弃的数量为3，并标记为已完成
	if completed {
		dropped.Set(3)
		dropped.SetCompleted()
	} else {
		// 如果未完成，则设置已丢弃的数量为2
		dropped.Set(2)
	}

	// 创建一个映射，将漏洞严重程度与手动进度对象关联起来
	bySeverityWriter := map[vulnerability.Severity]*progress.Manual{
		vulnerability.CriticalSeverity:   {},
		vulnerability.HighSeverity:       {},
		vulnerability.MediumSeverity:     {},
		vulnerability.LowSeverity:        {},
		vulnerability.NegligibleSeverity: {},
		vulnerability.UnknownSeverity:    {},
	}
# 获取所有漏洞严重程度的列表
allSeverities := vulnerability.AllSeverities()
# 对漏洞严重程度列表进行倒序排序
sort.Sort(sort.Reverse(vulnerability.Severities(allSeverities)))

# 初始化计数器
var count int64 = 1
# 遍历所有漏洞严重程度
for _, sev := range allSeverities {
    # 将计数值添加到对应严重程度的写入器中
    bySeverityWriter[sev].Add(count)
    # 计数值自增
    count++
}
# 将未知严重程度的计数值添加到对应写入器中
bySeverityWriter[vulnerability.UnknownSeverity].Add(count)

# 创建一个漏洞严重程度到监控对象的映射
bySeverity := map[vulnerability.Severity]progress.Monitorable{}

# 将写入器中的数据转移到监控对象中
for k, v := range bySeverityWriter {
    bySeverity[k] = v
}

# 返回匹配结果
return monitor.Matching{
    PackagesProcessed: pkgs,
    MatchesDiscovered: vulns,
    Fixed:             fixed,
}
# 定义一个包含四个键值对的字典
{
    'Ignored': ignored,  # 键为'Ignored'，值为变量ignored的值
    'Dropped': dropped,  # 键为'Dropped'，值为变量dropped的值
    'BySeverity': bySeverity,  # 键为'BySeverity'，值为变量bySeverity的值
}
```