# `grype\grype\db\vulnerability_provider.go`

```
package db

import (
    "fmt"

    "github.com/facebookincubator/nvdtools/wfn"

    cpeUtil "github.com/anchore/grype/grype/cpe"
    grypeDB "github.com/anchore/grype/grype/db/v5"
    "github.com/anchore/grype/grype/db/v5/namespace"
    "github.com/anchore/grype/grype/distro"
    "github.com/anchore/grype/grype/pkg"
    "github.com/anchore/grype/grype/vulnerability"
    "github.com/anchore/grype/internal/log"
    "github.com/anchore/syft/syft/cpe"
    syftPkg "github.com/anchore/syft/syft/pkg"
)

var _ vulnerability.Provider = (*VulnerabilityProvider)(nil)

type VulnerabilityProvider struct {
    namespaceIndex *namespace.Index  // 命名空间索引
    reader         grypeDB.VulnerabilityStoreReader  // 漏洞存储读取器
}

func NewVulnerabilityProvider(reader grypeDB.VulnerabilityStoreReader) (*VulnerabilityProvider, error) {
    namespaces, err := reader.GetVulnerabilityNamespaces()  // 获取漏洞命名空间
    if err != nil {
        return nil, fmt.Errorf("unable to get namespaces from store: %w", err)  // 如果获取失败，返回错误
    }

    namespaceIndex, err := namespace.FromStrings(namespaces)  // 从字符串创建命名空间索引
    if err != nil {
        return nil, fmt.Errorf("unable to parse namespaces from store: %w", err)  // 如果解析失败，返回错误
    }

    return &VulnerabilityProvider{
        namespaceIndex: namespaceIndex,  // 返回漏洞提供者对象
        reader:         reader,
    }, nil
}

func (pr *VulnerabilityProvider) Get(id, namespace string) ([]vulnerability.Vulnerability, error) {
    // 注意：通过 id 获取漏洞记录不一定会返回单个记录，因为记录会根据其修复集进行复制。
    vulns, err := pr.reader.GetVulnerability(namespace, id)  // 获取漏洞记录
    if err != nil {
        return nil, fmt.Errorf("provider failed to fetch namespace=%q pkg=%q: %w", namespace, id, err)  // 如果获取失败，返回错误
    }

    var results []vulnerability.Vulnerability  // 定义漏洞结果数组
    # 遍历漏洞列表
    for _, vuln := range vulns {
        # 根据漏洞信息创建漏洞对象
        vulnObj, err := vulnerability.NewVulnerability(vuln)
        # 如果创建对象过程中出现错误，则返回错误信息
        if err != nil {
            return nil, fmt.Errorf("provider failed to inflate vulnerability record (namespace=%q id=%q): %w", vuln.Namespace, vuln.ID, err)
        }

        # 将创建的漏洞对象添加到结果列表中
        results = append(results, *vulnObj)
    }
    # 返回结果列表和空的错误信息
    return results, nil
# 根据发行版和软件包获取漏洞信息
func (pr *VulnerabilityProvider) GetByDistro(d *distro.Distro, p pkg.Package) ([]vulnerability.Vulnerability, error) {
    # 如果发行版为空，则返回空值
    if d == nil {
        return nil, nil
    }

    # 初始化漏洞列表和命名空间
    var vulnerabilities []vulnerability.Vulnerability
    namespaces := pr.namespaceIndex.NamespacesForDistro(d)

    # 如果没有找到漏洞命名空间，则记录日志并返回空的漏洞列表
    if len(namespaces) == 0 {
        log.Debugf("no vulnerability namespaces found in grype database for distro=%s package=%s", d.String(), p.Name)
        return vulnerabilities, nil
    }

    # 初始化漏洞列表
    vulnerabilities = make([]vulnerability.Vulnerability, 0)

    # 遍历命名空间
    for _, n := range namespaces:
        # 遍历命名空间中的软件包
        for _, packageName := range n.Resolver().Resolve(p) {
            nsStr := n.String()
            # 根据命名空间和软件包名称搜索漏洞
            allPkgVulns, err := pr.reader.SearchForVulnerabilities(nsStr, packageName)

            # 如果搜索失败，则返回错误
            if err != nil {
                return nil, fmt.Errorf("provider failed to search for vulnerabilities (namespace=%q pkg=%q): %w", nsStr, packageName, err)
            }

            # 遍历搜索到的漏洞，创建漏洞对象并添加到漏洞列表中
            for _, vuln := range allPkgVulns {
                vulnObj, err := vulnerability.NewVulnerability(vuln)
                if err != nil {
                    return nil, fmt.Errorf("provider failed to inflate vulnerability record (namespace=%q id=%q distro=%q): %w", vuln.Namespace, vuln.ID, d, err)
                }

                vulnerabilities = append(vulnerabilities, *vulnObj)
            }
        }
    }

    return vulnerabilities, nil
}

# 根据语言和软件包获取漏洞信息
func (pr *VulnerabilityProvider) GetByLanguage(l syftPkg.Language, p pkg.Package) ([]vulnerability.Vulnerability, error) {
    # 初始化漏洞列表和命名空间
    var vulnerabilities []vulnerability.Vulnerability
    namespaces := pr.namespaceIndex.NamespacesForLanguage(l)

    # 如果没有找到漏洞命名空间，则记录日志并返回空的漏洞列表
    if len(namespaces) == 0 {
        log.Debugf("no vulnerability namespaces found in grype database for language=%s package=%s", l, p.Name)
        return vulnerabilities, nil
    }

    # 初始化漏洞列表
    vulnerabilities = make([]vulnerability.Vulnerability, 0)
    # 遍历命名空间列表
    for _, n := range namespaces:
        # 遍历每个命名空间中的包名
        for _, packageName := range n.Resolver().Resolve(p):
            # 获取命名空间的字符串表示
            nsStr := n.String()
            # 使用提供者的阅读器搜索漏洞
            allPkgVulns, err := pr.reader.SearchForVulnerabilities(nsStr, packageName)

            # 如果搜索出错，则返回错误信息
            if err != nil:
                return nil, fmt.Errorf("provider failed to fetch namespace=%q pkg=%q: %w", nsStr, packageName, err)

            # 遍历所有包漏洞
            for _, vuln := range allPkgVulns:
                # 创建漏洞对象
                vulnObj, err := vulnerability.NewVulnerability(vuln)
                # 如果创建漏洞对象出错，则返回错误信息
                if err != nil:
                    return nil, fmt.Errorf("provider failed to inflate vulnerability record (namespace=%q id=%q language=%q): %w", vuln.Namespace, vuln.ID, l, err)

                # 将漏洞对象添加到漏洞列表中
                vulnerabilities = append(vulnerabilities, *vulnObj)
            }
        }
    }

    # 返回漏洞列表和空错误
    return vulnerabilities, nil
// 根据CPE获取漏洞信息
func (pr *VulnerabilityProvider) GetByCPE(requestCPE cpe.CPE) ([]vulnerability.Vulnerability, error) {
    // 创建一个空的漏洞切片
    vulns := make([]vulnerability.Vulnerability, 0)
    // 获取所有的命名空间
    namespaces := pr.namespaceIndex.CPENamespaces()

    // 如果没有命名空间，则返回错误信息
    if len(namespaces) == 0 {
        log.Debugf("no vulnerability namespaces found for arbitrary CPEs in grype database")
        return nil, nil
    }

    // 如果请求的产品名称是任意或者NA，则返回错误信息
    if requestCPE.Product == wfn.Any || requestCPE.Product == wfn.NA {
        return nil, fmt.Errorf("product name is required")
    }

    // 遍历所有的命名空间
    for _, ns := range namespaces {
        // 根据命名空间和产品名称搜索漏洞
        allPkgVulns, err := pr.reader.SearchForVulnerabilities(ns.String(), ns.Resolver().Normalize(requestCPE.Product))
        if err != nil {
            return nil, fmt.Errorf("provider failed to fetch namespace=%q product=%q: %w", ns, requestCPE.Product, err)
        }

        // 根据命名空间规范化请求的CPE
        normalizedRequestCPE, err := cpe.New(ns.Resolver().Normalize(requestCPE.BindToFmtString()))

        if err != nil {
            normalizedRequestCPE = requestCPE
        }

        // 遍历所有的包漏洞
        for _, vuln := range allPkgVulns {
            vulnCPEs, err := cpeUtil.NewSlice(vuln.CPEs...)
            if err != nil {
                return nil, err
            }

            // 将请求的CPE与潜在匹配项进行比较（不包括版本，版本在下游处理）
            candidateMatchCpes := cpeUtil.MatchWithoutVersion(normalizedRequestCPE, vulnCPEs)

            // 如果有匹配项，则创建漏洞对象并添加到漏洞切片中
            if len(candidateMatchCpes) > 0 {
                vulnObj, err := vulnerability.NewVulnerability(vuln)
                if err != nil {
                    return nil, fmt.Errorf("provider failed to inflate vulnerability record (namespace=%q id=%q cpe=%q): %w", vuln.Namespace, vuln.ID, requestCPE.BindToFmtString(), err)
                }

                vulnObj.CPEs = candidateMatchCpes

                vulns = append(vulns, *vulnObj)
            }
        }
    }

    return vulns, nil
}
```