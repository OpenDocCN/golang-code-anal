# `grype\grype\presenter\cyclonedx\vulnerability.go`

```
// 导入所需的包
package cyclonedx

import (
	"fmt"  // 导入格式化包
	"strconv"  // 导入字符串转换包
	"strings"  // 导入字符串处理包

	"github.com/CycloneDX/cyclonedx-go"  // 导入CycloneDX库
	"github.com/google/uuid"  // 导入UUID库

	"github.com/anchore/grype/grype/match"  // 导入匹配库
	"github.com/anchore/grype/grype/pkg"  // 导入包信息库
	"github.com/anchore/grype/grype/vulnerability"  // 导入漏洞库
	"github.com/anchore/packageurl-go"  // 导入包URL库
)

// https://cyclonedx.org/docs/1.4/json/#vulnerabilities_items_bom-ref

// NewVulnerability creates a Vulnerability document from a match and the metadata provider
// 从匹配和元数据提供程序创建一个漏洞文档
func NewVulnerability(m match.Match, p vulnerability.MetadataProvider) (v cyclonedx.Vulnerability, err error) {
// 通过调用 GetMetadata 方法获取漏洞的元数据，如果出现错误则返回错误信息
metadata, err := p.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
if err != nil {
    return v, fmt.Errorf("unable to fetch vuln=%q metadata: %+v", m.Vulnerability.ID, err)
}

// 根据获取的元数据生成 CycloneDX 的评级
ratings := generateCDXRatings(metadata)

// 创建一个 CycloneDX 的源对象，包括名称和 URL
source := &cyclonedx.Source{
    Name: cdxSourceName(metadata.Namespace),
    URL:  metadata.DataSource,
}

// 创建一个包含漏洞引用信息的切片
references := &[]cyclonedx.VulnerabilityReference{
    {
        ID:     m.Vulnerability.ID,
        Source: source,
    },
}

// 创建一个空的漏洞公告切片
advisories := &[]cyclonedx.Advisory{}
	// 遍历 metadata.URLs 中的每个元素，将其转换为 cyclonedx.Advisory 结构并添加到 advisories 中
	for _, advisory := range metadata.URLs {
		*advisories = append(*advisories, cyclonedx.Advisory{
			URL: advisory,
		})
	}

	// 注意：如果某个字段在这里没有被捕获，通常是因为生成的引用链接已经包含了消费者需要的信息
	// 返回一个 cyclonedx.Vulnerability 结构，其中包含了 BOMRef、ID、Source、References、Ratings 等信息
	return cyclonedx.Vulnerability{
		BOMRef:     uuid.New().URN(),
		ID:         m.Vulnerability.ID,
		Source:     source,
		References: references,
		Ratings:    &ratings,
		// 我们的模型中不包含 CWEs
		CWEs:        nil,
		Description: metadata.Description,
		// 我们的模型中不包含完整的详细描述
		Detail: "",
		// 我们的模型中不包含建议
		// 推荐信息，通常用于指导用户如何处理漏洞
		Recommendation: "",
		// 漏洞公告信息
		Advisories:     advisories,
		// 影响信息，包括受影响的软件包等
		Affects: &[]cyclonedx.Affects{
			{
				Ref: deriveBomRef(m.Package),
			},
		},
		// 创建数据源
		Created: "",
		// 漏洞首次发布时间
		Published: "",
		// 漏洞最后更新时间
	Updated: "",
		// 我们的模型中不包含漏洞的认证信息
		Credits: nil,
		// 我们的模型中不包含确定漏洞发布前使用的方法的信息
		Tools: nil,
		// TODO: 我们的模型中不利用以下字段
		Analysis:   nil,
		Properties: nil,
	}, nil
}

// 生成 CycloneDX 漏洞评级
func generateCDXRatings(metadata *vulnerability.Metadata) []cyclonedx.VulnerabilityRating {
	// 从 Grype 漏洞严重性转换为 CycloneDX 严重性
	severity := cdxSeverityFromGrypeSeverity(metadata.Severity)

	// 创建一个空的漏洞评级数组
	ratings := make([]cyclonedx.VulnerabilityRating, 0)
	// 遍历 CVSS 数据
	for _, cvss := range metadata.Cvss {
		// 创建一个漏洞评级对象
		var rating cyclonedx.VulnerabilityRating
		// 获取 CVSS 基础分数并赋值给评级对象
		score := cvss.Metrics.BaseScore
		rating.Score = &score

		// 获取 CVSS 版本对应的评级方法
		// 评级方法可以是以下之一："CVSSv2", "CVSSv3", "CVSSv31", "OWASP", "other"
		method, err := cvssVersionToMethod(cvss.Version)
		if err != nil {
			// 如果无法准确获取版本，则不中断执行
			// TODO: 在这里记录警告？
			continue
		}
		// 设置rating对象的Method属性为传入的method值
		rating.Method = method
		// 设置rating对象的Vector属性为cvss对象的Vector属性
		rating.Vector = cvss.Vector
		// 设置rating对象的Severity属性为传入的severity值
		rating.Severity = severity
		// 将rating对象添加到ratings切片中
		ratings = append(ratings, rating)
	}

	// 确保severity始终被包含在ratings切片中
	if len(ratings) == 0 {
		// 如果ratings切片为空，添加一个只包含severity属性的VulnerabilityRating对象到ratings切片中
		ratings = append(ratings, cyclonedx.VulnerabilityRating{
			Severity: severity,
		})
	}

	// 返回ratings切片
	return ratings
}

// cvssVersionToMethod接受一个CVSS版本的字符串（例如"3.1"）并将其转换为CycloneDx评分方法，例如"CVSSv3"
func cvssVersionToMethod(version string) (cyclonedx.ScoringMethod, error) {
	// 将版本字符串转换为float64类型的值
	value, err := strconv.ParseFloat(version, 64)
// 如果发生错误，返回空字符串和错误信息
if err != nil {
    return "", err
}

// 根据不同的数值返回不同的 CVSS 计分方法
switch value {
case 2:
    return cyclonedx.ScoringMethodCVSSv2, nil
case 3:
    return cyclonedx.ScoringMethodCVSSv3, nil
case 3.1:
    return cyclonedx.ScoringMethodCVSSv31, nil
default:
    return cyclonedx.ScoringMethodOther, nil
}

// 将命名空间转换为源名称的格式
// 例如：debian:distro:debian:10 转换为 debian-distrot-debian-10
func cdxSourceName(namespace string) string {
    return strings.ReplaceAll(namespace, ":", "-")
}
# 根据 Grype 的漏洞严重程度转换为 CycloneDX 的漏洞严重程度
func cdxSeverityFromGrypeSeverity(severity string) cyclonedx.Severity {
    # 根据不同的严重程度字符串进行匹配，返回对应的 CycloneDX 的漏洞严重程度枚举值
    switch severity {
    case "Negligible":
        return cyclonedx.SeverityNone
    case "Unknown":
        return cyclonedx.SeverityUnknown
    case "Info":
        return cyclonedx.SeverityInfo
    case "Low":
        return cyclonedx.SeverityLow
    case "Medium":
        return cyclonedx.SeverityMedium
    case "High":
        return cyclonedx.SeverityHigh
    case "Critical":
        return cyclonedx.SeverityCritical
    default:
        return cyclonedx.SeverityUnknown
    }
}
// 衍生 BOM 引用，将 syft id 追加到 PURL 中，使其在 BOM 中唯一
// TODO: 将来可能希望通过 PURL 进行去重，并保留其唯一的元数据
func deriveBomRef(p pkg.Package) string {
    // 尝试解析 PURL，如果可能的话，将 syft id 追加到其中，使 PURL 在 BOM 中唯一
    // 如果没有有效的 PURL，则返回 ID
    if parsedPURL, err := packageurl.FromString(p.PURL); err == nil {
        parsedPURL.Qualifiers = append(parsedPURL.Qualifiers, packageurl.Qualifier{Key: "package-id", Value: string(p.ID)})
        return parsedPURL.ToString()
    }
    // 如果没有有效的 PURL，则使用 ID
    return string(p.ID)
}
```