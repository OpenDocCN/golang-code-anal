# `grype\grype\presenter\cyclonedx\vulnerability.go`

```go
// 导入所需的包
package cyclonedx

import (
    "fmt"
    "strconv"
    "strings"

    "github.com/CycloneDX/cyclonedx-go"
    "github.com/google/uuid"

    "github.com/anchore/grype/grype/match"
    "github.com/anchore/grype/grype/pkg"
    "github.com/anchore/grype/grype/vulnerability"
    "github.com/anchore/packageurl-go"
)

// https://cyclonedx.org/docs/1.4/json/#vulnerabilities_items_bom-ref

// NewVulnerability 从匹配和元数据提供程序创建一个 Vulnerability 文档
func NewVulnerability(m match.Match, p vulnerability.MetadataProvider) (v cyclonedx.Vulnerability, err error) {
    // 获取漏洞的元数据
    metadata, err := p.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
    if err != nil {
        return v, fmt.Errorf("unable to fetch vuln=%q metadata: %+v", m.Vulnerability.ID, err)
    }

    // 生成 CycloneDX 评级
    ratings := generateCDXRatings(metadata)

    // 创建漏洞的来源
    source := &cyclonedx.Source{
        Name: cdxSourceName(metadata.Namespace),
        URL:  metadata.DataSource,
    }

    // 创建漏洞的引用
    references := &[]cyclonedx.VulnerabilityReference{
        {
            ID:     m.Vulnerability.ID,
            Source: source,
        },
    }

    // 创建漏洞的建议
    advisories := &[]cyclonedx.Advisory{}
    for _, advisory := range metadata.URLs {
        *advisories = append(*advisories, cyclonedx.Advisory{
            URL: advisory,
        })
    }

    // 注意：如果某个字段在这里没有被捕获，通常是因为生成的引用链接已经包含了消费者需要的信息
    # 返回一个 Vulnerability 对象
    return cyclonedx.Vulnerability{
        # 生成一个新的 UUID 作为 BOMRef
        BOMRef:     uuid.New().URN(),
        # 使用传入的 Vulnerability 对象的 ID
        ID:         m.Vulnerability.ID,
        # 使用传入的 source
        Source:     source,
        # 使用传入的 references
        References: references,
        # 使用传入的 ratings
        Ratings:    &ratings,
        # 不在我们的模型中捕获 CWEs
        CWEs:        nil,
        # 使用传入的 metadata.Description
        Description: metadata.Description,
        # 不在我们的模型中捕获完整的详细描述
        Detail: "",
        # 不在我们的模型中捕获建议
        Recommendation: "",
        # 使用传入的 advisories
        Advisories:     advisories,
        # 创建数据源
        Affects: &[]cyclonedx.Affects{
            {
                # 使用 deriveBomRef 函数生成 BOMRef
                Ref: deriveBomRef(m.Package),
            },
        },
        # 数据源创建时间
        Created: "",
        # 漏洞首次发布时间
        Published: "",
        # 漏洞最后更新时间
        Updated: "",
        # 不在我们的模型中捕获认证信息
        Credits: nil,
        # 不在我们的模型中捕获用于确定漏洞的方法
        Tools: nil,
        # TODO: 我们的模型中不使用以下字段
        Analysis:   nil,
        Properties: nil,
    }, nil
}
// generateCDXRatings 生成 CycloneDx 的漏洞评级
func generateCDXRatings(metadata *vulnerability.Metadata) []cyclonedx.VulnerabilityRating {
    // 从 Grype 的严重性转换为 CycloneDx 的严重性
    severity := cdxSeverityFromGrypeSeverity(metadata.Severity)

    // 创建一个空的漏洞评级切片
    ratings := make([]cyclonedx.VulnerabilityRating, 0)
    // 遍历 CVSS 切片
    for _, cvss := range metadata.Cvss {
        // 创建一个漏洞评级对象
        var rating cyclonedx.VulnerabilityRating
        // 获取 CVSS 的基础分数
        score := cvss.Metrics.BaseScore
        rating.Score = &score

        // 获取 CVSS 的评分方法
        method, err := cvssVersionToMethod(cvss.Version)
        if err != nil {
            // 如果无法准确获取版本，则继续执行
            // TODO: 在这里记录警告？
            continue
        }
        rating.Method = method
        rating.Vector = cvss.Vector
        rating.Severity = severity
        // 将评级对象添加到切片中
        ratings = append(ratings, rating)
    }

    // 确保始终包含严重性
    if len(ratings) == 0 {
        ratings = append(ratings, cyclonedx.VulnerabilityRating{
            Severity: severity,
        })
    }

    return ratings
}

// cvssVersionToMethod 将 CVSS 版本转换为 CycloneDx 评级方法
func cvssVersionToMethod(version string) (cyclonedx.ScoringMethod, error) {
    value, err := strconv.ParseFloat(version, 64)
    if err != nil {
        return "", err
    }

    switch value {
    case 2:
        return cyclonedx.ScoringMethodCVSSv2, nil
    case 3:
        return cyclonedx.ScoringMethodCVSSv3, nil
    case 3.1:
        return cyclonedx.ScoringMethodCVSSv31, nil
    default:
        return cyclonedx.ScoringMethodOther, nil
    }
}

// cdxSourceName 将命名空间转换为源名称
func cdxSourceName(namespace string) string {
    return strings.ReplaceAll(namespace, ":", "-")
}

// cdxSeverityFromGrypeSeverity 将 Grype 的严重性转换为 CycloneDx 的严重性
func cdxSeverityFromGrypeSeverity(severity string) cyclonedx.Severity {
    switch severity {
    # 如果输入为"Negligible"，则返回cyclonedx.SeverityNone
    case "Negligible":
        return cyclonedx.SeverityNone
    # 如果输入为"Unknown"，则返回cyclonedx.SeverityUnknown
    case "Unknown":
        return cyclonedx.SeverityUnknown
    # 如果输入为"Info"，则返回cyclonedx.SeverityInfo
    case "Info":
        return cyclonedx.SeverityInfo
    # 如果输入为"Low"，则返回cyclonedx.SeverityLow
    case "Low":
        return cyclonedx.SeverityLow
    # 如果输入为"Medium"，则返回cyclonedx.SeverityMedium
    case "Medium":
        return cyclonedx.SeverityMedium
    # 如果输入为"High"，则返回cyclonedx.SeverityHigh
    case "High":
        return cyclonedx.SeverityHigh
    # 如果输入为"Critical"，则返回cyclonedx.SeverityCritical
    case "Critical":
        return cyclonedx.SeverityCritical
    # 如果输入不在以上情况中，则返回cyclonedx.SeverityUnknown
    default:
        return cyclonedx.SeverityUnknown
    }
func deriveBomRef(p pkg.Package) string {
    // 派生 BOM 引用，尝试解析 PURL（可移植统一资源定位符），并附加 syft id 以使 PURL 在 BOM 中唯一。
    // TODO: 将来可能希望按照 PURL 进行去重，并结合具有相同 PURL 的组件，同时保留它们的唯一元数据。
    if parsedPURL, err := packageurl.FromString(p.PURL); err == nil {
        // 如果成功解析 PURL，则将 syft id 附加到 qualifiers 中，并返回字符串格式的 PURL
        parsedPURL.Qualifiers = append(parsedPURL.Qualifiers, packageurl.Qualifier{Key: "package-id", Value: string(p.ID)})
        return parsedPURL.ToString()
    }
    // 如果没有有效的 PURL，则回退到严格使用 ID
    return string(p.ID)
}
```