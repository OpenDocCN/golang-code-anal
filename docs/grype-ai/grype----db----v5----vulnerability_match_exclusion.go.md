# `grype\grype\db\v5\vulnerability_match_exclusion.go`

```
package v5

import (
	"encoding/json"
)

// VulnerabilityMatchExclusion represents the minimum data fields necessary to automatically filter certain
// vulnerabilities from match results based on the specified constraints.
// VulnerabilityMatchExclusion 表示根据指定的约束条件自动过滤匹配结果中的某些漏洞所需的最小数据字段。
type VulnerabilityMatchExclusion struct {
	ID            string                                  `json:"id"`                    // The identifier of the vulnerability or advisory
	Constraints   []VulnerabilityMatchExclusionConstraint `json:"constraints,omitempty"` // The constraints under which the exclusion applies
	Justification string                                  `json:"justification"`         // Justification for the exclusion
}

// VulnerabilityMatchExclusionConstraint describes criteria for which matches should be excluded
// VulnerabilityMatchExclusionConstraint 描述应该排除哪些匹配的标准
type VulnerabilityMatchExclusionConstraint struct {
	Vulnerability VulnerabilityExclusionConstraint `json:"vulnerability,omitempty"` // Vulnerability exclusion criteria
	Package       PackageExclusionConstraint       `json:"package,omitempty"`       // Package exclusion criteria
	ExtraFields   map[string]interface{}           `json:"-"`
}
// 判断当前的VulnerabilityMatchExclusionConstraint是否可用，需要满足ExtraFields为空，Vulnerability可用，Package可用
func (c VulnerabilityMatchExclusionConstraint) Usable() bool {
	return len(c.ExtraFields) == 0 && c.Vulnerability.Usable() && c.Package.Usable()
}

// 从JSON数据中解析出VulnerabilityMatchExclusionConstraint对象
func (c *VulnerabilityMatchExclusionConstraint) UnmarshalJSON(data []byte) error {
	// 创建一个新类型，避免递归调用
	type _vulnerabilityMatchExclusionConstraint VulnerabilityMatchExclusionConstraint

	// 将JSON数据解析到新类型的实例中
	var _c _vulnerabilityMatchExclusionConstraint
	if err := json.Unmarshal(data, &_c); err != nil {
		return err
	}

	// 将JSON数据解析到新类型实例的ExtraFields字段中
	if err := json.Unmarshal(data, &_c.ExtraFields); err != nil {
		return err
	}

	// 删除ExtraFields中的"vulnerability"字段
	delete(_c.ExtraFields, "vulnerability")
}
// 删除 ExtraFields 中的 "package" 键值对
delete(_c.ExtraFields, "package")

// 如果 ExtraFields 的长度为 0，则将其赋值为 nil
if len(_c.ExtraFields) == 0 {
    _c.ExtraFields = nil
}

// 将新类型实例转换为原始类型并赋值
*c = VulnerabilityMatchExclusionConstraint(_c)
return nil
}

// VulnerabilityExclusionConstraint 描述了基于额外漏洞组件排除匹配的条件
type VulnerabilityExclusionConstraint struct {
    Namespace   string                 `json:"namespace,omitempty"` // 漏洞命名空间
    FixState    FixState               `json:"fix_state,omitempty"` // 漏洞修复状态
    ExtraFields map[string]interface{} `json:"-"` // 额外字段
}

// 判断 VulnerabilityExclusionConstraint 是否可用
func (v VulnerabilityExclusionConstraint) Usable() bool {
    return len(v.ExtraFields) == 0
}
// UnmarshalJSON 方法用于将 JSON 数据解析为VulnerabilityExclusionConstraint对象
func (v *VulnerabilityExclusionConstraint) UnmarshalJSON(data []byte) error {
    // 创建一个新类型，避免递归调用
    type _vulnerabilityExclusionConstraint VulnerabilityExclusionConstraint

    // 将 JSON 数据解析为新类型的实例
    var _v _vulnerabilityExclusionConstraint
    if err := json.Unmarshal(data, &_v); err != nil {
        return err
    }

    // 将 JSON 数据解析为ExtraFields字段
    if err := json.Unmarshal(data, &_v.ExtraFields); err != nil {
        return err
    }

    // 删除ExtraFields中的"namespace"和"fix_state"字段
    delete(_v.ExtraFields, "namespace")
    delete(_v.ExtraFields, "fix_state")

    // 如果ExtraFields中没有其他字段，则返回
    if len(_v.ExtraFields) == 0 {
// 将 _v.ExtraFields 设置为 nil，清空额外字段
_v.ExtraFields = nil
}

// 将新类型实例转换为原始类型并赋值
*v = VulnerabilityExclusionConstraint(_v)
return nil
}

// PackageExclusionConstraint 描述了基于包组件排除匹配的条件
type PackageExclusionConstraint struct {
Name        string                 `json:"name,omitempty"`     // 包名称
Language    string                 `json:"language,omitempty"` // 包的语言生态系统
Type        string                 `json:"type,omitempty"`     // 包类型
Version     string                 `json:"version,omitempty"`  // 包版本
Location    string                 `json:"location,omitempty"` // 包位置
ExtraFields map[string]interface{} `json:"-"`                  // 额外字段
}

func (p PackageExclusionConstraint) Usable() bool {
return len(p.ExtraFields) == 0
```
// 检查额外字段是否为空，如果为空则返回 true，表示可用
// UnmarshalJSON 方法用于将 JSON 数据解析为 PackageExclusionConstraint 对象
func (p *PackageExclusionConstraint) UnmarshalJSON(data []byte) error {
    // 创建一个新类型，避免递归调用
    type _packageExclusionConstraint PackageExclusionConstraint

    // 将 JSON 数据解析为新类型的实例
    var _p _packageExclusionConstraint
    if err := json.Unmarshal(data, &_p); err != nil {
        return err
    }

    // 将 JSON 数据解析为 ExtraFields 字段
    if err := json.Unmarshal(data, &_p.ExtraFields); err != nil {
        return err
    }

    // 删除不需要的字段
    delete(_p.ExtraFields, "name")
    delete(_p.ExtraFields, "language")
    delete(_p.ExtraFields, "type")
    delete(_p.ExtraFields, "version")
}
# 从 _p.ExtraFields 中删除 "location" 键值对
delete(_p.ExtraFields, "location")

# 如果 _p.ExtraFields 的长度为 0，则将其赋值为 nil
if len(_p.ExtraFields) == 0:
    _p.ExtraFields = nil

# 将新类型实例转换为原始类型并赋值
*p = PackageExclusionConstraint(_p)
# 返回空值
return nil
```