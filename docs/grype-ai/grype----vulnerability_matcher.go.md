# `grype\grype\vulnerability_matcher.go`

```
// 导入 grype 包
package grype

// 导入 fmt 包，用于格式化输出
import (
	"fmt"
	// 导入 slices 包
	"slices"
	// 导入 strings 包，用于处理字符串
	"strings"

	// 导入 go-partybus 包
	"github.com/wagoodman/go-partybus"
	// 导入 go-progress 包
	"github.com/wagoodman/go-progress"

	// 导入 grypeDb 包，用于数据库操作
	grypeDb "github.com/anchore/grype/grype/db/v5"
	// 导入 distro 包，用于处理发行版信息
	"github.com/anchore/grype/grype/distro"
	// 导入 event 包，用于事件处理
	"github.com/anchore/grype/grype/event"
	// 导入 monitor 包，用于监控事件
	"github.com/anchore/grype/grype/event/monitor"
	// 导入 grypeerr 包，用于处理 grype 错误
	"github.com/anchore/grype/grype/grypeerr"
	// 导入 match 包，用于匹配
	"github.com/anchore/grype/grype/match"
	// 导入 matcher 包，用于匹配器
	"github.com/anchore/grype/grype/matcher"
	// 导入 stock 包，用于存储匹配器
	"github.com/anchore/grype/grype/matcher/stock"
	// 导入 pkg 包，用于处理软件包信息
	"github.com/anchore/grype/grype/pkg"
	// 导入 store 包，用于存储操作
	"github.com/anchore/grype/grype/store"
// 导入 vex 包，用于处理漏洞数据
"github.com/anchore/grype/grype/vex"
// 导入 vulnerability 包，用于处理漏洞数据
"github.com/anchore/grype/grype/vulnerability"
// 导入 bus 包，用于内部通信
"github.com/anchore/grype/internal/bus"
// 导入 log 包，用于日志记录
"github.com/anchore/grype/internal/log"
// 导入 linux 包，用于处理 Linux 相关信息
"github.com/anchore/syft/syft/linux"
// 导入 syftPkg 包，用于处理软件包信息
syftPkg "github.com/anchore/syft/syft/pkg"

// 定义常量 branch 为 "├──"，用于表示树状结构中的分支节点
const (
	branch = "├──"
	// 定义常量 leaf 为 "└──"，用于表示树状结构中的叶子节点
	leaf   = "└──"
)

// 定义 VulnerabilityMatcher 结构体，用于匹配漏洞
type VulnerabilityMatcher struct {
	// 存储漏洞数据的存储对象
	Store          store.Store
	// 用于匹配漏洞的匹配器列表
	Matchers       []matcher.Matcher
	// 忽略规则列表
	IgnoreRules    []match.IgnoreRule
	// 指定的漏洞严重程度
	FailSeverity   *vulnerability.Severity
	// 是否按 CVE 规范化
	NormalizeByCVE bool
	// 漏洞处理器
	VexProcessor   *vex.Processor
}
// 创建一个默认的漏洞匹配器，使用给定的存储
func DefaultVulnerabilityMatcher(store store.Store) *VulnerabilityMatcher {
	// 返回一个漏洞匹配器对象，包含给定的存储和默认的匹配器
	return &VulnerabilityMatcher{
		Store:    store,
		Matchers: matcher.NewDefaultMatchers(matcher.Config{}),
	}
}

// 设置匹配器失败的严重程度
func (m *VulnerabilityMatcher) FailAtOrAboveSeverity(severity *vulnerability.Severity) *VulnerabilityMatcher {
	// 设置匹配器的失败严重程度，并返回匹配器对象
	m.FailSeverity = severity
	return m
}

// 设置匹配器的匹配规则
func (m *VulnerabilityMatcher) WithMatchers(matchers []matcher.Matcher) *VulnerabilityMatcher {
	// 设置匹配器的匹配规则，并返回匹配器对象
	m.Matchers = matchers
	return m
}

// 设置匹配器的忽略规则
func (m *VulnerabilityMatcher) WithIgnoreRules(ignoreRules []match.IgnoreRule) *VulnerabilityMatcher {
	// 设置匹配器的忽略规则，并返回匹配器对象
// 设置忽略规则
m.IgnoreRules = ignoreRules
// 返回匹配器对象
return m
}

// 查找匹配项
func (m *VulnerabilityMatcher) FindMatches(pkgs []pkg.Package, context pkg.Context) (remainingMatches *match.Matches, ignoredMatches []match.IgnoredMatch, err error) {
    // 跟踪匹配进度
    progressMonitor := trackMatcher(len(pkgs))

    // 延迟执行，用于在函数返回时设置进度监视器状态
    defer func() {
        progressMonitor.SetCompleted()
        if err != nil {
            progressMonitor.MatchesDiscovered.SetError(err)
        }
    }()

    // 查找数据库匹配项
    remainingMatches, ignoredMatches, err = m.findDBMatches(pkgs, context, progressMonitor)
    if err != nil {
        return remainingMatches, ignoredMatches, err
    }

    // 查找 VEX 匹配项
    remainingMatches, ignoredMatches, err = m.findVEXMatches(context, remainingMatches, ignoredMatches, progressMonitor)
```

// 如果发生错误，返回错误信息
if err != nil {
    err = fmt.Errorf("unable to find matches against VEX sources: %w", err)
    return remainingMatches, ignoredMatches, err
}

// 记录匹配结果的摘要日志
logListSummary(progressMonitor)

// 记录被忽略的匹配日志
logIgnoredMatches(ignoredMatches)

// 返回剩余的匹配结果、被忽略的匹配结果和空错误
return remainingMatches, ignoredMatches, nil
}

// 在漏洞数据库中查找匹配项
func (m *VulnerabilityMatcher) findDBMatches(pkgs []pkg.Package, context pkg.Context, progressMonitor *monitorWriter) (*match.Matches, []match.IgnoredMatch, error) {
    var ignoredMatches []match.IgnoredMatch

    // 记录日志，表示正在在数据库中查找匹配项
    log.Trace("finding matches against DB")
    // 在数据库中搜索匹配项
    matches, err := m.searchDBForMatches(context.Distro, pkgs, progressMonitor)
    // 如果发生错误，返回错误信息
    if err != nil {
        return nil, nil, fmt.Errorf("unable to find matches in DB: %w", err)
    }
# 应用忽略规则到匹配结果中，返回匹配结果和被忽略的匹配结果
matches, ignoredMatches = m.applyIgnoreRules(matches)

# 如果需要按照 CVE 进行规范化
if m.NormalizeByCVE:
    # 创建一个新的匹配结果对象
    normalizedMatches := match.NewMatches()
    # 遍历原始匹配结果，对每个匹配结果进行 CVE 规范化，并添加到新的匹配结果对象中
    for originalMatch := range matches.Enumerate():
        normalizedMatches.Add(m.normalizeByCVE(originalMatch))

    # 再次应用忽略规则，以防止在规范化过程中对结果进行了转换，可能导致结果回退（相对于已应用的忽略规则）。
    # 为什么在规范化之前还要额外应用忽略规则？因为用户可能有一个规则，用于忽略非规范化的漏洞 ID，我们希望确保该规则得到遵守。
    matches, ignoredMatches = m.applyIgnoreRules(normalizedMatches)

# 如果失败严重性不为空，并且匹配结果中存在严重性大于等于指定严重性的漏洞
if m.FailSeverity != nil && HasSeverityAtOrAbove(m.Store, *m.FailSeverity, matches):
    # 设置错误为超过严重性阈值的错误
    err = grypeerr.ErrAboveSeverityThreshold
// 返回匹配结果、被忽略的匹配结果和错误
func (m *VulnerabilityMatcher) searchDBForMatches(
	release *linux.Release,
	packages []pkg.Package,
	progressMonitor *monitorWriter,
) (match.Matches, error) {
	// 初始化错误变量
	var err error
	// 创建匹配结果对象
	res := match.NewMatches()
	// 创建匹配器索引和默认匹配器
	matcherIndex, defaultMatcher := newMatcherIndex(m.Matchers)

	// 创建 Linux 发行版对象
	var d *distro.Distro
	// 如果有发行版信息，则根据发行版信息创建 Linux 发行版对象
	if release != nil {
		d, err = distro.NewFromRelease(*release)
		// 如果创建发行版对象出错，则记录警告日志
		if err != nil {
			log.Warnf("unable to determine linux distribution: %+v", err)
		}
		// 如果发行版对象不为空且被禁用，则记录警告日志
		if d != nil && d.Disabled() {
			log.Warnf("unsupported linux distribution: %s", d.Name())
# 返回一个新的匹配对象和空的错误
return match.NewMatches(), nil
# 如果存在分发系统并且分发类型为Wolfi、Chainguard或Alpine，则创建一个以文件路径为键的假阳性分布映射
distroFalsePositivesByLocationPath := make(map[string][]string)
# 如果存在分发系统并且分发类型为Wolfi、Chainguard或Alpine，则调用indexFalsePositivesByLocation函数，将假阳性分布映射赋值给distroFalsePositivesByLocationPath
if d != nil && (d.Type == distro.Wolfi || d.Type == distro.Chainguard || d.Type == distro.Alpine) {
    distroFalsePositivesByLocationPath, err = indexFalsePositivesByLocation(d, packages, m.Store)
    # 如果出现错误，则返回空的匹配对象和错误
    if err != nil {
        return match.Matches{}, err
    }
}
# 如果默认匹配器为空，则创建一个新的默认匹配器
if defaultMatcher == nil {
    defaultMatcher = stock.NewStockMatcher(stock.MatcherConfig{UseCPEs: true})
}
# 遍历包列表
for _, p := range packages:
    # 增加进度监视器中已处理的包数量
    progressMonitor.PackagesProcessed.Increment()
    # 输出日志，记录正在搜索漏洞匹配的包
    log.WithFields("package", displayPackage(p)).Trace("searching for vulnerability matches")
    # 获取匹配器索引中与包类型对应的匹配器
    matchAgainst, ok := matcherIndex[p.Type]
# 如果没有匹配器，则使用默认匹配器
if !ok {
    matchAgainst = []matcher.Matcher{defaultMatcher}
}
# 遍历所有的匹配器
for _, theMatcher := range matchAgainst {
    # 使用匹配器匹配存储、包和路径，返回匹配结果和错误
    matches, err := theMatcher.Match(m.Store, d, p)
    # 如果出现错误，记录日志并继续下一个匹配器
    if err != nil {
        log.WithFields("error", err, "package", displayPackage(p)).Warn("matcher failed")
        continue
    }

    # 使用分布式误报列表过滤匹配结果
    matches = filterMatchesUsingDistroFalsePositives(matches, distroFalsePositivesByLocationPath)

    # 根据数据库排除表和硬编码规则过滤匹配结果
    filtered, dropped := match.ApplyExplicitIgnoreRules(m.Store, match.NewMatches(matches...))

    # 获取额外的匹配结果并记录日志
    additionalMatches := filtered.Sorted()
    logPackageMatches(p, additionalMatches)
    logExplicitDroppedPackageMatches(p, dropped)
    # 将额外的匹配结果添加到结果集中
    res.Add(additionalMatches...)
}
			// 将additionalMatches的长度转换为int64类型，并添加到MatchesDiscovered中
			progressMonitor.MatchesDiscovered.Add(int64(len(additionalMatches)))

			// 注意：在“ignore”和“dropped”匹配之间存在差异。
			// ignored：由于用户提供的忽略规则而被过滤掉的匹配
			// dropped：由于硬编码规则而被过滤掉的匹配
			// 更新漏洞列表，将additionalMatches中的匹配添加到progressMonitor中，同时将dropped和m.Store传递给updateVulnerabilityList函数
			updateVulnerabilityList(progressMonitor, additionalMatches, nil, dropped, m.Store)
		}
	}

	return res, nil
}

// 根据位置索引虚假阳性
func indexFalsePositivesByLocation(
	d *distro.Distro,
	packages []pkg.Package,
	s store.Store,
) (map[string][]string, error) {
	// 创建一个映射，用于存储虚假阳性的位置路径
	distroFalsePositivesByLocationPath := make(map[string][]string)

	// 遍历包列表
	for _, p := range packages {
// 通过位置获取分布式误报，如果出现错误则返回空和错误
falsePositivesByLocation, err := getDistroFalsePositivesByLocation(s, d, p)
if err != nil {
    return nil, err
}
// 遍历分布式误报，将误报添加到对应位置的路径中
for l, vulnIDs := range falsePositivesByLocation {
    distroFalsePositivesByLocationPath[l] = append(distroFalsePositivesByLocationPath[l], vulnIDs...)
}
}

// 返回分布式误报的位置路径和空
return distroFalsePositivesByLocationPath, nil
}

// 获取分布式误报的位置
func getDistroFalsePositivesByLocation(s store.Store, d *distro.Distro, p pkg.Package) (map[string][]string, error) {
    // 创建一个空的结果映射
    result := make(map[string][]string)

    // 如果数据是 APK 元数据，则获取分布式误报的条目
    if data, ok := p.Metadata.(pkg.ApkMetadata); ok {
        entries, err := s.GetByDistro(d, p)
        // 如果出现错误则返回空和错误
        if err != nil {
            return nil, err
        }
# 遍历 entries 列表中的每个元素
for _, entry := range entries:
    # 如果 entry 的约束条件为 "< 0 (apk)"
    if entry.Constraint.String() == "< 0 (apk)":
        # 遍历 data.Files 中的每个文件
        for _, f := range data.Files:
            # 将 entry.ID 添加到 result[f.Path] 对应的列表中
            result[f.Path] = append(result[f.Path], entry.ID)

# 遍历 pkg.UpstreamPackages(p) 中的每个上游包
for _, upstreamPkg := range pkg.UpstreamPackages(p):
    # 获取上游包对应的条目列表 entriesForUpstream 和可能的错误
    entriesForUpstream, err := s.GetByDistro(d, upstreamPkg)
    # 如果出现错误，返回空和错误信息
    if err != nil:
        return nil, err
    # 遍历 entriesForUpstream 列表中的每个元素
    for _, entry := range entriesForUpstream:
        # 如果 entry 的约束条件为 "< 0 (apk)"
        if entry.Constraint.String() == "< 0 (apk)":
            # 遍历 data.Files 中的每个文件
            for _, f := range data.Files:
                # 将 entry.ID 添加到 result[f.Path] 对应的列表中
                result[f.Path] = append(result[f.Path], entry.ID)
// 使用 distroFalsePositives 过滤匹配项
func filterMatchesUsingDistroFalsePositives(ms []match.Match, falsePositivesByLocation map[string][]string) []match.Match {
	// 初始化结果数组
	var result []match.Match
	// 遍历匹配项数组
	for _, m := range ms {
		// 初始化是否为误报标志
		isFalsePositive := false

		// 遍历匹配项的包位置
		for _, l := range m.Package.Locations.ToSlice() {
			// 如果该位置存在误报漏洞 ID
			if fpVulnIDs, ok := falsePositivesByLocation[l.RealPath]; ok {
				// 如果匹配项的漏洞 ID 存在于误报漏洞 ID 中
				if slices.Contains(fpVulnIDs, m.Vulnerability.ID) {
					// 设置为误报
					isFalsePositive = true
					// 跳出循环
					break
				}

				// 遍历匹配项的相关漏洞
				for _, relatedVulnerability := range m.Vulnerability.RelatedVulnerabilities {
					// 如果相关漏洞 ID 存在于误报漏洞 ID 中
					if slices.Contains(fpVulnIDs, relatedVulnerability.ID) {
# 初始化变量 isFalsePositive 为 true，用于标记是否为误报
isFalsePositive = true
# 跳出当前循环，继续执行下一步
break
# 如果条件成立，则执行下面的代码块
if !isFalsePositive {
    # 将 m 添加到 result 数组中
    result = append(result, m)
# 如果条件不成立，则执行下面的代码块
} else {
    # 记录日志，标记为误报并使用 distro 安全数据进行丢弃
    log.WithFields("vuln", m.Vulnerability.ID, "package", displayPackage(m.Package)).Trace("dropping false positive using distro security data")
# 返回 result 数组
return result
# 如果 m.VexProcessor 为 nil，则记录日志并返回 remainingMatches、ignoredMatches 和 nil
if m.VexProcessor == nil {
    log.Trace("no VEX documents provided, skipping VEX matching")
    return remainingMatches, ignoredMatches, nil
	}

	// 跟踪日志，查找可用的 VEX 文档匹配
	log.Trace("finding matches against available VEX documents")
	// 应用 VEX 处理器，找到匹配的结果和被忽略的匹配
	matchesAfterVex, ignoredMatchesAfterVex, err := m.VexProcessor.ApplyVEX(&context, remainingMatches, ignoredMatches)
	// 如果出现错误，返回错误信息
	if err != nil {
		return nil, nil, fmt.Errorf("unable to find matches against VEX documents: %w", err)
	}

	// 计算 VEX 处理后的匹配结果与剩余匹配的差异
	diffMatches := matchesAfterVex.Diff(*remainingMatches)
	// 计算被忽略的匹配的差异
	diffIgnoredMatches := ignoredMatchesDiff(ignoredMatchesAfterVex, ignoredMatches)

	// 更新漏洞列表，传入进度监视器、差异匹配结果、差异被忽略的匹配结果和存储对象
	updateVulnerabilityList(progressMonitor, diffMatches.Sorted(), diffIgnoredMatches, nil, m.Store)

	// 返回 VEX 处理后的匹配结果和被忽略的匹配结果
	return matchesAfterVex, ignoredMatchesAfterVex, nil
}

// 应用忽略规则到匹配结果
func (m *VulnerabilityMatcher) applyIgnoreRules(matches match.Matches) (match.Matches, []match.IgnoredMatch) {
	var ignoredMatches []match.IgnoredMatch
	// 如果忽略规则为空，直接返回
	if len(m.IgnoreRules) == 0 {
		return matches, ignoredMatches
	}

	// 应用用户提供的忽略规则，获取匹配和被忽略的匹配
	matches, ignoredMatches = match.ApplyIgnoreRules(matches, m.IgnoreRules)

	// 如果被忽略的匹配数量大于0，则记录日志
	if count := len(ignoredMatches); count > 0 {
		log.Infof("ignoring %d matches due to user-provided ignore rules", count)
	}
	return matches, ignoredMatches
}

// 根据CVE规范化匹配
func (m *VulnerabilityMatcher) normalizeByCVE(match match.Match) match.Match {
	// 如果匹配的漏洞ID符合CVE规范，则直接返回匹配
	if isCVE(match.Vulnerability.ID) {
		return match
	}

	// 如果匹配的漏洞相关的漏洞ID符合CVE规范，则添加到有效的CVE记录引用中
	var effectiveCVERecordRefs []vulnerability.Reference
	for _, ref := range match.Vulnerability.RelatedVulnerabilities {
		if isCVE(ref.ID) {
			effectiveCVERecordRefs = append(effectiveCVERecordRefs, ref)
		// 如果找到匹配的CVE记录，则跳出循环
		break
	}

	// 根据effectiveCVERecordRefs的长度进行不同的处理
	switch len(effectiveCVERecordRefs) {
	case 0:
		// 如果没有找到CVE记录，则记录日志并跳过规范化
		log.WithFields(
			"vuln", match.Vulnerability.ID,
			"package", displayPackage(match.Package),
		).Trace("unable to find CVE record for vulnerability, skipping normalization")
		return match
	case 1:
		// 如果只找到一个CVE记录，则继续执行
		break
	default:
		// 如果找到多个CVE记录，则记录日志并跳过规范化
		log.WithFields(
			"refs", fmt.Sprintf("%+v", effectiveCVERecordRefs),
			"vuln", match.Vulnerability.ID,
			"package", displayPackage(match.Package),
		).Trace("found multiple CVE records for vulnerability, skipping normalization")
		return match
	}

	// 从 effectiveCVERecordRefs 数组中获取第一个元素
	ref := effectiveCVERecordRefs[0]

	// 从存储中获取 ref.ID 和 ref.Namespace 对应的元数据
	upstreamMetadata, err := m.Store.GetMetadata(ref.ID, ref.Namespace)
	if err != nil {
		// 如果出现错误，记录日志并返回 match
		log.WithFields("id", ref.ID, "namespace", ref.Namespace, "error", err).Warn("unable to fetch effective CVE metadata")
		return match
	}

	// 如果获取的 upstreamMetadata 为空，返回 match
	if upstreamMetadata == nil {
		return match
	}

	// 创建一个原始的 vulnerability.Reference 对象
	originalRef := vulnerability.Reference{
		ID:        match.Vulnerability.ID,
		Namespace: match.Vulnerability.Namespace,
	}

	// 将 match.Vulnerability.ID 更新为 upstreamMetadata.ID
	match.Vulnerability.ID = upstreamMetadata.ID
// 将匹配的漏洞的命名空间设置为上游元数据的命名空间
match.Vulnerability.Namespace = upstreamMetadata.Namespace
// 将匹配的漏洞的相关漏洞设置为空的漏洞引用
match.Vulnerability.RelatedVulnerabilities = []vulnerability.Reference{originalRef}
// 返回匹配结果
return match
}

// 显示包的信息，如果包的 PURL 不为空，则返回 PURL，否则返回格式化的包名、版本和类型
func displayPackage(p pkg.Package) string {
    if p.PURL != "" {
        return p.PURL
    }
    return fmt.Sprintf("%s@%s (%s)", p.Name, p.Version, p.Type)
}

// 返回两个忽略匹配的差异
func ignoredMatchesDiff(subject []match.IgnoredMatch, other []match.IgnoredMatch) []match.IgnoredMatch {
    // TODO（alex）：这种实现的缺点是它没有考虑相同的忽略匹配因不同原因而被忽略（appliedIgnoreRules 字段）。

    // 创建一个 map 用于存储 other 中的忽略匹配
    otherMap := make(map[match.Fingerprint]struct{})
    // 遍历 other 切片，将忽略匹配的指纹作为键存储到 map 中
    for _, a := range other {
        otherMap[a.Match.Fingerprint()] = struct{}{}
// 创建一个空的忽略匹配列表
var diff []match.IgnoredMatch
// 遍历主题中的每个元素
for _, b := range subject {
    // 如果其他地图中不包含当前元素的指纹
    if _, ok := otherMap[b.Match.Fingerprint()]; !ok {
        // 将当前元素添加到忽略匹配列表中
        diff = append(diff, b)
    }
}

// 返回忽略匹配列表
return diff
}

// 创建一个新的匹配器索引
func newMatcherIndex(matchers []matcher.Matcher) (map[syftPkg.Type][]matcher.Matcher, matcher.Matcher) {
    // 创建一个空的匹配器索引
    matcherIndex := make(map[syftPkg.Type][]matcher.Matcher)
    // 创建一个默认匹配器
    var defaultMatcher matcher.Matcher
    // 遍历匹配器列表
    for _, m := range matchers {
        // 如果当前匹配器是库存匹配器
        if m.Type() == match.StockMatcher {
            // 将当前匹配器设置为默认匹配器
            defaultMatcher = m
            continue
        }
		// 遍历包类型切片，将每个包类型添加到匹配器索引中
		for _, t := range m.PackageTypes() {
			// 如果匹配器索引中不存在该包类型，则创建一个空的匹配器切片
			if _, ok := matcherIndex[t]; !ok {
				matcherIndex[t] = make([]matcher.Matcher, 0)
			}

			// 将当前匹配器添加到对应包类型的匹配器切片中
			matcherIndex[t] = append(matcherIndex[t], m)
			// 记录日志，添加匹配器
			log.Debugf("adding matcher: %+v", t)
		}
	}

	// 返回匹配器索引和默认匹配器
	return matcherIndex, defaultMatcher
}

// 判断是否为CVE漏洞
func isCVE(id string) bool {
	// 判断漏洞ID是否以"cve-"开头，忽略大小写
	return strings.HasPrefix(strings.ToLower(id), "cve-")
}

// 判断漏洞严重程度是否达到或超过指定级别
func HasSeverityAtOrAbove(store vulnerability.MetadataProvider, severity vulnerability.Severity, matches match.Matches) bool {
	// 如果严重程度为未知，则返回false
	if severity == vulnerability.UnknownSeverity {
		return false
// 遍历匹配结果的元数据
for m := range matches.Enumerate() {
    // 获取漏洞的元数据
    metadata, err := store.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
    // 如果获取元数据出错，则继续下一个匹配
    if err != nil {
        continue
    }

    // 解析漏洞严重程度，并与给定严重程度比较
    if vulnerability.ParseSeverity(metadata.Severity) >= severity {
        // 如果漏洞严重程度大于等于给定严重程度，则返回 true
        return true
    }
}
// 如果没有匹配的漏洞严重程度大于等于给定严重程度，则返回 false
return false
}

// 记录漏洞列表的摘要信息
func logListSummary(vl *monitorWriter) {
    // 记录发现的漏洞匹配数量和处理的软件包数量
    log.Infof("found %d vulnerability matches across %d packages", vl.MatchesDiscovered.Current(), vl.PackagesProcessed.Current())
    // 记录修复的漏洞数量
    log.Debugf("  ├── fixed: %d", vl.Fixed.Current())
    // 记录由于用户提供的规则而被忽略的漏洞数量
    log.Debugf("  ├── ignored: %d (due to user-provided rule)", vl.Ignored.Current())
    // 记录由于硬编码修正而被丢弃的漏洞数量
    log.Debugf("  ├── dropped: %d (due to hard-coded correction)", vl.Dropped.Current())
    // 记录匹配的漏洞数量
    log.Debugf("  └── matched: %d", vl.MatchesDiscovered.Current())
```

// 声明一个未知数量的变量
var unknownCount int64
// 如果存在未知严重性的漏洞，则将其数量赋给unknownCount
if count, ok := vl.BySeverity[vulnerability.UnknownSeverity]; ok {
    unknownCount = count.Current()
}
// 打印未知严重性漏洞的数量
log.Debugf("      ├── %s: %d", vulnerability.UnknownSeverity.String(), unknownCount)

// 获取所有严重性的列表
allSeverities := vulnerability.AllSeverities()
// 遍历所有严重性
for idx, sev := range allSeverities {
    // 选择并打印适当的标识符和严重性的数量
    arm := selectArm(idx, len(allSeverities))
    log.Debugf("      %s %s: %d", arm, sev.String(), vl.BySeverity[sev].Current())
}

// 更新漏洞列表
func updateVulnerabilityList(mon *monitorWriter, matches []match.Match, ignores []match.IgnoredMatch, dropped []match.IgnoredMatch, metadataProvider vulnerability.MetadataProvider) {
    // 遍历所有匹配的漏洞
    for _, m := range matches {
        // 获取漏洞的元数据
        metadata, err := metadataProvider.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
        // 如果获取元数据出错或者元数据为空，则将未知严重性漏洞数量增加
        if err != nil || metadata == nil {
            mon.BySeverity[vulnerability.UnknownSeverity].Increment()
            continue
		}

		// 通过漏洞严重程度解析得到的严重程度，查找对应的手动处理进度
		sevManualProgress, ok := mon.BySeverity[vulnerability.ParseSeverity(metadata.Severity)]
		// 如果没有找到对应的手动处理进度，则将漏洞归类为未知严重程度，并增加计数
		if !ok {
			mon.BySeverity[vulnerability.UnknownSeverity].Increment()
			continue
		}
		// 找到对应的手动处理进度，增加计数
		sevManualProgress.Increment()

		// 如果漏洞的修复状态为已修复，则增加计数
		if m.Vulnerability.Fix.State == grypeDb.FixedState {
			mon.Fixed.Increment()
		}
	}

	// 增加忽略的漏洞数量到统计中
	mon.Ignored.Add(int64(len(ignores)))
	// 增加被丢弃的漏洞数量到统计中
	mon.Dropped.Add(int64(len(dropped)))
}

// 记录包的匹配情况
func logPackageMatches(p pkg.Package, matches []match.Match) {
	// 如果没有匹配结果，则返回
	if len(matches) == 0 {
		// 如果没有匹配的漏洞，直接返回
		return
	}

	// 记录日志，显示找到的漏洞数量
	log.WithFields("package", displayPackage(p)).Debugf("found %d vulnerabilities", len(matches))
	// 遍历匹配的漏洞，选择对应的 arm，并记录日志
	for idx, m := range matches {
		arm := selectArm(idx, len(matches))
		log.WithFields("vuln", m.Vulnerability.ID, "namespace", m.Vulnerability.Namespace).Debugf("  %s", arm)
	}
}

// 根据索引和总数选择 arm
func selectArm(idx, total int) string {
	if idx == total-1 {
		return leaf
	}
	return branch
}

// 记录明确被忽略的包匹配
func logExplicitDroppedPackageMatches(p pkg.Package, ignored []match.IgnoredMatch) {
	// 如果没有被忽略的匹配，直接返回
	if len(ignored) == 0 {
		return
	}
// 结束函数
	}

	// 记录由于硬编码修正而丢弃的漏洞匹配数量
	log.WithFields("package", displayPackage(p)).Debugf("dropped %d vulnerability matches due to hard-coded correction", len(ignored))
	// 遍历被忽略的漏洞匹配
	for idx, i := range ignored {
		// 选择日志级别
		arm := selectArm(idx, len(ignored))

		// 记录被忽略的漏洞匹配的详细信息
		log.WithFields("vuln", i.Match.Vulnerability.ID, "rules", len(i.AppliedIgnoreRules)).Debugf("  %s", arm)
	}
}

// 记录被忽略的匹配
func logIgnoredMatches(ignored []match.IgnoredMatch) {
	// 如果被忽略的匹配数量为0，则返回
	if len(ignored) == 0 {
		return
	}

	// 记录被忽略的漏洞匹配数量
	log.Infof("ignored %d vulnerability matches", len(ignored))
	// 遍历被忽略的漏洞匹配
	for idx, i := range ignored {
		// 选择日志级别
		arm := selectArm(idx, len(ignored))

		// 记录被忽略的漏洞匹配的详细信息
		log.WithFields("vuln", i.Match.Vulnerability.ID, "rules", len(i.AppliedIgnoreRules), "package", displayPackage(i.Package)).Debugf("  %s", arm)
```
	}
}

type monitorWriter struct {
	PackagesProcessed *progress.Manual  // 用于跟踪已处理的软件包数量的进度条
	MatchesDiscovered *progress.Manual  // 用于跟踪已发现的匹配数量的进度条
	Fixed             *progress.Manual  // 用于跟踪已修复的漏洞数量的进度条
	Ignored           *progress.Manual  // 用于跟踪已忽略的漏洞数量的进度条
	Dropped           *progress.Manual  // 用于跟踪已丢弃的漏洞数量的进度条
	BySeverity        map[vulnerability.Severity]*progress.Manual  // 用于跟踪每个严重程度的漏洞数量的进度条
}

func newMonitor(pkgCount int) (monitorWriter, monitor.Matching) {
	manualBySev := make(map[vulnerability.Severity]*progress.Manual)
	for _, severity := range vulnerability.AllSeverities() {
		manualBySev[severity] = progress.NewManual(-1)  // 初始化每个严重程度的漏洞数量进度条
	}
	manualBySev[vulnerability.UnknownSeverity] = progress.NewManual(-1)  // 初始化未知严重程度的漏洞数量进度条

	m := monitorWriter{  // 创建监视器写入器对象
		# 创建一个包含进度信息的结构体，并初始化 PackagesProcessed 字段
		PackagesProcessed: progress.NewManual(int64(pkgCount)),
		# 创建一个包含进度信息的结构体，并初始化 MatchesDiscovered 字段
		MatchesDiscovered: progress.NewManual(-1),
		# 创建一个包含进度信息的结构体，并初始化 Fixed 字段
		Fixed:             progress.NewManual(-1),
		# 创建一个包含进度信息的结构体，并初始化 Ignored 字段
		Ignored:           progress.NewManual(-1),
		# 创建一个包含进度信息的结构体，并初始化 Dropped 字段
		Dropped:           progress.NewManual(-1),
		# 创建一个映射，将漏洞严重程度和进度信息结构体关联起来
		BySeverity:        manualBySev,
	}

	# 创建一个映射，将漏洞严重程度和进度信息结构体关联起来
	monitorableBySev := make(map[vulnerability.Severity]progress.Monitorable)
	for sev, manual := range manualBySev {
		monitorableBySev[sev] = manual
	}

	# 返回包含进度信息的结构体和漏洞严重程度的映射
	return m, monitor.Matching{
		PackagesProcessed: m.PackagesProcessed,
		MatchesDiscovered: m.MatchesDiscovered,
		Fixed:             m.Fixed,
		Ignored:           m.Ignored,
		Dropped:           m.Dropped,
		BySeverity:        monitorableBySev,
// 设置监视器为已完成状态
func (m *monitorWriter) SetCompleted() {
    // 设置 PackagesProcessed 为已完成状态
    m.PackagesProcessed.SetCompleted()
    // 设置 MatchesDiscovered 为已完成状态
    m.MatchesDiscovered.SetCompleted()
    // 设置 Fixed 为已完成状态
    m.Fixed.SetCompleted()
    // 设置 Ignored 为已完成状态
    m.Ignored.SetCompleted()
    // 设置 Dropped 为已完成状态
    m.Dropped.SetCompleted()
    // 遍历 BySeverity 切片，设置每个元素为已完成状态
    for _, v := range m.BySeverity {
        v.SetCompleted()
    }
}

// 创建一个监视器写入器，用于跟踪匹配器
func trackMatcher(pkgCount int) *monitorWriter {
    // 创建一个新的监视器，并返回写入器和读取器
    writer, reader := newMonitor(pkgCount)

    // 发布事件，表示漏洞扫描已经开始
    bus.Publish(partybus.Event{
        Type:  event.VulnerabilityScanningStarted,
        Value: reader,
    })
# 返回一个指向writer的指针
return &writer
```