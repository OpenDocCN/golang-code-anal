# `grype\grype\vulnerability_matcher.go`

```go
package grype

import (
    "fmt" // 导入 fmt 包，用于格式化输出
    "slices" // 导入 slices 包，用于处理切片
    "strings" // 导入 strings 包，用于处理字符串

    "github.com/wagoodman/go-partybus" // 导入第三方库 go-partybus
    "github.com/wagoodman/go-progress" // 导入第三方库 go-progress

    grypeDb "github.com/anchore/grype/grype/db/v5" // 导入 grypeDb 包，用于处理 grype 数据库
    "github.com/anchore/grype/grype/distro" // 导入 distro 包，用于处理发行版信息
    "github.com/anchore/grype/grype/event" // 导入 event 包，用于处理事件
    "github.com/anchore/grype/grype/event/monitor" // 导入 monitor 包，用于监控事件
    "github.com/anchore/grype/grype/grypeerr" // 导入 grypeerr 包，用于处理 grype 错误
    "github.com/anchore/grype/grype/match" // 导入 match 包，用于匹配
    "github.com/anchore/grype/grype/matcher" // 导入 matcher 包，用于匹配器
    "github.com/anchore/grype/grype/matcher/stock" // 导入 stock 包，用于处理股票匹配器
    "github.com/anchore/grype/grype/pkg" // 导入 pkg 包，用于处理包
    "github.com/anchore/grype/grype/store" // 导入 store 包，用于处理存储
    "github.com/anchore/grype/grype/vex" // 导入 vex 包，用于处理 vex
    "github.com/anchore/grype/grype/vulnerability" // 导入 vulnerability 包，用于处理漏洞
    "github.com/anchore/grype/internal/bus" // 导入 bus 包，用于处理内部总线
    "github.com/anchore/grype/internal/log" // 导入 log 包，用于处理日志
    "github.com/anchore/syft/syft/linux" // 导入 linux 包，用于处理 Linux 相关信息
    syftPkg "github.com/anchore/syft/syft/pkg" // 导入 syftPkg 包，用于处理 syft 包
)

const (
    branch = "├──" // 定义分支符号
    leaf   = "└──" // 定义叶子符号
)

type VulnerabilityMatcher struct {
    Store          store.Store // 存储对象
    Matchers       []matcher.Matcher // 匹配器列表
    IgnoreRules    []match.IgnoreRule // 忽略规则列表
    FailSeverity   *vulnerability.Severity // 失败严重性
    NormalizeByCVE bool // 是否按 CVE 规范化
    VexProcessor   *vex.Processor // vex 处理器
}

func DefaultVulnerabilityMatcher(store store.Store) *VulnerabilityMatcher {
    return &VulnerabilityMatcher{
        Store:    store, // 初始化存储对象
        Matchers: matcher.NewDefaultMatchers(matcher.Config{}), // 初始化默认匹配器
    }
}

func (m *VulnerabilityMatcher) FailAtOrAboveSeverity(severity *vulnerability.Severity) *VulnerabilityMatcher {
    m.FailSeverity = severity // 设置失败严重性
    return m
}

func (m *VulnerabilityMatcher) WithMatchers(matchers []matcher.Matcher) *VulnerabilityMatcher {
    m.Matchers = matchers // 设置匹配器列表
    return m
}

func (m *VulnerabilityMatcher) WithIgnoreRules(ignoreRules []match.IgnoreRule) *VulnerabilityMatcher {
    m.IgnoreRules = ignoreRules // 设置忽略规则列表
    return m
}

func (m *VulnerabilityMatcher) FindMatches(pkgs []pkg.Package, context pkg.Context) (remainingMatches *match.Matches, ignoredMatches []match.IgnoredMatch, err error) {
    // 查找匹配项
    // 创建一个进度监视器，用于跟踪匹配的进度
    progressMonitor := trackMatcher(len(pkgs))

    // 在函数返回时，设置进度监视器为已完成状态，并在发生错误时设置匹配发现错误
    defer func() {
        progressMonitor.SetCompleted()
        if err != nil {
            progressMonitor.MatchesDiscovered.SetError(err)
        }
    }()

    // 在数据库中查找匹配的软件包，并返回剩余匹配、被忽略的匹配和可能的错误
    remainingMatches, ignoredMatches, err = m.findDBMatches(pkgs, context, progressMonitor)
    if err != nil {
        return remainingMatches, ignoredMatches, err
    }

    // 在 VEX 源中查找匹配的软件包，并返回剩余匹配、被忽略的匹配和可能的错误
    remainingMatches, ignoredMatches, err = m.findVEXMatches(context, remainingMatches, ignoredMatches, progressMonitor)
    if err != nil {
        // 如果无法在 VEX 源中找到匹配，返回错误信息
        err = fmt.Errorf("unable to find matches against VEX sources: %w", err)
        return remainingMatches, ignoredMatches, err
    }

    // 记录匹配的摘要信息
    logListSummary(progressMonitor)

    // 记录被忽略的匹配
    logIgnoredMatches(ignoredMatches)

    // 返回剩余匹配、被忽略的匹配和空错误
    return remainingMatches, ignoredMatches, nil
# 定义一个方法，用于在漏洞数据库中查找匹配项
func (m *VulnerabilityMatcher) findDBMatches(pkgs []pkg.Package, context pkg.Context, progressMonitor *monitorWriter) (*match.Matches, []match.IgnoredMatch, error) {
    var ignoredMatches []match.IgnoredMatch

    # 输出日志，表示正在在数据库中查找匹配项
    log.Trace("finding matches against DB")
    # 在数据库中搜索匹配项
    matches, err := m.searchDBForMatches(context.Distro, pkgs, progressMonitor)
    if err != nil {
        return nil, nil, fmt.Errorf("unable to find matches in DB: %w", err)
    }

    # 应用忽略规则到匹配项
    matches, ignoredMatches = m.applyIgnoreRules(matches)

    # 如果设置了按CVE标准进行规范化
    if m.NormalizeByCVE {
        # 创建一个新的匹配项对象
        normalizedMatches := match.NewMatches()
        # 遍历原始匹配项，按CVE标准进行规范化
        for originalMatch := range matches.Enumerate() {
            normalizedMatches.Add(m.normalizeByCVE(originalMatch))
        }

        # 再次应用忽略规则，以确保规范化过程中不会影响结果
        matches, ignoredMatches = m.applyIgnoreRules(normalizedMatches)
    }

    # 如果设置了失败严重性，并且匹配项中存在严重性高于设定值的漏洞，则返回错误
    if m.FailSeverity != nil && HasSeverityAtOrAbove(m.Store, *m.FailSeverity, matches) {
        err = grypeerr.ErrAboveSeverityThreshold
    }

    return &matches, ignoredMatches, err
}

# 在数据库中搜索匹配项的具体实现
func (m *VulnerabilityMatcher) searchDBForMatches(
    release *linux.Release,
    packages []pkg.Package,
    progressMonitor *monitorWriter,
) (match.Matches, error) {
    var err error
    # 创建一个新的匹配项对象
    res := match.NewMatches()
    # 创建匹配器索引和默认匹配器
    matcherIndex, defaultMatcher := newMatcherIndex(m.Matchers)

    var d *distro.Distro
    # 如果发布信息不为空
    if release != nil:
        # 根据发布信息创建新的发行版对象
        d, err = distro.NewFromRelease(*release)
        # 如果出现错误，记录警告日志
        if err != nil:
            log.Warnf("unable to determine linux distribution: %+v", err)
        # 如果发行版对象存在且被禁用
        if d != nil and d.Disabled():
            # 记录警告日志，返回空匹配结果
            log.Warnf("unsupported linux distribution: %s", d.Name())
            return match.NewMatches(), nil

    # 创建存储位置路径到误报列表的映射
    distroFalsePositivesByLocationPath := make(map[string][]string)
    # 如果发行版对象存在且为 Wolfi、Chainguard 或 Alpine 类型
    if d != nil and (d.Type == distro.Wolfi || d.Type == distro.Chainguard || d.Type == distro.Alpine):
        # 调用函数，获取存储位置路径到误报列表的映射
        distroFalsePositivesByLocationPath, err = indexFalsePositivesByLocation(d, packages, m.Store)
        # 如果出现错误，返回空匹配结果和错误
        if err != nil:
            return match.Matches{}, err

    # 如果默认匹配器为空
    if defaultMatcher == nil:
        # 创建新的默认匹配器对象
        defaultMatcher = stock.NewStockMatcher(stock.MatcherConfig{UseCPEs: true})
    # 遍历给定的包列表
    for _, p := range packages:
        # 增加进度监视器中的已处理包数量
        progressMonitor.PackagesProcessed.Increment()
        # 记录正在搜索漏洞匹配的包信息
        log.WithFields("package", displayPackage(p)).Trace("searching for vulnerability matches")

        # 检查匹配器索引中是否存在当前包的类型
        matchAgainst, ok := matcherIndex[p.Type]
        if !ok:
            # 如果不存在，则使用默认匹配器
            matchAgainst = []matcher.Matcher{defaultMatcher}
        # 遍历匹配器列表
        for _, theMatcher := range matchAgainst:
            # 使用匹配器匹配存储、漏洞数据和当前包
            matches, err := theMatcher.Match(m.Store, d, p)
            if err != nil:
                # 如果匹配过程中出现错误，则记录警告并继续下一个匹配器
                log.WithFields("error", err, "package", displayPackage(p)).Warn("matcher failed")
                continue

            # 使用发行版误报信息过滤匹配结果
            matches = filterMatchesUsingDistroFalsePositives(matches, distroFalsePositivesByLocationPath)

            # 根据数据库排除表和硬编码规则过滤匹配结果
            filtered, dropped := match.ApplyExplicitIgnoreRules(m.Store, match.NewMatches(matches...))

            # 获取额外的匹配结果并记录日志
            additionalMatches := filtered.Sorted()
            logPackageMatches(p, additionalMatches)
            logExplicitDroppedPackageMatches(p, dropped)
            res.Add(additionalMatches...)

            # 增加进度监视器中的已发现匹配数量
            progressMonitor.MatchesDiscovered.Add(int64(len(additionalMatches)))

            # 注意："ignore" 和 "dropped" 匹配之间存在差异。
            # ignored: 根据用户提供的忽略规则过滤掉的匹配
            # dropped: 根据硬编码规则过滤掉的匹配
            # 更新漏洞列表
            updateVulnerabilityList(progressMonitor, additionalMatches, nil, dropped, m.Store)
    }

    # 返回结果和空错误
    return res, nil
// 根据位置索引虚假阳性
func indexFalsePositivesByLocation(
    d *distro.Distro,  // 传入发行版对象指针
    packages []pkg.Package,  // 传入包对象切片
    s store.Store,  // 传入存储对象
) (map[string][]string, error) {  // 返回位置到虚假阳性的映射和错误信息
    distroFalsePositivesByLocationPath := make(map[string][]string)  // 创建位置到虚假阳性的映射

    for _, p := range packages {  // 遍历包切片
        falsePositivesByLocation, err := getDistroFalsePositivesByLocation(s, d, p)  // 获取位置到虚假阳性的映射
        if err != nil {  // 如果出现错误
            return nil, err  // 返回空和错误信息
        }
        for l, vulnIDs := range falsePositivesByLocation {  // 遍历位置到虚假阳性的映射
            distroFalsePositivesByLocationPath[l] = append(distroFalsePositivesByLocationPath[l], vulnIDs...)  // 将虚假阳性添加到位置映射中
        }
    }

    return distroFalsePositivesByLocationPath, nil  // 返回位置到虚假阳性的映射和空错误信息
}

func getDistroFalsePositivesByLocation(s store.Store, d *distro.Distro, p pkg.Package) (map[string][]string, error) {  // 获取位置到虚假阳性的映射和错误信息
    result := make(map[string][]string)  // 创建位置到虚假阳性的映射

    if data, ok := p.Metadata.(pkg.ApkMetadata); ok {  // 如果包的元数据是 APK 元数据
        entries, err := s.GetByDistro(d, p)  // 获取发行版和包的条目
        if err != nil {  // 如果出现错误
            return nil, err  // 返回空和错误信息
        }
        for _, entry := range entries {  // 遍历条目
            if entry.Constraint.String() == "< 0 (apk)" {  // 如果约束条件为 "< 0 (apk)"
                for _, f := range data.Files {  // 遍历文件
                    result[f.Path] = append(result[f.Path], entry.ID)  // 将条目 ID 添加到位置映射中
                }
            }
        }

        for _, upstreamPkg := range pkg.UpstreamPackages(p) {  // 遍历上游包
            entriesForUpstream, err := s.GetByDistro(d, upstreamPkg)  // 获取上游包的条目
            if err != nil {  // 如果出现错误
                return nil, err  // 返回空和错误信息
            }
            for _, entry := range entriesForUpstream {  // 遍历上游包的条目
                if entry.Constraint.String() == "< 0 (apk)" {  // 如果约束条件为 "< 0 (apk)"
                    for _, f := range data.Files {  // 遍历文件
                        result[f.Path] = append(result[f.Path], entry.ID)  // 将条目 ID 添加到位置映射中
                    }
                }
            }
        }
    }

    return result, nil  // 返回位置到虚假阳性的映射和空错误信息
}

func filterMatchesUsingDistroFalsePositives(ms []match.Match, falsePositivesByLocation map[string][]string) []match.Match {  // 使用位置到虚假阳性的映射过滤匹配项
    var result []match.Match  // 创建匹配项切片
    # 遍历漏洞切片
    for _, m := range ms:
        # 初始化假阳性标志
        isFalsePositive := false

        # 遍历包位置切片
        for _, l := range m.Package.Locations.ToSlice():
            # 如果该位置的真实路径在假阳性字典中
            if fpVulnIDs, ok := falsePositivesByLocation[l.RealPath]; ok:
                # 如果该漏洞在假阳性漏洞ID列表中
                if slices.Contains(fpVulnIDs, m.Vulnerability.ID):
                    # 设置为假阳性
                    isFalsePositive = true
                    # 跳出循环
                    break

                # 遍历漏洞的相关漏洞
                for _, relatedVulnerability := range m.Vulnerability.RelatedVulnerabilities:
                    # 如果相关漏洞在假阳性漏洞ID列表中
                    if slices.Contains(fpVulnIDs, relatedVulnerability.ID):
                        # 设置为假阳性
                        isFalsePositive = true
                        # 跳出循环
                        break
            # 如果不是假阳性
        if !isFalsePositive:
            # 将漏洞添加到结果切片
            result = append(result, m)
        else:
            # 记录日志，说明使用发行版安全数据删除假阳性
            log.WithFields("vuln", m.Vulnerability.ID, "package", displayPackage(m.Package)).Trace("dropping false positive using distro security data")
    # 返回结果切片
    return result
# 查找 VEX 匹配项，根据上下文、剩余匹配项、被忽略的匹配项和进度监视器返回匹配项、被忽略的匹配项和错误
func (m *VulnerabilityMatcher) findVEXMatches(context pkg.Context, remainingMatches *match.Matches, ignoredMatches []match.IgnoredMatch, progressMonitor *monitorWriter) (*match.Matches, []match.IgnoredMatch, error) {
    # 如果 VexProcessor 为空，则跳过 VEX 匹配
    if m.VexProcessor == nil {
        log.Trace("no VEX documents provided, skipping VEX matching")
        return remainingMatches, ignoredMatches, nil
    }

    log.Trace("finding matches against available VEX documents")
    # 应用 VEX 处理器，返回 VEX 处理后的匹配项、被忽略的匹配项和错误
    matchesAfterVex, ignoredMatchesAfterVex, err := m.VexProcessor.ApplyVEX(&context, remainingMatches, ignoredMatches)
    if err != nil {
        return nil, nil, fmt.Errorf("unable to find matches against VEX documents: %w", err)
    }

    # 计算 VEX 处理后的匹配项和剩余匹配项的差异
    diffMatches := matchesAfterVex.Diff(*remainingMatches)
    # 注意：这假设差异只能是增加的
    # 计算 VEX 处理后的被忽略的匹配项和原被忽略的匹配项的差异
    diffIgnoredMatches := ignoredMatchesDiff(ignoredMatchesAfterVex, ignoredMatches)

    # 更新漏洞列表
    updateVulnerabilityList(progressMonitor, diffMatches.Sorted(), diffIgnoredMatches, nil, m.Store)

    return matchesAfterVex, ignoredMatchesAfterVex, nil
}

# 应用忽略规则，返回匹配项和被忽略的匹配项
func (m *VulnerabilityMatcher) applyIgnoreRules(matches match.Matches) (match.Matches, []match.IgnoredMatch) {
    var ignoredMatches []match.IgnoredMatch
    # 如果忽略规则为空，则直接返回匹配项和被忽略的匹配项
    if len(m.IgnoreRules) == 0 {
        return matches, ignoredMatches
    }

    # 应用忽略规则，返回匹配项和被忽略的匹配项
    matches, ignoredMatches = match.ApplyIgnoreRules(matches, m.IgnoreRules)

    # 如果有被忽略的匹配项，则记录日志
    if count := len(ignoredMatches); count > 0 {
        log.Infof("ignoring %d matches due to user-provided ignore rules", count)
    }
    return matches, ignoredMatches
}

# 根据 CVE 规范化匹配项
func (m *VulnerabilityMatcher) normalizeByCVE(match match.Match) match.Match {
    # 如果匹配项的漏洞 ID 符合 CVE 规范，则直接返回匹配项
    if isCVE(match.Vulnerability.ID) {
        return match
    }

    # 否则，查找匹配项关联的漏洞，如果有符合 CVE 规范的漏洞，则返回匹配项
    var effectiveCVERecordRefs []vulnerability.Reference
    for _, ref := range match.Vulnerability.RelatedVulnerabilities {
        if isCVE(ref.ID) {
            effectiveCVERecordRefs = append(effectiveCVERecordRefs, ref)
            break
        }
    }

    switch len(effectiveCVERecordRefs) {
    # 对于 case 0，记录日志并跟踪未能找到漏洞的 CVE 记录，然后返回匹配结果
    case 0:
        log.WithFields(
            "vuln", match.Vulnerability.ID,
            "package", displayPackage(match.Package),
        ).Trace("unable to find CVE record for vulnerability, skipping normalization")
        return match
    # 对于 case 1，直接跳出 switch 语句
    case 1:
        break
    # 对于其他情况，记录日志并跟踪找到多个 CVE 记录的漏洞，然后返回匹配结果
    default:
        log.WithFields(
            "refs", fmt.Sprintf("%+v", effectiveCVERecordRefs),
            "vuln", match.Vulnerability.ID,
            "package", displayPackage(match.Package),
        ).Trace("found multiple CVE records for vulnerability, skipping normalization")
        return match
    }

    # 获取有效的 CVE 记录引用
    ref := effectiveCVERecordRefs[0]

    # 获取上游元数据，并处理可能的错误
    upstreamMetadata, err := m.Store.GetMetadata(ref.ID, ref.Namespace)
    if err != nil {
        log.WithFields("id", ref.ID, "namespace", ref.Namespace, "error", err).Warn("unable to fetch effective CVE metadata")
        return match
    }

    # 如果上游元数据为空，则返回匹配结果
    if upstreamMetadata == nil {
        return match
    }

    # 创建原始引用
    originalRef := vulnerability.Reference{
        ID:        match.Vulnerability.ID,
        Namespace: match.Vulnerability.Namespace,
    }

    # 更新匹配结果的漏洞 ID、命名空间和相关漏洞引用
    match.Vulnerability.ID = upstreamMetadata.ID
    match.Vulnerability.Namespace = upstreamMetadata.Namespace
    match.Vulnerability.RelatedVulnerabilities = []vulnerability.Reference{originalRef}

    # 返回更新后的匹配结果
    return match
# 显示包信息，如果包的PURL不为空，则返回PURL，否则返回格式化的名称、版本和类型信息
func displayPackage(p pkg.Package) string {
    if p.PURL != "" {
        return p.PURL
    }
    return fmt.Sprintf("%s@%s (%s)", p.Name, p.Version, p.Type)
}

# 比较两个忽略匹配列表的差异
func ignoredMatchesDiff(subject []match.IgnoredMatch, other []match.IgnoredMatch) []match.IgnoredMatch {
    # 创建一个映射，用于存储other列表中的匹配指纹
    otherMap := make(map[match.Fingerprint]struct{})
    for _, a := range other {
        otherMap[a.Match.Fingerprint()] = struct{}{}
    }

    # 找出subject列表中存在而other列表中不存在的匹配，并添加到diff列表中
    var diff []match.IgnoredMatch
    for _, b := range subject {
        if _, ok := otherMap[b.Match.Fingerprint()]; !ok {
            diff = append(diff, b)
        }
    }

    return diff
}

# 创建匹配器索引和默认匹配器
func newMatcherIndex(matchers []matcher.Matcher) (map[syftPkg.Type][]matcher.Matcher, matcher.Matcher) {
    # 创建一个匹配器索引的映射
    matcherIndex := make(map[syftPkg.Type][]matcher.Matcher)
    var defaultMatcher matcher.Matcher
    for _, m := range matchers {
        # 如果匹配器类型为StockMatcher，则设置为默认匹配器，否则将匹配器添加到匹配器索引中
        if m.Type() == match.StockMatcher {
            defaultMatcher = m
            continue
        }
        for _, t := range m.PackageTypes() {
            if _, ok := matcherIndex[t]; !ok {
                matcherIndex[t] = make([]matcher.Matcher, 0)
            }

            matcherIndex[t] = append(matcherIndex[t], m)
            log.Debugf("adding matcher: %+v", t)
        }
    }

    return matcherIndex, defaultMatcher
}

# 判断是否为CVE编号
func isCVE(id string) bool {
    return strings.HasPrefix(strings.ToLower(id), "cve-")
}

# 判断是否存在严重程度达到或超过指定级别的漏洞
func HasSeverityAtOrAbove(store vulnerability.MetadataProvider, severity vulnerability.Severity, matches match.Matches) bool {
    if severity == vulnerability.UnknownSeverity {
        return false
    }
    # 遍历匹配结果的枚举
    for m := range matches.Enumerate() {
        # 获取漏洞的元数据，如果出现错误则跳过当前循环
        metadata, err := store.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
        if err != nil {
            continue
        }

        # 解析元数据中的严重程度，如果大于等于指定严重程度则返回 true
        if vulnerability.ParseSeverity(metadata.Severity) >= severity {
            return true
        }
    }
    # 如果没有匹配的漏洞严重程度大于等于指定严重程度，则返回 false
    return false
}
// 记录漏洞列表的摘要信息
func logListSummary(vl *monitorWriter) {
    // 记录发现的漏洞匹配数量和处理的包数量
    log.Infof("found %d vulnerability matches across %d packages", vl.MatchesDiscovered.Current(), vl.PackagesProcessed.Current())
    // 记录修复的漏洞数量
    log.Debugf("  ├── fixed: %d", vl.Fixed.Current())
    // 记录由于用户提供规则而被忽略的漏洞数量
    log.Debugf("  ├── ignored: %d (due to user-provided rule)", vl.Ignored.Current())
    // 记录由于硬编码修正而被丢弃的漏洞数量
    log.Debugf("  ├── dropped: %d (due to hard-coded correction)", vl.Dropped.Current())
    // 记录匹配的漏洞数量
    log.Debugf("  └── matched: %d", vl.MatchesDiscovered.Current())

    var unknownCount int64
    // 如果存在未知严重性的漏洞，则记录其数量
    if count, ok := vl.BySeverity[vulnerability.UnknownSeverity]; ok {
        unknownCount = count.Current()
    }
    log.Debugf("      ├── %s: %d", vulnerability.UnknownSeverity.String(), unknownCount)

    allSeverities := vulnerability.AllSeverities()
    // 遍历所有严重性级别，记录每个级别的漏洞数量
    for idx, sev := range allSeverities {
        arm := selectArm(idx, len(allSeverities))
        log.Debugf("      %s %s: %d", arm, sev.String(), vl.BySeverity[sev].Current())
    }
}

// 更新漏洞列表
func updateVulnerabilityList(mon *monitorWriter, matches []match.Match, ignores []match.IgnoredMatch, dropped []match.IgnoredMatch, metadataProvider vulnerability.MetadataProvider) {
    // 遍历所有匹配的漏洞
    for _, m := range matches {
        // 获取漏洞的元数据
        metadata, err := metadataProvider.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
        // 如果获取失败或者元数据为空，则将未知严重性漏洞数量加一
        if err != nil || metadata == nil {
            mon.BySeverity[vulnerability.UnknownSeverity].Increment()
            continue
        }

        // 获取漏洞的严重性
        sevManualProgress, ok := mon.BySeverity[vulnerability.ParseSeverity(metadata.Severity)]
        // 如果获取失败，则将未知严重性漏洞数量加一
        if !ok {
            mon.BySeverity[vulnerability.UnknownSeverity].Increment()
            continue
        }
        sevManualProgress.Increment()

        // 如果漏洞的修复状态为已修复，则将已修复漏洞数量加一
        if m.Vulnerability.Fix.State == grypeDb.FixedState {
            mon.Fixed.Increment()
        }
    }

    // 将忽略的漏洞数量加入到忽略统计中
    mon.Ignored.Add(int64(len(ignores)))
    // 将丢弃的漏洞数量加入到丢弃统计中
    mon.Dropped.Add(int64(len(dropped)))
}

// 记录包的匹配情况
func logPackageMatches(p pkg.Package, matches []match.Match) {
    // 如果没有匹配的漏洞，则直接返回
    if len(matches) == 0 {
        return
    }
}
    # 使用日志字段记录包名和显示包信息，并调试输出匹配的漏洞数量
    log.WithFields("package", displayPackage(p)).Debugf("found %d vulnerabilities", len(matches))
    # 遍历匹配的漏洞列表，并选择对应的 arm，记录漏洞 ID 和命名空间，并调试输出 arm 信息
    for idx, m := range matches:
        arm := selectArm(idx, len(matches))
        log.WithFields("vuln", m.Vulnerability.ID, "namespace", m.Vulnerability.Namespace).Debugf("  %s", arm)
// 选择分支的函数，根据索引和总数判断是返回 leaf 还是 branch
func selectArm(idx, total int) string {
    if idx == total-1 {
        return leaf
    }
    return branch
}

// 记录明确被忽略的软件包匹配
func logExplicitDroppedPackageMatches(p pkg.Package, ignored []match.IgnoredMatch) {
    if len(ignored) == 0 {
        return
    }

    log.WithFields("package", displayPackage(p)).Debugf("dropped %d vulnerability matches due to hard-coded correction", len(ignored))
    for idx, i := range ignored {
        arm := selectArm(idx, len(ignored))

        log.WithFields("vuln", i.Match.Vulnerability.ID, "rules", len(i.AppliedIgnoreRules)).Debugf("  %s", arm)
    }
}

// 记录被忽略的匹配
func logIgnoredMatches(ignored []match.IgnoredMatch) {
    if len(ignored) == 0 {
        return
    }

    log.Infof("ignored %d vulnerability matches", len(ignored))
    for idx, i := range ignored {
        arm := selectArm(idx, len(ignored))

        log.WithFields("vuln", i.Match.Vulnerability.ID, "rules", len(i.AppliedIgnoreRules), "package", displayPackage(i.Package)).Debugf("  %s", arm)
    }
}

// 监控写入器结构体
type monitorWriter struct {
    PackagesProcessed *progress.Manual
    MatchesDiscovered *progress.Manual
    Fixed             *progress.Manual
    Ignored           *progress.Manual
    Dropped           *progress.Manual
    BySeverity        map[vulnerability.Severity]*progress.Manual
}

// 创建新的监控写入器
func newMonitor(pkgCount int) (monitorWriter, monitor.Matching) {
    manualBySev := make(map[vulnerability.Severity]*progress.Manual)
    for _, severity := range vulnerability.AllSeverities() {
        manualBySev[severity] = progress.NewManual(-1)
    }
    manualBySev[vulnerability.UnknownSeverity] = progress.NewManual(-1)

    m := monitorWriter{
        PackagesProcessed: progress.NewManual(int64(pkgCount)),
        MatchesDiscovered: progress.NewManual(-1),
        Fixed:             progress.NewManual(-1),
        Ignored:           progress.NewManual(-1),
        Dropped:           progress.NewManual(-1),
        BySeverity:        manualBySev,
    }
    # 创建一个映射，将漏洞严重程度映射到可监控对象
    monitorableBySev := make(map[vulnerability.Severity]progress.Monitorable)
    # 遍历手动处理的漏洞映射
    for sev, manual := range manualBySev {
        # 将手动处理的漏洞映射到可监控对象的映射中
        monitorableBySev[sev] = manual
    }

    # 返回监控对象和匹配结果
    return m, monitor.Matching{
        PackagesProcessed: m.PackagesProcessed,
        MatchesDiscovered: m.MatchesDiscovered,
        Fixed:             m.Fixed,
        Ignored:           m.Ignored,
        Dropped:           m.Dropped,
        BySeverity:        monitorableBySev,  # 将漏洞严重程度映射到可监控对象的映射作为返回结果的一部分
    }
# 设置监视器写入器的完成状态，分别设置已处理的包、已发现的匹配、已修复的、已忽略的、已丢弃的状态为完成
func (m *monitorWriter) SetCompleted() {
    m.PackagesProcessed.SetCompleted()  # 设置已处理的包状态为完成
    m.MatchesDiscovered.SetCompleted()  # 设置已发现的匹配状态为完成
    m.Fixed.SetCompleted()  # 设置已修复的状态为完成
    m.Ignored.SetCompleted()  # 设置已忽略的状态为完成
    m.Dropped.SetCompleted()  # 设置已丢弃的状态为完成
    for _, v := range m.BySeverity {  # 遍历按严重程度分类的状态
        v.SetCompleted()  # 设置状态为完成
    }
}

# 跟踪匹配器，返回监视器写入器
func trackMatcher(pkgCount int) *monitorWriter {
    writer, reader := newMonitor(pkgCount)  # 创建新的监视器写入器和读取器
    bus.Publish(partybus.Event{  # 发布事件
        Type:  event.VulnerabilityScanningStarted,  # 事件类型为漏洞扫描开始
        Value: reader,  # 事件值为读取器
    })
    return &writer  # 返回监视器写入器的指针
}
```