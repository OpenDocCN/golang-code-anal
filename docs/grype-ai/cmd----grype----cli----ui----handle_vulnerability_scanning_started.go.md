# `grype\cmd\grype\cli\ui\handle_vulnerability_scanning_started.go`

```go
package ui

import (
    "fmt" // 导入 fmt 包，用于格式化输出
    "sort" // 导入 sort 包，用于对切片进行排序
    "strings" // 导入 strings 包，用于处理字符串
    "time" // 导入 time 包，用于处理时间

    tea "github.com/charmbracelet/bubbletea" // 导入 bubbletea 包，用于构建终端用户界面
    "github.com/charmbracelet/lipgloss" // 导入 lipgloss 包，用于创建漂亮的终端样式
    "github.com/wagoodman/go-partybus" // 导入 go-partybus 包，用于事件总线
    "github.com/wagoodman/go-progress" // 导入 go-progress 包，用于显示进度条

    "github.com/anchore/bubbly/bubbles/taskprogress" // 导入 taskprogress 包，用于显示任务进度
    "github.com/anchore/grype/grype/event/monitor" // 导入 monitor 包，用于监控事件
    "github.com/anchore/grype/grype/event/parsers" // 导入 parsers 包，用于解析事件
    "github.com/anchore/grype/grype/vulnerability" // 导入 vulnerability 包，用于处理漏洞
    "github.com/anchore/grype/internal/log" // 导入 log 包，用于记录日志
)

const (
    branch = "├──" // 定义分支符号
    end    = "└──" // 定义末端符号
)

var _ progress.StagedProgressable = (*vulnerabilityScanningAdapter)(nil) // 确保 vulnerabilityScanningAdapter 实现了 StagedProgressable 接口

type vulnerabilityProgressTree struct {
    mon        *monitor.Matching // 监控匹配对象
    windowSize tea.WindowSizeMsg // 窗口大小消息

    countBySeverity map[vulnerability.Severity]int64 // 按严重程度统计漏洞数量的映射
    unknownCount    int64 // 未知漏洞数量
    fixedCount      int64 // 已修复漏洞数量
    ignoredCount    int64 // 已忽略漏洞数量
    droppedCount    int64 // 已删除漏洞数量
    totalCount      int64 // 总漏洞数量
    severities      []vulnerability.Severity // 漏洞严重程度切片

    id       uint32 // ID
    sequence int // 序列号

    updateDuration time.Duration // 更新持续时间
    textStyle      lipgloss.Style // 文本样式
}

func newVulnerabilityProgressTree(monitor *monitor.Matching, textStyle lipgloss.Style) vulnerabilityProgressTree {
    allSeverities := vulnerability.AllSeverities() // 获取所有漏洞严重程度
    sort.Sort(sort.Reverse(vulnerability.Severities(allSeverities))) // 对漏洞严重程度进行排序

    return vulnerabilityProgressTree{
        mon:             monitor, // 初始化监控对象
        countBySeverity: make(map[vulnerability.Severity]int64), // 初始化漏洞严重程度计数映射
        severities:      allSeverities, // 初始化漏洞严重程度切片
        textStyle:       textStyle, // 初始化文本样式
    }
}

// vulnerabilityProgressTreeTickMsg 表示计时器已经触发，需要渲染一个帧
type vulnerabilityProgressTreeTickMsg struct {
    Time     time.Time // 时间
    Sequence int // 序列号
    ID       uint32 // ID
}

type vulnerabilityScanningAdapter struct {
    mon *monitor.Matching // 监控匹配对象
}

func (p vulnerabilityScanningAdapter) Current() int64 {
    return p.mon.PackagesProcessed.Current() // 返回已处理的包数量
}

func (p vulnerabilityScanningAdapter) Error() error {
    return p.mon.MatchesDiscovered.Error() // 返回发现的匹配错误
}
func (p vulnerabilityScanningAdapter) Size() int64 {
    // 返回已处理包的大小
    return p.mon.PackagesProcessed.Size()
}

func (p vulnerabilityScanningAdapter) Stage() string {
    // 返回漏洞匹配的阶段信息
    return fmt.Sprintf("%d vulnerability matches", p.mon.MatchesDiscovered.Current()-p.mon.Ignored.Current())
}

func (m *Handler) handleVulnerabilityScanningStarted(e partybus.Event) ([]tea.Model, tea.Cmd) {
    // 解析漏洞扫描开始事件
    mon, err := parsers.ParseVulnerabilityScanningStarted(e)
    if err != nil {
        // 如果解析失败，记录错误并返回空
        log.WithFields("error", err).Warn("unable to parse event")
        return nil, nil
    }

    // 创建新的任务进度
    tsk := m.newTaskProgress(
        taskprogress.Title{
            Default: "Scan for vulnerabilities",
            Running: "Scanning for vulnerabilities",
            Success: "Scanned for vulnerabilities",
        },
        taskprogress.WithStagedProgressable(vulnerabilityScanningAdapter{mon: mon}),
    )

    // 在成功时显示阶段
    tsk.HideStageOnSuccess = false

    // 返回任务进度和漏洞扫描进度树
    textStyle := tsk.HintStyle
    return []tea.Model{
        tsk,
        newVulnerabilityProgressTree(mon, textStyle),
    }, nil
}

func (l vulnerabilityProgressTree) Init() tea.Cmd {
    // 这是状态信息的周期性更新
    return func() tea.Msg {
        return vulnerabilityProgressTreeTickMsg{
            // 发生tick的时间
            Time: time.Now(),

            // 此消息所属的日志帧的ID。在路由消息时可能会有帮助，但要注意日志帧默认会忽略不包含ID的消息。
            ID: l.id,

            Sequence: l.sequence,
        }
    }
}

func (l vulnerabilityProgressTree) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.WindowSizeMsg:
        // 更新窗口大小
        l.windowSize = msg
        return l, nil
    # 当接收到漏洞进度树的更新消息时，更新模型数据
    l.totalCount = l.mon.MatchesDiscovered.Current()  # 更新总数
    l.fixedCount = l.mon.Fixed.Current()  # 更新已修复数
    l.ignoredCount = l.mon.Ignored.Current()  # 更新已忽略数
    l.droppedCount = l.mon.Dropped.Current()  # 更新已删除数
    l.unknownCount = l.mon.BySeverity[vulnerability.UnknownSeverity].Current()  # 更新未知严重性数
    for _, sev := range l.severities:  # 遍历所有严重性级别
        l.countBySeverity[sev] = l.mon.BySeverity[sev].Current()  # 更新每个严重性级别的数量

    # 启动下一个时钟周期
    tickCmd := l.handleTick(msg)  # 处理下一个时钟周期的命令

    return l, tickCmd  # 返回更新后的模型和下一个时钟周期的命令
}

return l, nil  # 返回更新后的模型和空命令
}

func (l vulnerabilityProgressTree) View() string {
    sb := strings.Builder{}

    // 遍历漏洞严重程度列表
    for idx, sev := range l.severities {
        // 获取当前严重程度的漏洞数量，并添加到字符串构建器中
        count := l.countBySeverity[sev]
        sb.WriteString(fmt.Sprintf("%d %s", count, sev))
        // 如果不是最后一个严重程度，则添加逗号和空格
        if idx < len(l.severities)-1 {
            sb.WriteString(", ")
        }
    }
    // 如果存在未知的漏洞数量，则添加到字符串构建器中
    if l.unknownCount > 0 {
        unknownStr := fmt.Sprintf(" (%d unknown)", l.unknownCount)
        sb.WriteString(unknownStr)
    }

    // 获取构建器中的字符串并重置构建器
    status := sb.String()
    sb.Reset()

    // 根据漏洞严重程度和数量渲染文本样式
    sevStr := l.textStyle.Render(fmt.Sprintf("   %s by severity: %s", branch, status))

    // 将渲染后的文本添加到字符串构建器中
    sb.WriteString(sevStr)

    dropped := ""
    // 如果存在已忽略的漏洞数量，则添加到 dropped 变量中
    if l.droppedCount > 0 {
        dropped = fmt.Sprintf("(%d dropped)", l.droppedCount)
    }

    // 根据漏洞状态数量和已修复数量渲染文本样式
    fixedStr := l.textStyle.Render(
        fmt.Sprintf("   %s by status:   %d fixed, %d not-fixed, %d ignored %s",
            end, l.fixedCount, l.totalCount-l.fixedCount, l.ignoredCount, dropped,
        ),
    )
    // 将渲染后的文本添加到字符串构建器中
    sb.WriteString("\n" + fixedStr)

    // 返回构建器中的字符串
    return sb.String()
}

func (l vulnerabilityProgressTree) queueNextTick() tea.Cmd {
    // 返回一个定时器命令，用于发送漏洞进度树的更新消息
    return tea.Tick(l.updateDuration, func(t time.Time) tea.Msg {
        return vulnerabilityProgressTreeTickMsg{
            Time:     t,
            ID:       l.id,
            Sequence: l.sequence,
        }
    })
}

func (l *vulnerabilityProgressTree) handleTick(msg vulnerabilityProgressTreeTickMsg) tea.Cmd {
    // 如果设置了 ID，并且 ID 不属于此日志帧，则拒绝消息
    if msg.ID > 0 && msg.ID != l.id {
        return nil
    }

    // 如果设置了序列，并且不是我们期望的序列，则拒绝消息
    // 这可以防止日志帧接收过多消息，从而更新过于频繁
    if msg.Sequence > 0 && msg.Sequence != l.sequence {
        return nil
    }

    l.sequence++

    // 注意：即使日志已完成，我们仍应对阶段变化和窗口大小事件做出响应
    return l.queueNextTick()
}
```