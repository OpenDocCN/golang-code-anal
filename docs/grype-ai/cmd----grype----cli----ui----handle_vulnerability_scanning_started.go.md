# `grype\cmd\grype\cli\ui\handle_vulnerability_scanning_started.go`

```
package ui

import (
	"fmt"  // 导入 fmt 包，用于格式化输出
	"sort"  // 导入 sort 包，用于对数据进行排序
	"strings"  // 导入 strings 包，用于处理字符串
	"time"  // 导入 time 包，用于处理时间

	tea "github.com/charmbracelet/bubbletea"  // 导入 bubbletea 包，用于构建终端用户界面
	"github.com/charmbracelet/lipgloss"  // 导入 lipgloss 包，用于创建漂亮的终端样式
	"github.com/wagoodman/go-partybus"  // 导入 go-partybus 包，用于事件总线
	"github.com/wagoodman/go-progress"  // 导入 go-progress 包，用于显示进度条

	"github.com/anchore/bubbly/bubbles/taskprogress"  // 导入 taskprogress 包，用于显示任务进度
	"github.com/anchore/grype/grype/event/monitor"  // 导入 monitor 包，用于监控事件
	"github.com/anchore/grype/grype/event/parsers"  // 导入 parsers 包，用于解析事件
	"github.com/anchore/grype/grype/vulnerability"  // 导入 vulnerability 包，用于处理漏洞
	"github.com/anchore/grype/internal/log"  // 导入 log 包，用于日志记录
)
// 定义常量 branch 和 end，分别表示树形结构中的分支和末端
const (
	branch = "├──"
	end    = "└──"
)

// 声明 vulnerabilityScanningAdapter 结构体实现了 progress.StagedProgressable 接口
var _ progress.StagedProgressable = (*vulnerabilityScanningAdapter)(nil)

// 定义 vulnerabilityProgressTree 结构体
type vulnerabilityProgressTree struct {
	mon             *monitor.Matching
	windowSize      tea.WindowSizeMsg

	// 用于存储不同严重程度漏洞的数量
	countBySeverity map[vulnerability.Severity]int64
	unknownCount    int64
	fixedCount      int64
	ignoredCount    int64
	droppedCount    int64
	totalCount      int64
	severities      []vulnerability.Severity

	id       uint32
```
这段代码定义了常量、变量和结构体，用于表示漏洞扫描的进度树和相关信息。其中包括了常量 branch 和 end，用于表示树形结构中的分支和末端；变量 _ 表示 vulnerabilityScanningAdapter 结构体实现了 progress.StagedProgressable 接口；结构体 vulnerabilityProgressTree 包含了漏洞扫描的相关信息，如监视器、窗口大小、不同严重程度漏洞的数量等。
// 定义一个名为 sequence 的整数变量

// 定义一个名为 updateDuration 的时间间隔变量
// 定义一个名为 textStyle 的 lipgloss 样式变量

// 创建一个新的 vulnerabilityProgressTree 结构体实例
// 参数 monitor 是一个指向 monitor.Matching 类型的指针
// 参数 textStyle 是一个 lipgloss 样式
func newVulnerabilityProgressTree(monitor *monitor.Matching, textStyle lipgloss.Style) vulnerabilityProgressTree {
    // 获取所有漏洞严重程度，并按照严重程度倒序排序
    allSeverities := vulnerability.AllSeverities()
    sort.Sort(sort.Reverse(vulnerability.Severities(allSeverities)))

    // 返回一个 vulnerabilityProgressTree 结构体实例
    return vulnerabilityProgressTree{
        mon:             monitor, // 设置 monitor 字段为传入的 monitor 参数
        countBySeverity: make(map[vulnerability.Severity]int64), // 初始化 countBySeverity 字段为一个空的 map
        severities:      allSeverities, // 设置 severities 字段为排序后的所有严重程度
        textStyle:       textStyle, // 设置 textStyle 字段为传入的 textStyle 参数
    }
}

// 定义一个名为 vulnerabilityProgressTreeTickMsg 的结构体
// 用于指示定时器已经触发，并且应该渲染一个帧
type vulnerabilityProgressTreeTickMsg struct {
// 定义结构体vulnerabilityScanningAdapter，包含一个指向monitor.Matching的指针
type vulnerabilityScanningAdapter struct {
	mon *monitor.Matching
}

// 实现Current方法，返回mon.PackagesProcessed的当前值
func (p vulnerabilityScanningAdapter) Current() int64 {
	return p.mon.PackagesProcessed.Current()
}

// 实现Error方法，返回mon.MatchesDiscovered的错误信息
func (p vulnerabilityScanningAdapter) Error() error {
	return p.mon.MatchesDiscovered.Error()
}

// 实现Size方法，返回mon.PackagesProcessed的大小
func (p vulnerabilityScanningAdapter) Size() int64 {
	return p.mon.PackagesProcessed.Size()
}
// Stage 方法返回一个字符串，表示漏洞匹配的数量
func (p vulnerabilityScanningAdapter) Stage() string {
	return fmt.Sprintf("%d vulnerability matches", p.mon.MatchesDiscovered.Current()-p.mon.Ignored.Current())
}

// 处理漏洞扫描开始事件的方法
func (m *Handler) handleVulnerabilityScanningStarted(e partybus.Event) ([]tea.Model, tea.Cmd) {
	// 解析漏洞扫描开始事件
	mon, err := parsers.ParseVulnerabilityScanningStarted(e)
	if err != nil {
		// 如果解析失败，记录错误并返回空
		log.WithFields("error", err).Warn("unable to parse event")
		return nil, nil
	}

	// 创建一个新的任务进度
	tsk := m.newTaskProgress(
		taskprogress.Title{
			Default: "Scan for vulnerabilities",
			Running: "Scanning for vulnerabilities",
			Success: "Scanned for vulnerabilities",
		},
		// 使用 vulnerabilityScanningAdapter 结构作为进度的适配器
		taskprogress.WithStagedProgressable(vulnerabilityScanningAdapter{mon: mon}),
	)
// 设置任务完成后不隐藏阶段
tsk.HideStageOnSuccess = false

// 获取任务的提示样式
textStyle := tsk.HintStyle

// 返回包含任务和漏洞进度树的模型列表
return []tea.Model{
	tsk,
	newVulnerabilityProgressTree(mon, textStyle),
}, nil
}

// 初始化漏洞进度树
func (l vulnerabilityProgressTree) Init() tea.Cmd {
	// 这是状态信息的周期性更新
	return func() tea.Msg {
		return vulnerabilityProgressTreeTickMsg{
			// 发生tick的时间
			Time: time.Now(),

			// 此消息所属的日志帧的ID。在路由消息时可能会有帮助，但请记住日志帧
// 默认情况下将忽略不包含 ID 的消息。
ID: l.id, // 将 l.id 赋值给 ID

Sequence: l.sequence, // 将 l.sequence 赋值给 Sequence
}

func (l vulnerabilityProgressTree) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg: // 如果消息类型是 tea.WindowSizeMsg
		l.windowSize = msg // 将消息赋值给 l.windowSize
		return l, nil // 返回更新后的模型和空命令

	case vulnerabilityProgressTreeTickMsg: // 如果消息类型是 vulnerabilityProgressTreeTickMsg
		// 更新模型
		l.totalCount = l.mon.MatchesDiscovered.Current() // 将 l.mon.MatchesDiscovered.Current() 赋值给 l.totalCount
		l.fixedCount = l.mon.Fixed.Current() // 将 l.mon.Fixed.Current() 赋值给 l.fixedCount
		l.ignoredCount = l.mon.Ignored.Current() // 将 l.mon.Ignored.Current() 赋值给 l.ignoredCount
		l.droppedCount = l.mon.Dropped.Current() // 将 l.mon.Dropped.Current() 赋值给 l.droppedCount
		// 设置未知严重性漏洞的数量为当前数量
		l.unknownCount = l.mon.BySeverity[vulnerability.UnknownSeverity].Current()
		// 遍历所有严重性级别，将每个级别的数量设置为当前数量
		for _, sev := range l.severities {
			l.countBySeverity[sev] = l.mon.BySeverity[sev].Current()
		}

		// 启动下一个时钟周期
		tickCmd := l.handleTick(msg)

		// 返回漏洞进度树和时钟周期命令
		return l, tickCmd
	}

	// 返回漏洞进度树和空命令
	return l, nil
}

// 查看漏洞进度树的方法
func (l vulnerabilityProgressTree) View() string {
	// 创建一个字符串构建器
	sb := strings.Builder{}

	// 遍历所有严重性级别，将每个级别的数量和级别名称添加到字符串构建器中
	for idx, sev := range l.severities {
		count := l.countBySeverity[sev]
		sb.WriteString(fmt.Sprintf("%d %s", count, sev))
# 如果当前索引小于严重性列表的长度减1，则向字符串构建器添加逗号和空格
if idx < len(l.severities)-1 {
    sb.WriteString(", ")
}

# 如果存在未知数量大于0，则构建一个包含未知数量的字符串，并添加到字符串构建器
if l.unknownCount > 0 {
    unknownStr := fmt.Sprintf(" (%d unknown)", l.unknownCount)
    sb.WriteString(unknownStr)
}

# 将字符串构建器的内容赋值给变量status，并重置字符串构建器
status := sb.String()
sb.Reset()

# 使用文本样式渲染分支和状态的字符串，并添加到字符串构建器
sevStr := l.textStyle.Render(fmt.Sprintf("   %s by severity: %s", branch, status))
sb.WriteString(sevStr)

# 如果丢弃数量大于0，则构建一个包含丢弃数量的字符串
dropped := ""
if l.droppedCount > 0 {
    dropped = fmt.Sprintf("(%d dropped)", l.droppedCount)
}
// 使用文本样式渲染包含修复状态信息的字符串，并将其添加到字符串构建器中
fixedStr := l.textStyle.Render(
    fmt.Sprintf("   %s by status:   %d fixed, %d not-fixed, %d ignored %s",
        end, l.fixedCount, l.totalCount-l.fixedCount, l.ignoredCount, dropped,
    ),
)
sb.WriteString("\n" + fixedStr)

// 返回字符串构建器中的字符串
return sb.String()
}

// 返回一个用于触发下一个时钟滴答的命令
func (l vulnerabilityProgressTree) queueNextTick() tea.Cmd {
    return tea.Tick(l.updateDuration, func(t time.Time) tea.Msg {
        // 返回一个包含当前时间、ID 和序列号的漏洞进度树滴答消息
        return vulnerabilityProgressTreeTickMsg{
            Time:     t,
            ID:       l.id,
            Sequence: l.sequence,
        }
    })
}
// 如果设置了ID，并且ID不属于此日志框架，则拒绝消息。
func (l *vulnerabilityProgressTree) handleTick(msg vulnerabilityProgressTreeTickMsg) tea.Cmd {
    if msg.ID > 0 && msg.ID != l.id {
        return nil
    }

    // 如果设置了序列，并且不是我们期望的序列，则拒绝消息。
   // 这可以防止日志框架接收过多的消息，从而更新过于频繁。
    if msg.Sequence > 0 && msg.Sequence != l.sequence {
        return nil
    }

    l.sequence++

    // 注意：即使日志已完成，我们仍应对阶段变化和窗口大小事件做出响应
    return l.queueNextTick()
}
```