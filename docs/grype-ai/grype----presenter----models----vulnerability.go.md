# `grype\grype\presenter\models\vulnerability.go`

```
package models

import (
    "github.com/anchore/grype/grype/vulnerability"
)

type Vulnerability struct {
    VulnerabilityMetadata
    Fix        Fix        `json:"fix"`  // 定义漏洞修复信息
    Advisories []Advisory `json:"advisories"`  // 定义漏洞的建议信息
}

type Fix struct {
    Versions []string `json:"versions"`  // 定义修复版本号
    State    string   `json:"state"`  // 定义修复状态
}

type Advisory struct {
    ID   string `json:"id"`  // 定义建议的ID
    Link string `json:"link"`  // 定义建议的链接
}

func NewVulnerability(vuln vulnerability.Vulnerability, metadata *vulnerability.Metadata) Vulnerability {
    if metadata == nil {
        return Vulnerability{
            VulnerabilityMetadata: NewVulnerabilityMetadata(vuln.ID, vuln.Namespace, metadata),  // 如果元数据为空，则返回漏洞元数据
        }
    }

    advisories := make([]Advisory, len(vuln.Advisories))  // 创建建议的切片
    for idx, advisory := range vuln.Advisories {
        advisories[idx] = Advisory{
            ID:   advisory.ID,  // 填充建议的ID
            Link: advisory.Link,  // 填充建议的链接
        }
    }

    fixedInVersions := vuln.Fix.Versions  // 获取修复版本号
    if fixedInVersions == nil {
        // always allocate collections
        fixedInVersions = make([]string, 0)  // 如果修复版本号为空，则分配一个空的切片
    }

    return Vulnerability{
        VulnerabilityMetadata: NewVulnerabilityMetadata(vuln.ID, vuln.Namespace, metadata),  // 返回漏洞元数据
        Fix: Fix{
            Versions: fixedInVersions,  // 填充修复版本号
            State:    string(vuln.Fix.State),  // 填充修复状态
        },
        Advisories: advisories,  // 返回建议信息
    }
}
```