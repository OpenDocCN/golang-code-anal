# `grype\grype\presenter\models\vulnerability.go`

```
// 导入vulnerability包，用于引用其中的数据结构和函数
import (
	"github.com/anchore/grype/grype/vulnerability"
)

// 定义Vulnerability结构体，包含VulnerabilityMetadata、Fix和Advisories字段
type Vulnerability struct {
	VulnerabilityMetadata
	Fix        Fix        `json:"fix"` // 定义Fix结构体类型的字段，用于表示漏洞的修复情况
	Advisories []Advisory `json:"advisories"` // 定义Advisory结构体类型的切片字段，用于表示漏洞的警告信息
}

// 定义Fix结构体，包含Versions和State字段
type Fix struct {
	Versions []string `json:"versions"` // 定义字符串切片类型的字段，用于表示修复的版本信息
	State    string   `json:"state"` // 定义字符串类型的字段，用于表示修复状态
}

// 定义Advisory结构体，包含ID和Link字段
type Advisory struct {
	ID   string `json:"id"` // 定义字符串类型的字段，用于表示警告的ID
	Link string `json:"link"` // 定义字符串类型的字段，用于表示警告的链接
}
}

func NewVulnerability(vuln vulnerability.Vulnerability, metadata *vulnerability.Metadata) Vulnerability {
	// 创建新的漏洞对象
	if metadata == nil {
		// 如果元数据为空，返回只包含漏洞元数据的漏洞对象
		return Vulnerability{
			VulnerabilityMetadata: NewVulnerabilityMetadata(vuln.ID, vuln.Namespace, metadata),
		}
	}

	// 创建漏洞关联的建议对象集合
	advisories := make([]Advisory, len(vuln.Advisories))
	for idx, advisory := range vuln.Advisories {
		advisories[idx] = Advisory{
			ID:   advisory.ID,
			Link: advisory.Link,
		}
	}

	// 获取漏洞修复版本
	fixedInVersions := vuln.Fix.Versions
	if fixedInVersions == nil {
		// 如果修复版本为空，始终分配集合
		// 创建一个空的字符串切片用于存储修复版本
		fixedInVersions = make([]string, 0)
	}

	// 返回一个Vulnerability对象，包括VulnerabilityMetadata和Fix信息
	return Vulnerability{
		// 创建一个新的VulnerabilityMetadata对象
		VulnerabilityMetadata: NewVulnerabilityMetadata(vuln.ID, vuln.Namespace, metadata),
		// 设置修复版本和状态信息
		Fix: Fix{
			Versions: fixedInVersions,
			State:    string(vuln.Fix.State),
		},
		// 设置安全建议信息
		Advisories: advisories,
	}
}
```