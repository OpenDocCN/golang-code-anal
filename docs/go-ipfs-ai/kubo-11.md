# go-ipfs 源码解析 11

# `core/commands/cat.go`

该代码包是一个命令行工具的包，其具体的作用取决于它的用法。但是，我们可以从代码中看到一些提示如何使用该包的信息。

首先，该代码包使用了一些来自其它库的库，包括 "github.com/ipfs/kubo/core/commands/cmdenv" 和 "github.com/ipfs/kubo/core/commands/cmdutils"。这些库可能提供了该工具所需的必要功能。

其次，该代码包定义了一个名为 "packages" 的结构体，其中包含了一些描述性文本。这些描述性文本告诉我们该工具包是用于什么的，以及它提供了哪些功能。

最后，该代码包定义了一个名为 "main" 的函数，该函数是该工具包的入口点。在该函数中，可能有一些内部代码，以便在函数中执行必要的操作来初始化或配置该工具包。

虽然我们无法从该代码包中确定其具体作用，但我们可以根据该代码包中定义的结构体和函数，对该工具包的实际用途进行猜测。


```go
package commands

import (
	"context"
	"fmt"
	"io"
	"os"

	"github.com/ipfs/kubo/core/commands/cmdenv"
	"github.com/ipfs/kubo/core/commands/cmdutils"

	"github.com/cheggaaa/pb"
	iface "github.com/ipfs/boxo/coreiface"
	"github.com/ipfs/boxo/files"
	cmds "github.com/ipfs/go-ipfs-cmds"
)

```

This is a Go implementation of the `ReadAll` and `Copy` functions used in the `io.Copy` function.

The `MultiReader` function reads multiple readers and returns any errors from them. Since the errors returned by the readers are passed to `Emit`, any errors from the `Copy` function are also sent to the client.

The `PostRun` function is a function that runs the `ReadAll` and `Copy` functions as part of a continuous Integration (CI) build process. It takes theReader as an argument and returns any errors that occurred.

The `PostRunMap` function maps over the possible error codes generated by `ReadAll` and `Copy` to a function that performs the desired action. For example, if an error is generated by `ReadAll`, the function returns a fresh copy of the error instead of returning it.

Overall, this implementation appears to be designed to help simplify the process of running a CI build process using the `io.Copy` function.


```go
const (
	progressBarMinSize = 1024 * 1024 * 8 // show progress bar for outputs > 8MiB
	offsetOptionName   = "offset"
	lengthOptionName   = "length"
)

var CatCmd = &cmds.Command{
	Helptext: cmds.HelpText{
		Tagline:          "Show IPFS object data.",
		ShortDescription: "Displays the data contained by an IPFS or IPNS object(s) at the given path.",
	},

	Arguments: []cmds.Argument{
		cmds.StringArg("ipfs-path", true, true, "The path to the IPFS object(s) to be outputted.").EnableStdin(),
	},
	Options: []cmds.Option{
		cmds.Int64Option(offsetOptionName, "o", "Byte offset to begin reading from."),
		cmds.Int64Option(lengthOptionName, "l", "Maximum number of bytes to read."),
		cmds.BoolOption(progressOptionName, "p", "Stream progress data.").WithDefault(true),
	},
	Run: func(req *cmds.Request, res cmds.ResponseEmitter, env cmds.Environment) error {
		api, err := cmdenv.GetApi(env, req)
		if err != nil {
			return err
		}

		offset, _ := req.Options[offsetOptionName].(int64)
		if offset < 0 {
			return fmt.Errorf("cannot specify negative offset")
		}

		max, found := req.Options[lengthOptionName].(int64)

		if max < 0 {
			return fmt.Errorf("cannot specify negative length")
		}
		if !found {
			max = -1
		}

		err = req.ParseBodyArgs()
		if err != nil {
			return err
		}

		readers, length, err := cat(req.Context, api, req.Arguments, int64(offset), int64(max))
		if err != nil {
			return err
		}

		/*
			if err := corerepo.ConditionalGC(req.Context, node, length); err != nil {
				re.SetError(err, cmds.ErrNormal)
				return
			}
		*/

		res.SetLength(length)
		reader := io.MultiReader(readers...)

		// Since the reader returns the error that a block is missing, and that error is
		// returned from io.Copy inside Emit, we need to take Emit errors and send
		// them to the client. Usually we don't do that because it means the connection
		// is broken or we supplied an illegal argument etc.
		return res.Emit(reader)
	},
	PostRun: cmds.PostRunMap{
		cmds.CLI: func(res cmds.Response, re cmds.ResponseEmitter) error {
			if res.Length() > 0 && res.Length() < progressBarMinSize {
				return cmds.Copy(re, res)
			}

			for {
				v, err := res.Next()
				if err != nil {
					if err == io.EOF {
						return nil
					}
					return err
				}

				switch val := v.(type) {
				case io.Reader:
					reader := val

					req := res.Request()
					progress, _ := req.Options[progressOptionName].(bool)
					if progress {
						var bar *pb.ProgressBar
						bar, reader = progressBarForReader(os.Stderr, val, int64(res.Length()))
						bar.Start()
						defer bar.Finish()
					}

					err = re.Emit(reader)
					if err != nil {
						return err
					}
				default:
					log.Warnf("cat postrun: received unexpected type %T", val)
				}
			}
		},
	},
}

```

This function appears to be used to count the number of files in a directory and its subdirectories based on the specified input. It takes a list of paths to the directory paths and returns a slice of slice-like structures containing the files in the directory, their sizes, and the number of files in the directory.

The function first checks the input paths for errors and then iterates through each path. For each path, it attempts to retrieve the file information using the specified API. If an error occurs, the function returns immediately. If the file information cannot be retrieved, the function returns with an error.

The function then calculates the number of files in the directory based on the number of files in each directory and its subdirectories. If the number of files is greater than the specified `max` value, the function reads the files one by one until the maximum number of files is reached. The `readers` variable is updated with the io.Reader instances that retrieve the files.

The function returns a slice of slice-like structures containing the files in the directory, their sizes, and the number of files in the directory.


```go
func cat(ctx context.Context, api iface.CoreAPI, paths []string, offset int64, max int64) ([]io.Reader, uint64, error) {
	readers := make([]io.Reader, 0, len(paths))
	length := uint64(0)
	if max == 0 {
		return nil, 0, nil
	}
	for _, pString := range paths {
		p, err := cmdutils.PathOrCidPath(pString)
		if err != nil {
			return nil, 0, err
		}

		f, err := api.Unixfs().Get(ctx, p)
		if err != nil {
			return nil, 0, err
		}

		var file files.File
		switch f := f.(type) {
		case files.File:
			file = f
		case files.Directory:
			return nil, 0, iface.ErrIsDir
		default:
			return nil, 0, iface.ErrNotSupported
		}

		fsize, err := file.Size()
		if err != nil {
			return nil, 0, err
		}

		if offset > fsize {
			offset = offset - fsize
			continue
		}

		count, err := file.Seek(offset, io.SeekStart)
		if err != nil {
			return nil, 0, err
		}
		offset = 0

		fsize, err = file.Size()
		if err != nil {
			return nil, 0, err
		}

		size := uint64(fsize - count)
		length += size
		if max > 0 && length >= uint64(max) {
			var r io.Reader = file
			if overshoot := int64(length - uint64(max)); overshoot != 0 {
				r = io.LimitReader(file, int64(size)-overshoot)
				length = uint64(max)
			}
			readers = append(readers, r)
			break
		}
		readers = append(readers, file)
	}
	return readers, length, nil
}

```

# `core/commands/cid.go`

该代码的作用是定义了一个名为 "commands" 的包，其中定义了一些命令行工具的函数。

具体来说，该包中定义了以下函数：

- `fmt.Printf` 函数用于格式化输出。
- `io.Io` 函数用于输入/输出。
- `sort.Sort` 函数用于对字符串进行排序。
- `strings.Sort` 函数遵循 strings.Sort 函数的规则，但是只支持 ASCII 字符集中的字符。
- `unicode.TryPredicate` 函数接受一个 Unicode 字符串，并返回一个布尔值。
- `verifcid.VerifyCID` 函数接受一个 CID 字符串，并验证其是否有效。
- `cid.CID` 函数接受一个 CID 字符串，并返回一个 CID 对象。
- `cidutil.Decode` 函数接受一个 CID 字符串和一种编码，并返回一个 Unicode 字符串。
- `cmds.BoxCmd` 函数定义了一个新命令 `boxCmd`，它接收一个 CID 对象和一个字符串参数。
- `ipldmulticodec.Marshal` 函数定义了一个新函数 `Marshal`，它接收一个 CID 对象和一个字符串参数，并返回一个编码对象。
- `mbase.MultiBase` 函数定义了一个新函数 `MultiBase`，它接收一个字符串参数，并返回一个编码对象。
- `mc.MultiCodec` 函数定义了一个新函数 `MultiCodec`，它接收一个编码对象和一个字符串参数，并返回一个 MultiCodec 对象。
- `mhash.Hash` 函数定义了一个新函数 `Hash`，它接收一个字符串参数，并返回一个哈希值。


```go
package commands

import (
	"fmt"
	"io"
	"sort"
	"strings"
	"unicode"

	verifcid "github.com/ipfs/boxo/verifcid"
	cid "github.com/ipfs/go-cid"
	cidutil "github.com/ipfs/go-cidutil"
	cmds "github.com/ipfs/go-ipfs-cmds"
	ipldmulticodec "github.com/ipld/go-ipld-prime/multicodec"
	mbase "github.com/multiformats/go-multibase"
	mc "github.com/multiformats/go-multicodec"
	mhash "github.com/multiformats/go-multihash"
)

```

该代码定义了一个名为 "CidCmd" 的命令对象，包含了多个子命令以及用于格式化、编码和哈希等操作的命令。

该命令对象的属性和方法如下：

- var CidCmd: 该命令对象的变量，存储了一个 CID 命令对象。

- Helptext: 该命令对象的属性，定义了该命令对象的帮助信息。

- Subcommands: 该命令对象的属性，定义了该命令对象的所有子命令。

- format: 该命令对象的属性，定义了该命令对象的格式选项。

- base32: 该命令对象的属性，定义了该命令对象的 base32 格式选项。

- bases: 该命令对象的属性，定义了该命令对象的 bases 子命令。

- codecs: 该命令对象的属性，定义了该命令对象的 codecs 子命令。

- hashes: 该命令对象的属性，定义了该命令对象的 hashes 子命令。

- Extra: 该命令对象的属性，定义了该命令对象的额外操作。

- CreateCmdExtras: 该命令对象的方法，实现了创建命令对象的额外操作。

- SetDoesNotUseRepo: 该命令对象的属性，定义了该命令对象是否使用仓库中的依赖项。如果设置为 true，则命令对象将不再使用仓库中的依赖项，而是直接从该命令对象中使用定义的依赖项。


```go
var CidCmd = &cmds.Command{
	Helptext: cmds.HelpText{
		Tagline: "Convert and discover properties of CIDs",
	},
	Subcommands: map[string]*cmds.Command{
		"format": cidFmtCmd,
		"base32": base32Cmd,
		"bases":  basesCmd,
		"codecs": codecsCmd,
		"hashes": hashesCmd,
	},
	Extra: CreateCmdExtras(SetDoesNotUseRepo(true)),
}

const (
	cidFormatOptionName    = "f"
	cidVerisonOptionName   = "v"
	cidCodecOptionName     = "mc"
	cidMultibaseOptionName = "b"
)

```

This appears to be a Go program that implements the `cid` package to convert between different data formats, such as Base58, Hex, and others.

It appears to be using the `营业执照` format for the `base58btc` case.

When a request is made to convert to a specific data format, the program checks the base string and the codec for the new format. If the base string is not empty and the codec is `DagProtobuf` or `base58btc`, the program converts to the specified data format. If the base string is not empty and the codec is any other data format, the program returns an error.

If the base string is `` and the codec is `0`, the program converts to `CIDv0` with the `toCidV0` function. If the base string is `1` or any other value, the program converts to `CIDv1` with the `toCidV1` function.

If the base string is not empty, the program uses the `EncoderByName` method of the `mbase.Encoder` type to convert the base string to the corresponding encoding. If the base string is `0` and the new codec is `0`, the program returns an error if the `newCodec` field is `0` and the codec is `DagProtobuf` or `base58btc`. If the base string is `1` and the new codec is any other data format, the program converts to the specified data format.

The program uses the `streamResult` method from the `cmds.PostRunMap` type to handle the output of the `fmt.Println` method. It captures any errors in the output and returns an error if the output cannot be processed.


```go
var cidFmtCmd = &cmds.Command{
	Helptext: cmds.HelpText{
		Tagline: "Format and convert a CID in various useful ways.",
		LongDescription: `
Format and converts <cid>'s in various useful ways.

The optional format string is a printf style format string:
` + cidutil.FormatRef,
	},
	Arguments: []cmds.Argument{
		cmds.StringArg("cid", true, true, "CIDs to format.").EnableStdin(),
	},
	Options: []cmds.Option{
		cmds.StringOption(cidFormatOptionName, "Printf style format string.").WithDefault("%s"),
		cmds.StringOption(cidVerisonOptionName, "CID version to convert to."),
		cmds.StringOption(cidCodecOptionName, "CID multicodec to convert to."),
		cmds.StringOption(cidMultibaseOptionName, "Multibase to display CID in."),
	},
	Run: func(req *cmds.Request, resp cmds.ResponseEmitter, env cmds.Environment) error {
		fmtStr, _ := req.Options[cidFormatOptionName].(string)
		verStr, _ := req.Options[cidVerisonOptionName].(string)
		codecStr, _ := req.Options[cidCodecOptionName].(string)
		baseStr, _ := req.Options[cidMultibaseOptionName].(string)

		opts := cidFormatOpts{}

		if strings.IndexByte(fmtStr, '%') == -1 {
			return fmt.Errorf("invalid format string: %q", fmtStr)
		}
		opts.fmtStr = fmtStr

		if codecStr != "" {
			var codec mc.Code
			err := codec.Set(codecStr)
			if err != nil {
				return err
			}
			opts.newCodec = uint64(codec)
		} // otherwise, leave it as 0 (not a valid IPLD codec)

		switch verStr {
		case "":
			if baseStr != "" {
				opts.verConv = toCidV1
			}
		case "0":
			if opts.newCodec != 0 && opts.newCodec != cid.DagProtobuf {
				return fmt.Errorf("cannot convert to CIDv0 with any codec other than dag-pb")
			}
			if baseStr != "" && baseStr != "base58btc" {
				return fmt.Errorf("cannot convert to CIDv0 with any multibase other than the implicit base58btc")
			}
			opts.verConv = toCidV0
		case "1":
			opts.verConv = toCidV1
		default:
			return fmt.Errorf("invalid cid version: %q", verStr)
		}

		if baseStr != "" {
			encoder, err := mbase.EncoderByName(baseStr)
			if err != nil {
				return err
			}
			opts.newBase = encoder.Encoding()
		} else {
			opts.newBase = mbase.Encoding(-1)
		}

		return emitCids(req, resp, opts)
	},
	PostRun: cmds.PostRunMap{
		cmds.CLI: streamResult(func(v interface{}, out io.Writer) nonFatalError {
			r := v.(*CidFormatRes)
			if r.ErrorMsg != "" {
				return nonFatalError(fmt.Sprintf("%s: %s", r.CidStr, r.ErrorMsg))
			}
			fmt.Fprintf(out, "%s\n", r.Formatted)
			return ""
		}),
	},
	Type: CidFormatRes{},
}

```

该代码定义了一个名为 "CidFormatRes" 的结构体，该结构体包含以下字段：

* CidStr：原始的 CID，作为整行字符串传递给函数。
* Formatted：格式化后的 CID，作为字符串返回。
* ErrorMsg：错误消息，作为字符串返回。

接下来定义了一个名为 "base32Cmd" 的结构体，该结构体包含了以下字段：

* Helptext：帮助文本，定义了命令的帮助信息的标签、短描述和详细描述。
* Arguments：命令参数，指定了要传递给函数的 CID 和其他选项。
* Run：函数实现，处理输入参数并返回适当的错误。
* PostRun：函数实现，在运行命令之后执行，将命令参数存储在一个变量中。
* Type：函数实现的类型，定义了命令的类型。

最后，定义了 "cidFmtCmd"，并输出了 "base32Cmd"。


```go
type CidFormatRes struct {
	CidStr    string // Original Cid String passed in
	Formatted string // Formatted Result
	ErrorMsg  string // Error
}

var base32Cmd = &cmds.Command{
	Helptext: cmds.HelpText{
		Tagline: "Convert CIDs to Base32 CID version 1.",
		ShortDescription: `
'ipfs cid base32' normalizes passed CIDs to their canonical case-insensitive encoding.
Useful when processing third-party CIDs which could come with arbitrary formats.
`,
	},
	Arguments: []cmds.Argument{
		cmds.StringArg("cid", true, true, "CIDs to convert.").EnableStdin(),
	},
	Run: func(req *cmds.Request, resp cmds.ResponseEmitter, env cmds.Environment) error {
		opts := cidFormatOpts{
			fmtStr:  "%s",
			newBase: mbase.Encoding(mbase.Base32),
			verConv: toCidV1,
		}
		return emitCids(req, resp, opts)
	},
	PostRun: cidFmtCmd.PostRun,
	Type:    cidFmtCmd.Type,
}

```

该代码定义了一个名为 "cidFormatOpts" 的结构体类型，它表示了用于将 CID 格式化为字符串格式的选项。该结构体包含三个成员变量：

1. "fmtStr"：表示字符串格式化串，用于格式化 CID 中的格式字符。
2. "newBase"：表示新基，用于将 CID 中的 base 字段转换为新基。
3. "verConv"：表示验证函数，用于验证 CID 格式的有效性并返回错误。

该结构体还包含一个名为 "argumentIterator" 的接口类型，用于定义一个用于遍历 CID 参数的迭代器。

该代码的用途是定义了一个 CID 格式化选项的结构体，该结构体可以用于将 CID 格式化为字符串格式的选项，并定义了一个 "argumentIterator" 的接口类型，用于遍历 CID 参数。


```go
type cidFormatOpts struct {
	fmtStr   string
	newBase  mbase.Encoding
	verConv  func(cid cid.Cid) (cid.Cid, error)
	newCodec uint64
}

type argumentIterator struct {
	args []string
	body cmds.StdinArguments
}

func (i *argumentIterator) next() (string, bool) {
	if len(i.args) > 0 {
		arg := i.args[0]
		i.args = i.args[1:]
		return arg, true
	}
	if i.body == nil || !i.body.Scan() {
		return "", false
	}
	return strings.TrimSpace(i.body.Argument()), true
}

```

This is a function that decodes a Citrix Receiver (CR) CID (Citrix Identity Document) string into a CID Format string.

The function takes a Citrix Identity Document (CID) string as input, and an optional format string, an optional base, and an optional converter. The base is used to convert the CID to a base58 format if it is not already a base58 string.

The function first checks if the input is valid and returns an error if it is not. If the input is valid, the function then decodes the CID into a CID Format string. If the decoding fails, an error message is emitted and the error is propagated up the chain. If the input is valid but the base is not specified, the function defaults to the default base58base.

The function then formats the CID string using the specified format string and the specified base, and emits the CID string along with an error message if there are any issues with the format string or the base.

Finally, the function also emits any errors that occurred during the process, and any errors that occurred during the formatting of the CID string.

Note: This function should be called from a function that has already been called to avoid making unnecessary calls.


```go
func (i *argumentIterator) err() error {
	if i.body == nil {
		return nil
	}
	return i.body.Err()
}

func emitCids(req *cmds.Request, resp cmds.ResponseEmitter, opts cidFormatOpts) error {
	itr := argumentIterator{req.Arguments, req.BodyArgs()}
	var emitErr error
	for emitErr == nil {
		cidStr, ok := itr.next()
		if !ok {
			break
		}
		res := &CidFormatRes{CidStr: cidStr}
		c, err := cid.Decode(cidStr)
		if err != nil {
			res.ErrorMsg = err.Error()
			emitErr = resp.Emit(res)
			continue
		}

		if opts.newCodec != 0 && opts.newCodec != c.Type() {
			c = cid.NewCidV1(opts.newCodec, c.Hash())
		}

		if opts.verConv != nil {
			c, err = opts.verConv(c)
			if err != nil {
				res.ErrorMsg = err.Error()
				emitErr = resp.Emit(res)
				continue
			}
		}

		base := opts.newBase
		if base == -1 {
			if c.Version() == 0 {
				base = mbase.Base58BTC
			} else {
				base, _ = cid.ExtractEncoding(cidStr)
			}
		}

		str, err := cidutil.Format(opts.fmtStr, base, c)
		if _, ok := err.(cidutil.FormatStringError); ok {
			// no point in continuing if there is a problem with the format string
			return err
		}
		if err != nil {
			res.ErrorMsg = err.Error()
		} else {
			res.Formatted = str
		}
		emitErr = resp.Emit(res)
	}
	if emitErr != nil {
		return emitErr
	}
	err := itr.err()
	if err != nil {
		return err
	}
	return nil
}

```

这两函数主要用于将输入的CID类型转换为CIDV0或CIDV1类型。

函数`toCidV0`接收一个CID类型参数，首先检查该CID类型是否与`cid.DagProtobuf`相同。如果不同，那么将返回一个CID类型和一个错误消息，错误消息将会包含一个`fmt.Errorf`函数，该函数将`"can't convert non-dag-pb nodes to cidv0"`作为其错误消息。否则，如果CID类型与`cid.DagProtobuf`相同，那么返回输入的CID类型。

函数`toCidV1`与`toCidV0`类似，只是返回类型将根据输入的CID类型来决定。如果输入的CID类型与`cid.DagProtobuf`相同，那么返回一个新的`cid.Cid`类型。否则，返回一个新的`cid.Cid`类型和一个错误消息。

结构体`CodeAndName`定义了一个包含代码和名称的字符串类型。这些函数主要作用于将CID类型转换为`CodeAndName`类型，但没有具体的实现，因此无法提供其功能。


```go
func toCidV0(c cid.Cid) (cid.Cid, error) {
	if c.Type() != cid.DagProtobuf {
		return cid.Cid{}, fmt.Errorf("can't convert non-dag-pb nodes to cidv0")
	}
	return cid.NewCidV0(c.Hash()), nil
}

func toCidV1(c cid.Cid) (cid.Cid, error) {
	return cid.NewCidV1(c.Type(), c.Hash()), nil
}

type CodeAndName struct {
	Code int
	Name string
}

```

This appears to be a CM/types-generated Go program that implements the CodeAndName type, which represents a code and a name for a given piece of code. The program provides a `-m` flag to specify the encoding to use when generating the names, and a `-n` flag to specify whether to generate numerical code and names.

The `CodeAndName` struct represents the code and name for a given piece of code. The code is encoded from base64, and the name is generated by the `EncodingToStr` function.

The `Encoders` map is used to map the `-m` and `-n` flags to the appropriate encoder functions. The `-m` flag maps to the `CodeAndName` struct's `-n` method, while the `-n` flag maps to the `CodeAndName` struct's `-m` method.

The `multibaseSorter` function is used in the `-m` flag's `CodeAndName` method to sort the codes by length and prefixes.

Overall, this program provides a simple way to generate code and names for different pieces of code in different encodings.


```go
const (
	prefixOptionName  = "prefix"
	numericOptionName = "numeric"
)

var basesCmd = &cmds.Command{
	Helptext: cmds.HelpText{
		Tagline: "List available multibase encodings.",
		ShortDescription: `
'ipfs cid bases' relies on https://github.com/multiformats/go-multibase
`,
	},
	Options: []cmds.Option{
		cmds.BoolOption(prefixOptionName, "also include the single letter prefixes in addition to the code"),
		cmds.BoolOption(numericOptionName, "also include numeric codes"),
	},
	Run: func(req *cmds.Request, resp cmds.ResponseEmitter, env cmds.Environment) error {
		var res []CodeAndName
		// use EncodingToStr in case at some point there are multiple names for a given code
		for code, name := range mbase.EncodingToStr {
			res = append(res, CodeAndName{int(code), name})
		}
		return cmds.EmitOnce(resp, res)
	},
	Encoders: cmds.EncoderMap{
		cmds.Text: cmds.MakeTypedEncoder(func(req *cmds.Request, w io.Writer, val []CodeAndName) error {
			prefixes, _ := req.Options[prefixOptionName].(bool)
			numeric, _ := req.Options[numericOptionName].(bool)
			sort.Sort(multibaseSorter{val})
			for _, v := range val {
				code := v.Code
				if code < 32 || code >= 127 {
					// don't display non-printable prefixes
					code = ' '
				}
				switch {
				case prefixes && numeric:
					fmt.Fprintf(w, "%c %7d  %s\n", code, v.Code, v.Name)
				case prefixes:
					fmt.Fprintf(w, "%c  %s\n", code, v.Name)
				case numeric:
					fmt.Fprintf(w, "%7d  %s\n", v.Code, v.Name)
				default:
					fmt.Fprintf(w, "%s\n", v.Name)
				}
			}
			return nil
		}),
	},
	Type: []CodeAndName{},
}

```

The `ListEncoders` function returns a map of supported encoder codes, where each key is a `CodeAndName` struct containing the code and a name. The `ListDecoders` function returns a similar map of supported decoder codes.

The `CodeAndName` struct represents a combination of a code and a name for a supported encoding or decoding operation. The code is represented as a `uint64` and the name is represented as a `string`.

The `res` slice is updated with new entries, and the entry for the `uint64(mc.Libp2pKey)` code is added with the `supportedCodecs` map.


```go
const (
	codecsNumericOptionName   = "numeric"
	codecsSupportedOptionName = "supported"
)

var codecsCmd = &cmds.Command{
	Helptext: cmds.HelpText{
		Tagline: "List available CID multicodecs.",
		ShortDescription: `
'ipfs cid codecs' relies on https://github.com/multiformats/go-multicodec
`,
	},
	Options: []cmds.Option{
		cmds.BoolOption(codecsNumericOptionName, "n", "also include numeric codes"),
		cmds.BoolOption(codecsSupportedOptionName, "s", "list only codecs supported by go-ipfs commands"),
	},
	Run: func(req *cmds.Request, resp cmds.ResponseEmitter, env cmds.Environment) error {
		listSupported, _ := req.Options[codecsSupportedOptionName].(bool)
		supportedCodecs := make(map[uint64]struct{})
		if listSupported {
			for _, code := range ipldmulticodec.ListEncoders() {
				supportedCodecs[code] = struct{}{}
			}
			for _, code := range ipldmulticodec.ListDecoders() {
				supportedCodecs[code] = struct{}{}
			}
			// add libp2p-key
			supportedCodecs[uint64(mc.Libp2pKey)] = struct{}{}
		}

		var res []CodeAndName
		for _, code := range mc.KnownCodes() {
			if code.Tag() == "ipld" {
				if listSupported {
					if _, ok := supportedCodecs[uint64(code)]; !ok {
						continue
					}
				}
				res = append(res, CodeAndName{int(code), mc.Code(code).String()})
			}
		}
		return cmds.EmitOnce(resp, res)
	},
	Encoders: cmds.EncoderMap{
		cmds.Text: cmds.MakeTypedEncoder(func(req *cmds.Request, w io.Writer, val []CodeAndName) error {
			numeric, _ := req.Options[codecsNumericOptionName].(bool)
			sort.Sort(codeAndNameSorter{val})
			for _, v := range val {
				if numeric {
					fmt.Fprintf(w, "%5d  %s\n", v.Code, v.Name)
				} else {
					fmt.Fprintf(w, "%s\n", v.Name)
				}
			}
			return nil
		}),
	},
	Type: []CodeAndName{},
}

```

这段代码定义了一个名为 "hashesCmd" 的 MultihashCommand。该命令的 Helptext 提供了对它的描述，短描述，以及选项。Run 函数实现了命令的行为，即当请求发送时，会处理并返回数据。具体来说，它会遍历所有可用的 Multihash 编码，对于每个可用的编码，它将产生一个具有编码编号和名称的 CodeAndName 对象，并将它们添加到结果集合中。最后，它使用 cmds.EmitOnce 函数将结果返回，并使用 codecsCmd.Encoders 函数将编码 Encode 发送。


```go
var hashesCmd = &cmds.Command{
	Helptext: cmds.HelpText{
		Tagline: "List available multihashes.",
		ShortDescription: `
'ipfs cid hashes' relies on https://github.com/multiformats/go-multihash
`,
	},
	Options: codecsCmd.Options,
	Run: func(req *cmds.Request, resp cmds.ResponseEmitter, env cmds.Environment) error {
		var res []CodeAndName
		// use mhash.Codes in case at some point there are multiple names for a given code
		for code, name := range mhash.Codes {
			if !verifcid.DefaultAllowlist.IsAllowed(code) {
				continue
			}
			res = append(res, CodeAndName{int(code), name})
		}
		return cmds.EmitOnce(resp, res)
	},
	Encoders: codecsCmd.Encoders,
	Type:     codecsCmd.Type,
}

```

这段代码定义了一个名为`multibaseSorter`的结构体，该结构体具有以下三个方法：

1. `Len()`方法返回排序前`data`数组的长度。
2. `Swap()`方法交换排序前`data`数组中两个元素的值。
3. `Less()`方法根据两个元素的`Code`值，将`Lower()`为小写字母的元素放在前面，否则将`Lower()`为大写字母的元素放在前面。

在这个结构体中，`data`数组是一个有序的`CodeAndName`类型的数组，其中`Code`是编码，`Name`是名称。该结构体用于排序一个包含`Code`和`Name`的数组，以便将具有相同编码的元素按照名称排序。


```go
type multibaseSorter struct {
	data []CodeAndName
}

func (s multibaseSorter) Len() int      { return len(s.data) }
func (s multibaseSorter) Swap(i, j int) { s.data[i], s.data[j] = s.data[j], s.data[i] }

func (s multibaseSorter) Less(i, j int) bool {
	a := unicode.ToLower(rune(s.data[i].Code))
	b := unicode.ToLower(rune(s.data[j].Code))
	if a != b {
		return a < b
	}
	// lowecase letters should come before uppercase
	return s.data[i].Code > s.data[j].Code
}

```

这段代码定义了一个名为 `codeAndNameSorter` 的结构体类型，其包含一个名为 `data` 的数组。这个结构体类型定义了三个方法：

1. `Len()` 方法返回一个整数，表示 `codeAndNameSorter` 结构体中 `data` 数组的长度。
2. `Swap()` 方法交换了 `codeAndNameSorter` 结构体中两个元素的值，并将 `i` 和 `j` 的值作为参数传入。
3. `Less()` 方法比较两个元素的码，返回一个布尔值，表示哪个元素在数组中应该排在前面。

该 `codeAndNameSorter` 结构体类型的实例可以被赋值为以下方式：


type example struct {
	CodeAndNames []CodeAndName `码并命名排序`
}

func main() {
	s := example{
		CodeAndNames: []CodeAndName{
			{"排序测试", 89},
			{"测试排序", 55},
			{"大小写比较", 88},
			{"_2排序测试", 56},
		},
	}

	// 输出排序测试排序前的代码
	fmt.Println(s.Len()) // 输出 4

	// 交换 s.data[0] 和 s.data[1] 的值
	s.Swap(0, 1)

	// 输出排序测试排序后的代码
	fmt.Println(s.Len()) // 输出 3

	// 输出排序测试代码中，排序测试排序前的顺序
	fmt.Println(s.Less(0, 1)) // 输出 true
	fmt.Println(s.Less(1, 0)) // 输出 false
}


这个 `codeAndNameSorter` 结构体类型的实例通常用于对一个数组进行排序，其 `data` 数组中的元素都是 `CodeAndName` 类型的结构体，其中 `Code` 和 `Name` 是字段的名称。这个 `codeAndNameSorter` 实例提供了一些方法来对这个数组进行排序、交换元素以及比较元素的大小。


```go
type codeAndNameSorter struct {
	data []CodeAndName
}

func (s codeAndNameSorter) Len() int           { return len(s.data) }
func (s codeAndNameSorter) Swap(i, j int)      { s.data[i], s.data[j] = s.data[j], s.data[i] }
func (s codeAndNameSorter) Less(i, j int) bool { return s.data[i].Code < s.data[j].Code }

```

# `core/commands/cid_test.go`

This appears to be a testing function for a command-line tool called `cidFmtCmd`. The testing is done by passing different input values through the command, and then measuring any errors that may occur.

The input values being tested are all variations of a base32-encoded value, with the first test case being the expected output for the base32-padding of the string "zdj7WWwMSWGoyxYkkT7mHgYvr6tV8CYd77aYxxqSbg9HsiMcE". The other test cases are similar, but with different base32-encoded values.

It's important to note that this testing function is only a simple example, and does not provide any error handling or validation for the `cidFmtCmd` function. It is therefore recommended to thoroughly test the function in a production environment before using it in production.


```go
package commands

import (
	"testing"

	cmds "github.com/ipfs/go-ipfs-cmds"
	"github.com/multiformats/go-multibase"
)

func TestCidFmtCmd(t *testing.T) {
	t.Parallel()

	// Test 'error when -v 0 is present and a custom -b is passed'
	t.Run("ipfs cid format <cid> -b z -v 0", func(t *testing.T) {
		t.Parallel()

		type testV0PresentAndCustomBaseCase struct {
			MultibaseName  string
			ExpectedErrMsg string
		}

		var testV0PresentAndCustomBaseCases []testV0PresentAndCustomBaseCase

		for _, e := range multibase.EncodingToStr {
			var testCase testV0PresentAndCustomBaseCase

			if e == "base58btc" {
				testCase.MultibaseName = e
				testCase.ExpectedErrMsg = ""
				testV0PresentAndCustomBaseCases = append(testV0PresentAndCustomBaseCases, testCase)
				continue
			}
			testCase.MultibaseName = e
			testCase.ExpectedErrMsg = "cannot convert to CIDv0 with any multibase other than the implicit base58btc"
			testV0PresentAndCustomBaseCases = append(testV0PresentAndCustomBaseCases, testCase)
		}

		for _, e := range testV0PresentAndCustomBaseCases {

			// Mock request
			req := &cmds.Request{
				Options: map[string]interface{}{
					cidVerisonOptionName:   "0",
					cidMultibaseOptionName: e.MultibaseName,
					cidFormatOptionName:    "%s",
				},
			}

			// Response emitter
			resp := cmds.ResponseEmitter(nil)

			// Call the CidFmtCmd function with the mock request and response
			err := cidFmtCmd.Run(req, resp, nil)
			if err == nil && e.MultibaseName == "base58btc" {
				continue
			}

			errMsg := err.Error()
			if errMsg != e.ExpectedErrMsg {
				t.Errorf("Expected %s, got %s instead", e.ExpectedErrMsg, errMsg)
			}
		}
	})

	// Test 'upgrade CID to v1 when passing a custom -b and no -v is specified'
	t.Run("ipfs cid format <cid-version-0> -b z", func(t *testing.T) {
		t.Parallel()

		type testImplicitVersionAndCustomMultibaseCase struct {
			Ver           string
			CidV1         string
			CidV0         string
			MultibaseName string
		}

		var testCases = []testImplicitVersionAndCustomMultibaseCase{
			{
				Ver:           "",
				CidV1:         "zdj7WWwMSWGoyxYkkT7mHgYvr6tV8CYd77aYxxqSbg9HsiMcE",
				CidV0:         "QmPr755CxWUwt39C2Yiw4UGKrv16uZhSgeZJmoHUUS9TSJ",
				MultibaseName: "z",
			},
			{
				Ver:           "",
				CidV1:         "CAFYBEIDI7ZABPGG3S63QW3AJG2XAZNE4NJQPN777WLWYRAIDG3TE5QFN3A======",
				CidV0:         "QmVQVyEijmLb2cBQrowNQsaPbnUnJhfDK1sYe3wepm6ySf",
				MultibaseName: "base32padupper",
			},
		}
		for _, e := range testCases {
			// Mock request
			req := &cmds.Request{
				Options: map[string]interface{}{
					cidVerisonOptionName:   e.Ver,
					cidMultibaseOptionName: e.MultibaseName,
					cidFormatOptionName:    "%s",
				},
			}

			// Response emitter
			resp := cmds.ResponseEmitter(nil)

			// Call the CidFmtCmd function with the mock request and response
			err := cidFmtCmd.Run(req, resp, nil)

			if err != nil {
				t.Error(err)
			}
		}
	})
}

```

# `core/commands/commands.go`

这段代码定义了一个名为“packages”的包，该包实现了IPFS命令接口。它导入了来自github.com/ipfs/kubo/commands的命令行和HTTP API，这是从Go语言环境中使用IPFS的外部用户可以使用的接口。

具体来说，这段代码实现了以下功能：

1. 定义了一个名为“packages”的包。
2. 导入了来自github.com/ipfs/go-ipfs-cmds的命令行和HTTP API。
3. 通过使用ipsGo.Migrate.命令将当前目录下的所有IPFS配置文件翻译成Kubernetes规范。
4. 通过使用ipsGo.Migrate.Company命令将当前目录下的所有IPFS配置文件翻译成Markdown格式。
5. 通过使用sort.Strings.Sort命令对当前目录下的所有IPFS配置文件按照字段进行排序。
6. 通过使用strings.Split命令将当前目录下的所有IPFS配置文件按行分割成多个部分，并将每个部分的文件名存储在ipsGo.Migrate.Formats.ExtraArgs中。
7. 通过使用fmt.Printf函数将当前目录下的所有IPFS配置文件的字符串打印出来，以便用户查看。

总之，这段代码实现了将IPFS命令行和HTTP API与Go语言环境结合使用，以便用户在Kubernetes环境中使用IPFS。


```go
// Package commands implements the ipfs command interface
//
// Using github.com/ipfs/kubo/commands to define the command line and HTTP
// APIs.  This is the interface available to folks using IPFS from outside of
// the Go language.
package commands

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"

	cmds "github.com/ipfs/go-ipfs-cmds"
)

```

该代码定义了一个名为 "commandEncoder" 的结构体，该结构体包含一个 "w" 类型的 "io.Writer" 字段和一个名为 "Encode" 的方法。

"Encode" 方法接受一个 "interface{}"，该方法返回一个 "error" 类型的变量 "e"。

该方法首先检查给定的 "Command" 类型的变量是否与 "Encode" 方法中的类型匹配。如果不匹配，该方法返回一个错误消息。

如果给定的 "Command" 类型与 "Encode" 方法中的类型匹配，那么该方法将循环遍历 "Command" 类型中包含的方法调用，并使用 "w" 类型的 "io.Writer" 字段将参数 "s" 写入 "w" 类型中的 "[]byte" 切片。如果写入过程中出现错误，该方法返回该错误。

最后，该方法返回一个 "error" 类型的变量 "e"，如果没有返回任何错误，该方法返回 nil。


```go
type commandEncoder struct {
	w io.Writer
}

func (e *commandEncoder) Encode(v interface{}) error {
	var (
		cmd *Command
		ok  bool
	)

	if cmd, ok = v.(*Command); !ok {
		return fmt.Errorf(`core/commands: unexpected type %T, expected *"core/commands".Command`, v)
	}

	for _, s := range cmdPathStrings(cmd, cmd.showOpts) {
		_, err := e.w.Write([]byte(s + "\n"))
		if err != nil {
			return err
		}
	}

	return nil
}

```

这段代码定义了一个名为 "Command" 的结构体类型，它包含了名称、子命令和选项。

同时，定义了一个名为 "Option" 的结构体类型，它包含了一组名称。

最后，定义了一个名为 "showOpts" 的布尔变量，以及一个名为 "flagsOptionName" 的常量。

根据这些信息，可以推测出这段代码可能是一个命令行工具的定义，其中包含了不同种类的命令、可选项和用于控制这些命令和选项的选项。

例如，这个命令行工具可能允许用户自定义命令、设置选项和显示选项的名称。


```go
type Command struct {
	Name        string
	Subcommands []Command
	Options     []Option

	showOpts bool
}

type Option struct {
	Names []string
}

const (
	flagsOptionName = "flags"
)

```

该代码定义了一个名为 "CommandsCmd" 的函数，它接受一个根命令（cmd）并返回一个命令，该命令列出根命令中的所有子命令（subcommand）。

函数中包含以下部分：

1. 一个字符串类型的 "CommandsCmd" 函数，它接受一个名为 "root" 的 cmds.Command 类型的参数。
2. 一个字符串类型的 "CommandsCmd" 函数的 Helptext，它列出了该命令的用途，短描述和完整描述。
3. 一个字典类型的 "CommandsCmd" 函数的子命令列表，其中包含名为 "completion" 的子命令，它是CompletionCmd函数的实例。
4. 一个包含选项的 "CommandsCmd" 函数的选项列表，其中包含一个名为 "f" 的 cmds.BoolOption。
5. 一个内部函数 CreateCmdExtras，该函数用于设置或取消使用附加功能，例如输出repo设置。
6. 一个内部函数 SetDoesNotUseRepo，该函数用于设置或取消使用输出repo设置。
7. 一个内部函数 Run，该函数在请求、响应和环境参数都被正确设置后，运行函数内部的一个 cmds.Command。
8. 在 Run 函数内部，使用 cmd2outputCmd 将 "ipfs" 命令的根目录输出为 stdout，并设置给请求的 Options 中的 "f" 选项为 true，然后调用 rootCmd.showOpts，最后返回。
9. 在 Encoders 内部，使用 maps 类型存储所有可用的编码器，其中 maps 内部使用的是 commandEncoder，通过 w io.Writer 类型的参数传递写入。


```go
// CommandsCmd takes in a root command,
// and returns a command that lists the subcommands in that root
func CommandsCmd(root *cmds.Command) *cmds.Command {
	return &cmds.Command{
		Helptext: cmds.HelpText{
			Tagline:          "List all available commands.",
			ShortDescription: `Lists all available commands (and subcommands) and exits.`,
		},
		Subcommands: map[string]*cmds.Command{
			"completion": CompletionCmd(root),
		},
		Options: []cmds.Option{
			cmds.BoolOption(flagsOptionName, "f", "Show command flags"),
		},
		Extra: CreateCmdExtras(SetDoesNotUseRepo(true)),
		Run: func(req *cmds.Request, res cmds.ResponseEmitter, env cmds.Environment) error {
			rootCmd := cmd2outputCmd("ipfs", root)
			rootCmd.showOpts, _ = req.Options[flagsOptionName].(bool)
			return cmds.EmitOnce(res, &rootCmd)
		},
		Encoders: cmds.EncoderMap{
			cmds.Text: func(req *cmds.Request) func(io.Writer) cmds.Encoder {
				return func(w io.Writer) cmds.Encoder { return &commandEncoder{w} }
			},
		},
		Type: Command{},
	}
}

```

该代码定义了一个名为“cmd2outputCmd”的函数，接受一个名为“cmd”的命令行参数和一个名为“cmd.Commands”的链式参数。函数的作用是将“cmd.Commands”中的每个子命令转换为一个名为“output”的新命令行参数，其中“output”包含了该子命令的名称、选项和输出命令行参数。

函数的实现主要分为两个步骤：首先，根据“cmd.Options”遍历每个子命令的选项并创建一个名为“opts”的数组长度为“len(cmd.Options)”的选项数组；然后，将“opts”数组中的每个选项设置为子命令的选项名称，从而创建了一个新的“output”命令行参数。

接着，函数遍历“cmd.Commands”中的每个子命令，将子命令转换为新的“output”命令行参数，并将其添加到“output.Subcommands”数组中。这样，最终“output.Subcommands”数组中包含了原命令的所有子命令和它们的输出命令行参数。

函数最终返回一个名为“output”的新命令行参数，该参数包含了原命令的所有子命令和它们的输出命令行参数。


```go
func cmd2outputCmd(name string, cmd *cmds.Command) Command {
	opts := make([]Option, len(cmd.Options))
	for i, opt := range cmd.Options {
		opts[i] = Option{opt.Names()}
	}

	output := Command{
		Name:        name,
		Subcommands: make([]Command, 0, len(cmd.Subcommands)),
		Options:     opts,
	}

	for name, sub := range cmd.Subcommands {
		output.Subcommands = append(output.Subcommands, cmd2outputCmd(name, sub))
	}

	return output
}

```

该函数`cmdPathStrings`接收一个命令行参数`cmd`和一个布尔选项`showOptions`。函数内部创建一个空字符串数组`cmds`，然后递归地处理给定的命令`cmd`及其子命令。

函数内部定义了一个名为`recurse`的函数，该函数处理给定的前缀`prefix`和命令`cmd`。`recurse`函数将创建一个新前缀`newPrefix`，并将该前缀添加到命令的参数中。如果设置了`showOptions`选项为真，则递归地处理给定的选项。

`recurse`函数处理子命令时，将创建一个新前缀`newPrefix`，并将其添加到命令参数中。然后，如果给定的前缀不为空，并且`showOptions`选项为真，则递归地处理给定的选项。递归处理选项时，将创建一个字符串，其中包含前缀和选项的拉糟组合。然后，将这个字符串加入到命令参数中。

在`recurse`函数处理子命令之后，将创建一个空字符串数组`cmds`，并使用`sort.Strings`函数对数组进行排序。最后，函数返回排好序的命令参数数组。


```go
func cmdPathStrings(cmd *Command, showOptions bool) []string {
	var cmds []string

	var recurse func(prefix string, cmd *Command)
	recurse = func(prefix string, cmd *Command) {
		newPrefix := prefix + cmd.Name
		cmds = append(cmds, newPrefix)
		if prefix != "" && showOptions {
			for _, options := range cmd.Options {
				var cmdOpts []string
				for _, flag := range options.Names {
					if len(flag) == 1 {
						flag = "-" + flag
					} else {
						flag = "--" + flag
					}
					cmdOpts = append(cmdOpts, newPrefix+" "+flag)
				}
				cmds = append(cmds, strings.Join(cmdOpts, " / "))
			}
		}
		for _, sub := range cmd.Subcommands {
			recurse(newPrefix+" ", &sub)
		}
	}

	recurse("", cmd)
	sort.Strings(cmds)
	return cmds
}

```

这段代码定义了一个名为CompletionCmd的函数，它接收一个根目录（根目录）的CMDS.Command对象。函数返回一个指向生成Completion命令的CMDS.Command对象的指针。

CompletionCmd的作用是生成命令的Completion输出。它通过在根目录下创建一个名为Completion.txt的文件来保存生成的Completion命令。通过编写以下行来创建Completion.txt文件并添加Completion命令的完成输出：
bash
echo "Generate shell completions." > Completion.txt
echo " " >> Completion.txt
echo "The simplest way to see it working is write the completions" >> Completion.txt

这段代码首先创建一个名为Completion.txt的文件，并向其中添加了Completion命令的完成输出。接下来，它将生成Completion命令并将其添加到Completion.txt文件中。

当函数被调用时，它会返回一个指向生成Completion命令的CMDS.Command对象的指针。这意味着可以通过在晚后续和使用函数返回的指针来访问生成的Completion命令。


```go
func CompletionCmd(root *cmds.Command) *cmds.Command {
	return &cmds.Command{
		Helptext: cmds.HelpText{
			Tagline: "Generate shell completions.",
		},
		NoRemote: true,
		Subcommands: map[string]*cmds.Command{
			"bash": {
				Helptext: cmds.HelpText{
					Tagline:          "Generate bash shell completions.",
					ShortDescription: "Generates command completions for the bash shell.",
					LongDescription: `
Generates command completions for the bash shell.

The simplest way to see it working is write the completions
```

This code appears to be a bash script that installs completion functionality for the ipfs-completion package and outputs the completed commands to a file called ipfs-completion.bash.

It first checks if the completion package is already installed and, if not, installs it using the `ipfs commands completion bash` command. Once the installation is complete, it is then sourced (i.e., executed) the script from the current directory (`./ipfs-completion.bash`).

The script is also configured to run the `ipfs-completion.bash` script as the function when the `ipfs commands completion bash` command is executed. This means that when the completion functionality is used, the script will be run and the defined completion commands will be executed.

Finally, the script checks if the `NoRemote` option is set to `true` and, if it is, the `func` function is defined. This function takes three arguments: a `req` object, a `res` object, and an environment object. The `req` object is used to store information about the request, the `res` object is used to store the response emitted by the function, and the environment object is used to store information about the environment in which the function is being executed.

The `writeBashCompletions` function is called with the root directory and a `buf` bytes.Buffer as arguments. The function is responsible for writing the completion commands to the file. If an error occurs while writing the file, the function returns it.


```go
to a file and then source it:

  > ipfs commands completion bash > ipfs-completion.bash
  > source ./ipfs-completion.bash

To install the completions permanently, they can be moved to
/etc/bash_completion.d or sourced from your ~/.bashrc file.
`,
				},
				NoRemote: true,
				Run: func(req *cmds.Request, res cmds.ResponseEmitter, env cmds.Environment) error {
					var buf bytes.Buffer
					if err := writeBashCompletions(root, &buf); err != nil {
						return err
					}
					res.SetLength(uint64(buf.Len()))
					return res.Emit(&buf)
				},
			},
			"zsh": {
				Helptext: cmds.HelpText{
					Tagline:          "Generate zsh shell completions.",
					ShortDescription: "Generates command completions for the zsh shell.",
					LongDescription: `
```

This code is a script that generates command completions for the zsh shell. When run, it completion will be saved to a file called ipfs-completion.zsh and then sourced from the ./ipfs-completion.zsh file.

To see the working of the code, you can simply write the completions to a file and then run the script.

As mentioned, the simplest way to see the working of this code is by writing the completions to a file and then running the script.

To install the completions permanently, they can be moved to /etc/zsh/completions or sourced from your ~/.zshrc file.


```go
Generates command completions for the zsh shell.

The simplest way to see it working is write the completions
to a file and then source it:

  > ipfs commands completion zsh > ipfs-completion.zsh
  > source ./ipfs-completion.zsh

To install the completions permanently, they can be moved to
/etc/zsh/completions or sourced from your ~/.zshrc file.
`,
				},
				NoRemote: true,
				Run: func(req *cmds.Request, res cmds.ResponseEmitter, env cmds.Environment) error {
					var buf bytes.Buffer
					if err := writeZshCompletions(root, &buf); err != nil {
						return err
					}
					res.SetLength(uint64(buf.Len()))
					return res.Emit(&buf)
				},
			},
			"fish": {
				Helptext: cmds.HelpText{
					Tagline:          "Generate fish shell completions.",
					ShortDescription: "Generates command completions for the fish shell.",
					LongDescription: `
```

此代码是一个命令行工具，名为"ipfs-completion"，它使用Fish shell作为其交互式用户界面。它主要用于生成Fish shell的命令完成（completion）列表，并将它们保存到一个名为"ipfs-completion.fish"的文件中。

具体来说，这段代码实现了以下功能：

1. 生成Fish shell命令完成列表，并将它们保存到"ipfs-completion.fish"文件中。
2. 通过写入Fish shell命令完成列表到"ipfs-completion.fish"文件中，并使用source命令将该文件的内容复制到当前Fish shell会话中。
3. 提供了一个名为"ipfs commands completion fish"的命令行接口，用于查看并运行"ipfs-completion"工具。
4. 提供了一个用于将"ipfs-completion"工具安装到Fish shell的命令，可以将该命令保存到"/etc/fish/completions"、"~/.config/fish/completions"或"~/.config/fish/config.fish"等系统文件中。


```go
Generates command completions for the fish shell.

The simplest way to see it working is write the completions
to a file and then source it:

  > ipfs commands completion fish > ipfs-completion.fish
  > source ./ipfs-completion.fish

To install the completions permanently, they can be moved to
/etc/fish/completions or ~/.config/fish/completions or sourced from your ~/.config/fish/config.fish file.
`,
				},
				NoRemote: true,
				Run: func(req *cmds.Request, res cmds.ResponseEmitter, env cmds.Environment) error {
					var buf bytes.Buffer
					if err := writeFishCompletions(root, &buf); err != nil {
						return err
					}
					res.SetLength(uint64(buf.Len()))
					return res.Emit(&buf)
				},
			},
		},
	}
}

```

该代码定义了一个名为 `streamResult` 的函数，其作用是处理命令行输出中的结果，可能会包含非致命错误。

该函数接受两个参数：`procVal` 和 `io.Writer`。`procVal` 是一个函数，它接受两个参数，一个是 `interface{}`，另一个是 `io.Writer`。它返回一个 `nonFatalError` 类型的结果，可以选择忽略非致命错误并输出该错误。

`streamResult` 的实现是通过一个循环来读取命令行输出中的每一行，并对其中的每个值调用 `procVal`，然后处理可能的结果。如果 `procVal` 返回一个非空字符串，函数将使用 `fmt.Fprintf` 函数将该错误消息输出到 `os.Stderr`。否则，函数将设置 `errors` 变量为 `true`，并使用 `fmt.Fatalf` 函数输出一个错误消息。

最后，如果 `procVal` 返回一个空字符串或出现任何错误，函数将为该错误输出一个非空字符串，并返回一个非空 `io.Error`。


```go
type nonFatalError string

// streamResult is a helper function to stream results that possibly
// contain non-fatal errors.  The helper function is allowed to panic
// on internal errors.
func streamResult(procVal func(interface{}, io.Writer) nonFatalError) func(cmds.Response, cmds.ResponseEmitter) error {
	return func(res cmds.Response, re cmds.ResponseEmitter) (err error) {
		defer func() {
			if r := recover(); r != nil {
				err = fmt.Errorf("internal error: %v", r)
			}
			re.Close()
		}()

		var errors bool
		for {
			v, err := res.Next()
			if err != nil {
				if err == io.EOF {
					break
				}
				return err
			}

			errorMsg := procVal(v, os.Stdout)

			if errorMsg != "" {
				errors = true
				fmt.Fprintf(os.Stderr, "%s\n", errorMsg)
			}
		}

		if errors {
			return fmt.Errorf("errors while displaying some entries")
		}
		return nil
	}
}

```

# `core/commands/commands_test.go`

这段代码定义了一个名为 `collectPaths` 的函数，该函数接受一个前缀字符串 `prefix` 和一个 `cmds.Command` 类型的参数 `cmd`，并输出一个 `map[string]struct{}` 类型的变量 `out`，其中键是路径名，值为包含该路径命名的 `struct{}` 类型的数据。

函数内部首先遍历 `cmd.Subcommands` 字段，对于每个子命令，将路径前缀加上子命令名称，并将其值设置为 `struct{}{}` 类型的空 struct。然后递归调用 `collectPaths` 函数本身，将子命令的路径也传递给 `collectPaths` 函数。这样就实现了遍历所有子命令并输出它们的路径，将结果存储到 `out` 变量中。


```go
package commands

import (
	"strings"
	"testing"

	cmds "github.com/ipfs/go-ipfs-cmds"
)

func collectPaths(prefix string, cmd *cmds.Command, out map[string]struct{}) {
	for name, sub := range cmd.Subcommands {
		path := prefix + "/" + name
		out[path] = struct{}{}
		collectPaths(path, sub, out)
	}
}

```

This is a Go program that provides a simple command-line interface for managing DAG (directed acyclic graph) data structures. The program provides a set of built-in commands for common operations, such as generating a DAG, getting a specific node's data, and resolving references to nodes in the graph.

The program also provides a way to collect and organize the different commands that can be used to perform these operations into a tree-like structure called a "cmdSet". This allows the user to easily navigate and find the commands they need, and also allows the program to keep track of which commands have already been executed for each command-line interaction.

The root directory of the graph data is specified using the "/graph" path. By default, the program looks for a "DAG" file in this directory, and if one is not found, it prints an error message.

The program uses the "collectPaths" function to gather all the possible paths to the root directory and all its subdirectories, and stores this in a map called "cmdSet". This is done in a way that allows the program to organize the commands into a tree-like structure, with each command being represented as a node in the tree.

The program then provides a loop through all the commands in the list and performs the necessary operations for each one. It also provides a way to test whether a given command-line path is valid by checking if the program finds the command-line arguments and the root directory.

Overall, the program is designed to be a simple and effective tool for managing DAG data structures in a graph database.


```go
func TestROCommands(t *testing.T) {
	list := []string{
		"/block",
		"/block/get",
		"/block/stat",
		"/cat",
		"/commands",
		"/commands/completion",
		"/commands/completion/bash",
		"/commands/completion/fish",
		"/commands/completion/zsh",
		"/dag",
		"/dag/get",
		"/dag/resolve",
		"/dag/stat",
		"/dag/export",
		"/dns",
		"/get",
		"/ls",
		"/name",
		"/name/resolve",
		"/object",
		"/object/data",
		"/object/get",
		"/object/links",
		"/object/stat",
		"/refs",
		"/resolve",
		"/version",
	}

	cmdSet := make(map[string]struct{})
	collectPaths("", RootRO, cmdSet)

	for _, path := range list {
		if _, ok := cmdSet[path]; !ok {
			t.Errorf("%q not in result", path)
		} else {
			delete(cmdSet, path)
		}
	}

	for path := range cmdSet {
		t.Errorf("%q in result but shouldn't be", path)
	}

	for _, path := range list {
		path = path[1:] // remove leading slash
		split := strings.Split(path, "/")
		sub, err := RootRO.Get(split)
		if err != nil {
			t.Errorf("error getting subcommand %q: %v", path, err)
		} else if sub == nil {
			t.Errorf("subcommand %q is nil even though there was no error", path)
		}
	}
}

```

This is a Go program that contains a命令-line interface for managing Swarm, a Go framework for managing and controlling large-scale, distributed systems. The program provides a set of commands for managing Swarm nodes, connecting and disconnecting them, and viewing information about the Swarm, such as the state of the nodes and the filters that are applied to them.

The program uses a configuration file to specify the location of the Swarm and the commands to use. The configuration file is specified using the "stats" command, which takes a file path as an argument. If the file cannot be found, the program will print an error and exit.

The program also provides a "test" command that connects to a remote Swarm and prints information about it. This command requires the "swarm" command to be specified as a dependency, and is intended for use in testing the program rather than in a production environment.

Overall, the program provides a simple and flexible way to manage Swarm nodes and their configurations.


```go
func TestCommands(t *testing.T) {
	list := []string{
		"/add",
		"/bitswap",
		"/bitswap/ledger",
		"/bitswap/reprovide",
		"/bitswap/stat",
		"/bitswap/wantlist",
		"/block",
		"/block/get",
		"/block/put",
		"/block/rm",
		"/block/stat",
		"/bootstrap",
		"/bootstrap/add",
		"/bootstrap/add/default",
		"/bootstrap/list",
		"/bootstrap/rm",
		"/bootstrap/rm/all",
		"/cat",
		"/cid",
		"/cid/base32",
		"/cid/bases",
		"/cid/codecs",
		"/cid/format",
		"/cid/hashes",
		"/commands",
		"/commands/completion",
		"/commands/completion/bash",
		"/commands/completion/fish",
		"/commands/completion/zsh",
		"/config",
		"/config/edit",
		"/config/profile",
		"/config/profile/apply",
		"/config/replace",
		"/config/show",
		"/dag",
		"/dag/export",
		"/dag/get",
		"/dag/import",
		"/dag/put",
		"/dag/resolve",
		"/dag/stat",
		"/dht",
		"/dht/findpeer",
		"/dht/findprovs",
		"/dht/get",
		"/dht/provide",
		"/dht/put",
		"/dht/query",
		"/routing",
		"/routing/put",
		"/routing/get",
		"/routing/findpeer",
		"/routing/findprovs",
		"/routing/provide",
		"/diag",
		"/diag/cmds",
		"/diag/cmds/clear",
		"/diag/cmds/set-time",
		"/diag/profile",
		"/diag/sys",
		"/dns",
		"/file",
		"/file/ls",
		"/files",
		"/files/chcid",
		"/files/cp",
		"/files/flush",
		"/files/ls",
		"/files/mkdir",
		"/files/mv",
		"/files/read",
		"/files/rm",
		"/files/stat",
		"/files/write",
		"/filestore",
		"/filestore/dups",
		"/filestore/ls",
		"/filestore/verify",
		"/get",
		"/id",
		"/key",
		"/key/export",
		"/key/gen",
		"/key/import",
		"/key/list",
		"/key/rename",
		"/key/rm",
		"/key/rotate",
		"/log",
		"/log/level",
		"/log/ls",
		"/log/tail",
		"/ls",
		"/mount",
		"/multibase",
		"/multibase/decode",
		"/multibase/encode",
		"/multibase/transcode",
		"/multibase/list",
		"/name",
		"/name/inspect",
		"/name/publish",
		"/name/pubsub",
		"/name/pubsub/cancel",
		"/name/pubsub/state",
		"/name/pubsub/subs",
		"/name/resolve",
		"/object",
		"/object/data",
		"/object/diff",
		"/object/get",
		"/object/links",
		"/object/new",
		"/object/patch",
		"/object/patch/add-link",
		"/object/patch/append-data",
		"/object/patch/rm-link",
		"/object/patch/set-data",
		"/object/put",
		"/object/stat",
		"/p2p",
		"/p2p/close",
		"/p2p/forward",
		"/p2p/listen",
		"/p2p/ls",
		"/p2p/stream",
		"/p2p/stream/close",
		"/p2p/stream/ls",
		"/pin",
		"/pin/add",
		"/pin/ls",
		"/pin/remote",
		"/pin/remote/add",
		"/pin/remote/ls",
		"/pin/remote/rm",
		"/pin/remote/service",
		"/pin/remote/service/add",
		"/pin/remote/service/ls",
		"/pin/remote/service/rm",
		"/pin/rm",
		"/pin/update",
		"/pin/verify",
		"/ping",
		"/pubsub",
		"/pubsub/ls",
		"/pubsub/peers",
		"/pubsub/pub",
		"/pubsub/sub",
		"/refs",
		"/refs/local",
		"/repo",
		"/repo/fsck",
		"/repo/gc",
		"/repo/migrate",
		"/repo/stat",
		"/repo/verify",
		"/repo/version",
		"/repo/ls",
		"/resolve",
		"/shutdown",
		"/stats",
		"/stats/bitswap",
		"/stats/bw",
		"/stats/dht",
		"/stats/provide",
		"/stats/repo",
		"/swarm",
		"/swarm/addrs",
		"/swarm/addrs/listen",
		"/swarm/addrs/local",
		"/swarm/connect",
		"/swarm/disconnect",
		"/swarm/filters",
		"/swarm/filters/add",
		"/swarm/filters/rm",
		"/swarm/peers",
		"/swarm/peering",
		"/swarm/peering/add",
		"/swarm/peering/ls",
		"/swarm/peering/rm",
		"/swarm/resources",
		"/tar",
		"/tar/add",
		"/tar/cat",
		"/update",
		"/urlstore",
		"/urlstore/add",
		"/version",
		"/version/deps",
	}

	cmdSet := make(map[string]struct{})
	collectPaths("", Root, cmdSet)

	for _, path := range list {
		if _, ok := cmdSet[path]; !ok {
			t.Errorf("%q not in result", path)
		} else {
			delete(cmdSet, path)
		}
	}

	for path := range cmdSet {
		t.Errorf("%q in result but shouldn't be", path)
	}

	for _, path := range list {
		path = path[1:] // remove leading slash
		split := strings.Split(path, "/")
		sub, err := Root.Get(split)
		if err != nil {
			t.Errorf("error getting subcommand %q: %v", path, err)
		} else if sub == nil {
			t.Errorf("subcommand %q is nil even though there was no error", path)
		}
	}
}

```