# v2ray-core源码解析 6

# `app/log/config.pb.go`

这段代码是一个Go语言编写的字段截断工具，它通过Protoc编译器生成。该工具的作用是将一个名为"log.proto"的JSON配置文件中的内容（字节数组）拆分成多个名为"log"的包，并输出每个包的接口定义。以下是生成的每个包的接口定义：


package log

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
	"time"
)

type LogEntry struct {
	Time time.Time
	Level log.Level
	message string
}

type Config struct {
	Level log.Level
	JSON string `json:"json"`
}

type Logger struct {
	config *Config
	logger log.Logger
}

func NewLogger(config *Config) *Logger {
	return &Logger{
		config: config,
		logger: log.Logger{},
		loader: log.ConfigLoader(func(r *log.Logger) *log.Config {
			return &log.Config{
				Prefix:         "",
				AddF calling for timestamp: func(s string) string {
					return s
				},
				Level:         config.Level,
					Filters:     []log.Filter,
					Terminated: true,
					DisableKeepalive: true,
					Write(output => log.Log(output, "", log.L弯曲)...) },
			},
		},
	}
}

func (l *Logger) log(level log.Level, message string, args ...interface{}) {
	var vars = []interface{}{}
	if l.config.JSON != "" {
		var jsonValue, err := ioutil.ReadAll(l.config.JSON)
		if err != nil {
			log.Fatalf("Failed to read JSON file: %v", err)
		}
		err = json.Unmarshal(jsonValue, &vars)
	}
	log.Enqueue(level, message, args...)
	l.logger.Log(level, message, args...)
}

func (l *Logger) logEmerg(level log.Level, message string, args ...interface{}) {
	log.Emerg(level, message, args...)
	l.logger.Alert(level, message, args...)
}

func (l *Logger) logFatal(level log.Level, message string, args ...interface{}) {
	log.Fatalf(level, message, args...)
	l.logger.Fatalf(level, message, args...)
}

func (l *Logger) logFields(level log.Level, message string, fields map[string]log.Field) {
	log.Fields(level, message, fields)
	l.logger.Fields(level, message, fields)
}

func (l *Logger) logV(level log.Level, message string, value interface{}, ...interface{}) {
	log.V(level, message, value, args...)
	l.logger.V(level, message, value, args...)
}

func (l *Logger) logDP(level log.Level, message string, value int64, args ...interface{}) {
	log.DP(level, message, value, args...)
	l.logger.DP(level, message, value, args...)
}

func (l *Logger) logU(level log.Level, message string, user interface{}, ...interface{}) {
	log.U(level, message, user, args...)
	l.logger.U(level, message, user, args...)
}

func (l *Logger) logExit(level log.Level, message string, args ...interface{}) {
	log.Exit(level, message, args...)
	l.logger.Exit(level, message, args...)
}


这段代码实现了以下功能：

1. 读取并解析一个名为"log.proto"的JSON配置文件；
2. 定义了一个名为"Logger"的


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: app/log/config.proto

package log

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	log "v2ray.com/core/common/log"
)

```

这段代码是一个Go语言中的const类型的变量，它包含两个判断，一个是_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)，另一个是_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)。

这两个判断的作用是确保客户端使用的Go语言版本与 protobuf 版本兼容的包是足够更新和兼容的。如果版本过低或者过高，都会抛出一个错误，并提示相应的错误信息。

同时，代码中定义了一个名为 LogType 的类型，它是一个从int32数据类型中定义的常量类型，定义了四个不同的 log 类型：LogType_None、LogType_Console、LogType_File 和 LogType_Event。

这里需要注意的是，该代码并没有输出具体的错误信息，它只是验证了Go语言版本与 protobuf 版本是否兼容，并确保客户端使用了一个足够更新和兼容的版本。


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type LogType int32

const (
	LogType_None    LogType = 0
	LogType_Console LogType = 1
	LogType_File    LogType = 2
	LogType_Event   LogType = 3
)

```

这段代码定义了一个枚举类型`LogType`及其对应的值映射。`LogType`的值为0到3，分别对应`None`、`Console`和`File`、`Event`。而`LogType_value`是一个 map 类型的映射，其中 key 是`int32`类型的字符串，value 是`int32`类型的整数。通过这个映射，`LogType_value`中的键是`LogType`的名称，而值则是`int32`类型对应的实际值。

比如，如果你使用`LogType`中的值为2(`File`)，那么`LogType_value`中的键将为`"File"`。这个枚举类型可以让你在代码中更方便地使用和定义不同类型的日志，以及根据日志类型输出或加载日志。


```go
// Enum value maps for LogType.
var (
	LogType_name = map[int32]string{
		0: "None",
		1: "Console",
		2: "File",
		3: "Event",
	}
	LogType_value = map[string]int32{
		"None":    0,
		"Console": 1,
		"File":    2,
		"Event":   3,
	}
)

```

这段代码定义了一个名为`FileAppLogConfig`的`LogType`接口。它实现了三个函数：`Enum`，`String`和`Descriptor`。

1. `Enum`函数接收一个`x`参数，并返回一个`LogType`类型的`p`变量。这个函数的作用是将`x`转换为`LogType`并返回。

2. `String`函数接收一个`LogType`类型的`x`参数，并返回一个字符串类型的`p`。这个函数的作用是将`x`转换为字符串类型的`FileAppLogConfig`类型的实例。

3. `Descriptor`函数接收一个`LogType`类型的`x`参数，并返回一个`FileAppLogConfig`类型元素的`Descriptor`。这个函数的作用是获取`x`的`Descriptor`。

4. `Type`函数接收一个`LogType`类型的`x`参数，并返回一个`protoreflect.EnumType`类型的`p`。这个函数的作用是将`x`转换为`protoreflect.EnumType`类型的实例。

`FileAppLogConfig`是一个来自`file_app_log_config_pb.proto`的`LogType`接口。它提供了将`FileAppLogConfig`类型的数据与协议名称映射的函数。


```go
func (x LogType) Enum() *LogType {
	p := new(LogType)
	*p = x
	return p
}

func (x LogType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogType) Descriptor() protoreflect.EnumDescriptor {
	return file_app_log_config_proto_enumTypes[0].Descriptor()
}

func (LogType) Type() protoreflect.EnumType {
	return &file_app_log_config_proto_enumTypes[0]
}

```

这段代码定义了一个名为 "func" 的函数，它接收一个名为 "x" 的参数，并返回一个名为 "Number" 的接口类型。这个函数使用了 "protoreflect" 包中的 "EnumNumber" 函数，用于将 "x" 参数转换为一个 "Number" 类型的枚举值。

另外，这段代码定义了一个名为 "EnumDescriptor" 的函数，它接收一个名为 "LogType" 的参数，并返回两个字节切片，第一个切片是 "LogType" 类型的描述信息，第二个切片是包含 "ErrorLogType" 和 "ErrorLogLevel" 字段名称的整数切片。这个函数使用了 "file_app_log_config_proto_rawDescGZIP" 函数，用于从文件中读取 "file_app_log_config_proto.proto" 文件的内容，并将读取到的内容解析为 "LogType" 和 "ErrorLogType" 字段。


```go
func (x LogType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogType.Descriptor instead.
func (LogType) EnumDescriptor() ([]byte, []int) {
	return file_app_log_config_proto_rawDescGZIP(), []int{0}
}

type Config struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ErrorLogType  LogType      `protobuf:"varint,1,opt,name=error_log_type,json=errorLogType,proto3,enum=v2ray.core.app.log.LogType" json:"error_log_type,omitempty"`
	ErrorLogLevel log.Severity `protobuf:"varint,2,opt,name=error_log_level,json=errorLogLevel,proto3,enum=v2ray.core.common.log.Severity" json:"error_log_level,omitempty"`
	ErrorLogPath  string       `protobuf:"bytes,3,opt,name=error_log_path,json=errorLogPath,proto3" json:"error_log_path,omitempty"`
	AccessLogType LogType      `protobuf:"varint,4,opt,name=access_log_type,json=accessLogType,proto3,enum=v2ray.core.app.log.LogType" json:"access_log_type,omitempty"`
	AccessLogPath string       `protobuf:"bytes,5,opt,name=access_log_path,json=accessLogPath,proto3" json:"access_log_path,omitempty"`
}

```

这段代码定义了两个函数，以及一个名为Config的接口。下面逐步解释每个函数的作用：

1. `func (x *Config) Reset()` 函数的作用是重置 `Config` 对象 `x`，将其设置为一个新的 `Config` 对象。

2. `func (x *Config) String()` 函数的作用是将 `Config` 对象 `x` 转换为字符串形式。

3. `func (x *Config) ProtoMessage()` 函数的作用是返回一个 `ProtoMessage` 对象，该对象将 `Config` 对象 `x` 转换为字节切片并传递给 `MessageStringOf` 函数。

请注意，`*Config` 表示一个指向 `Config` 类型对象的指针。在函数内部，我们通过 `*x` 获取该指针，并将其设置为一个新的 `Config` 对象。然后，我们检查 `protoimpl.UnsafeEnabled` 是否为真，如果是，我们将在内存中保存 `x` 的 `MessageInfo` 值，这个值存储在内存中的 `file_app_log_config_proto_msgTypes[0]` 类型对象中。最后，我们使用 `protoimpl.X.MessageStringOf` 函数将 `x` 对象转换为字符串，并将其存储在内存中的 `file_app_log_config_proto_msgTypes[0]` 类型对象中。


```go
func (x *Config) Reset() {
	*x = Config{}
	if protoimpl.UnsafeEnabled {
		mi := &file_app_log_config_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

```

这段代码定义了两个函数，分别是func和 Descriptor。

func函数接收一个Config类型的参数x，并返回一个protoreflect.Message类型的结果。函数的作用是在不使用轮询的情况下，根据传入的配置对象x，输出对应的protoreflect.Message类型。具体实现包括以下步骤：

1. 获取文件_app_log_config_proto_msgTypes数组中的第一个元素，并将其赋值给mi变量。

2. 如果传入的x对象不为空，执行以下操作：

	1. 获取x对象的指针变量，并将其赋值给ms变量。

	2. 如果ms对象的LoadMessageInfo()方法返回的是nil，则执行以下操作：

		1. 将mi对象的MessageInfo设置为从x对象中获取的MessageInfo。

		2. 返回ms对象的MessageOf(x)方法返回的结果。

	3. 如果ms对象的LoadMessageInfo()方法返回的并非nil，则直接返回ms对象的MessageOf(x)方法返回的结果。

	4. 如果以上步骤成功执行完，返回mi对象的MessageOf(x)方法返回的结果。

Descriptors函数接收一个Config类型的参数x，并返回包含配置对象的描述符的字节切片和两个整数，第一个整数表示描述符类型，第二个整数表示相应描述符类型的字节数。函数的作用是在不使用轮询的情况下，根据传入的配置对象x，输出对应的描述符类型和相应描述符类型的字节数。具体实现包括以下步骤：

1. 返回file_app_log_config_proto_rawDescGZIP和[]int{0}，表示文件_app_log_config_proto_rawDescGZIP字节切片包含一个完整的文件_app_log_config_proto_描述符，[]int表示相应描述符类型的字节数也为0。


```go
func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_app_log_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_app_log_config_proto_rawDescGZIP(), []int{0}
}

```

这段代码定义了三个函数，分别接收一个`Config`类型的参数`x`，并返回相应的错误日志类型、级别和路径。

第一个函数`func (x *Config) GetErrorLogType() LogType`接收一个`Config`类型的参数`x`，并判断`x`是否为`nil`。如果是`nil`，则返回`LogType_None`，否则返回`x.ErrorLogType`。这里的`*Config`表示`x`是一个`Config`类型的指针，可能代表一个配置文件或者一个配置参数。

第二个函数`func (x *Config) GetErrorLogLevel() log.Severity`与第一个函数类似，接收一个`Config`类型的参数`x`，并判断`x`是否为`nil`。如果是`nil`，则返回`log.Severity_Unknown`，否则返回`x.ErrorLogLevel`。这里的`*Config`同样表示`x`是一个`Config`类型的指针，可能代表一个配置文件或者一个配置参数。

第三个函数`func (x *Config) GetErrorLogPath() string`接收一个`Config`类型的参数`x`，并判断`x`是否为`nil`。如果是`nil`，则返回一个空字符串` ""`。否则，返回`x.ErrorLogPath`。这里的`*Config`表示`x`是一个`Config`类型的指针，可能代表一个配置文件或者一个配置参数，而`ErrorLogPath`是配置文件中一个用于写入错误日志的路径。


```go
func (x *Config) GetErrorLogType() LogType {
	if x != nil {
		return x.ErrorLogType
	}
	return LogType_None
}

func (x *Config) GetErrorLogLevel() log.Severity {
	if x != nil {
		return x.ErrorLogLevel
	}
	return log.Severity_Unknown
}

func (x *Config) GetErrorLogPath() string {
	if x != nil {
		return x.ErrorLogPath
	}
	return ""
}

```

这段代码定义了两个函数，分别是 `func (x *Config) GetAccessLogType() LogType` 和 `func (x *Config) GetAccessLogPath() string`，这两个函数接收一个名为 `x` 的 `Config` 类型的参数。

第一个函数 `GetAccessLogType()` 接收一个 `*Config` 类型的参数，判断 `x` 是否为 `nil`，如果是，则返回 `LogType_None`，否则返回 `x.AccessLogType`。这里的 `LogType_None` 是一个预定义的 `LogType` 类型，表示没有记录的日誌，通常用於测试和空日志。

第二个函数 `GetAccessLogPath()` 同样接收一个 `*Config` 类型的参数，判断 `x` 是否为 `nil`，如果是，则返回一个空字符串，否则返回 `x.AccessLogPath`。这里的 `"/"` 表示一个空字符串，表示没有记录的日誌，通常也用于测试。

最后，定义了一个名为 `File_app_log_config_proto` 的函数，接收一个 `protoreflect.FileDescriptor` 类型的参数，这个函数的作用可能是获取 `File_app_log_config_proto.ProtocolConfig` 的实例化值。但是，由于没有给出 `File_app_log_config_proto` 的定义，所以无法确定这个函数的具体实现。


```go
func (x *Config) GetAccessLogType() LogType {
	if x != nil {
		return x.AccessLogType
	}
	return LogType_None
}

func (x *Config) GetAccessLogPath() string {
	if x != nil {
		return x.AccessLogPath
	}
	return ""
}

var File_app_log_config_proto protoreflect.FileDescriptor

```

0x10, 0x03, 0x42, 0x47, 0x0a, 0x16, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79,
	0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x61, 0x70, 0x70, 0x2e, 0x6c, 0x6f, 0x67, 0x50, 0x01, 0x5a,
	0x16, 0x76, 0x32, 0x72, 0x6f, 0x74, 0x6f, 0x33,


```go
var file_app_log_config_proto_rawDesc = []byte{
	0x0a, 0x14, 0x61, 0x70, 0x70, 0x2f, 0x6c, 0x6f, 0x67, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f,
	0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x6c, 0x6f, 0x67, 0x1a, 0x14, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2f, 0x6c, 0x6f, 0x67, 0x2f, 0x6c, 0x6f, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x22, 0xa7, 0x02, 0x0a, 0x06, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x41, 0x0a, 0x0e, 0x65,
	0x72, 0x72, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x67, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65,
	0x2e, 0x61, 0x70, 0x70, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x4c, 0x6f, 0x67, 0x54, 0x79, 0x70, 0x65,
	0x52, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4c, 0x6f, 0x67, 0x54, 0x79, 0x70, 0x65, 0x12, 0x47,
	0x0a, 0x0f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x67, 0x5f, 0x6c, 0x65, 0x76, 0x65,
	0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e,
	0x63, 0x6f, 0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x6c, 0x6f, 0x67, 0x2e,
	0x53, 0x65, 0x76, 0x65, 0x72, 0x69, 0x74, 0x79, 0x52, 0x0d, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4c,
	0x6f, 0x67, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x24, 0x0a, 0x0e, 0x65, 0x72, 0x72, 0x6f, 0x72,
	0x5f, 0x6c, 0x6f, 0x67, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4c, 0x6f, 0x67, 0x50, 0x61, 0x74, 0x68, 0x12, 0x43, 0x0a,
	0x0f, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x6c, 0x6f, 0x67, 0x5f, 0x74, 0x79, 0x70, 0x65,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63,
	0x6f, 0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x4c, 0x6f, 0x67, 0x54,
	0x79, 0x70, 0x65, 0x52, 0x0d, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x26, 0x0a, 0x0f, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x6c, 0x6f, 0x67,
	0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x61, 0x63, 0x63,
	0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x50, 0x61, 0x74, 0x68, 0x2a, 0x35, 0x0a, 0x07, 0x4c, 0x6f,
	0x67, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x6f, 0x6e, 0x65, 0x10, 0x00, 0x12,
	0x0b, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04,
	0x46, 0x69, 0x6c, 0x65, 0x10, 0x02, 0x12, 0x09, 0x0a, 0x05, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x10,
	0x03, 0x42, 0x47, 0x0a, 0x16, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63,
	0x6f, 0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x6c, 0x6f, 0x67, 0x50, 0x01, 0x5a, 0x16, 0x76,
	0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x61, 0x70,
	0x70, 0x2f, 0x6c, 0x6f, 0x67, 0xaa, 0x02, 0x12, 0x56, 0x32, 0x52, 0x61, 0x79, 0x2e, 0x43, 0x6f,
	0x72, 0x65, 0x2e, 0x41, 0x70, 0x70, 0x2e, 0x4c, 0x6f, 0x67, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x33,
}

```

此代码定义了一个名为file_app_log_config_proto_rawDescOnce的变量，其类型为sync.Once，用于保证代码中对file_app_log_config_proto_rawDescOnce的多次调用只有一次被真正执行。

同时，代码中定义了一个名为file_app_log_config_proto_rawDescData的变量，其类型为[]byte，用于存储file_app_log_config_proto_rawDesc类型中的数据。

接着，代码中实现了一个名为file_app_log_config_proto_rawDescGZIP的函数，该函数将file_app_log_config_proto_rawDescData使用gzip压缩后返回。

然后，代码中定义了一个名为file_app_log_config_proto_enumTypes的变量，其类型为[]protoimpl.EnumInfo，用于存储file_app_log_config_proto_enum类型的信息。

接着，代码中定义了一个名为file_app_log_config_proto_msgTypes的变量，其类型为[]protoimpl.MessageInfo，用于存储file_app_log_config_proto_msg类型的信息。

最后，代码中定义了一个名为file_app_log_config_proto_goTypes的变量，其类型为[]interface{}，用于存储file_app_log_config_proto_go类型的信息。go类型的类型与protobuf中定义的类型一致，可以根据需要使用go代码进行解码等操作。


```go
var (
	file_app_log_config_proto_rawDescOnce sync.Once
	file_app_log_config_proto_rawDescData = file_app_log_config_proto_rawDesc
)

func file_app_log_config_proto_rawDescGZIP() []byte {
	file_app_log_config_proto_rawDescOnce.Do(func() {
		file_app_log_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_app_log_config_proto_rawDescData)
	})
	return file_app_log_config_proto_rawDescData
}

var file_app_log_config_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_app_log_config_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_app_log_config_proto_goTypes = []interface{}{
	(LogType)(0),      // 0: v2ray.core.app.log.LogType
	(*Config)(nil),    // 1: v2ray.core.app.log.Config
	(log.Severity)(0), // 2: v2ray.core.common.log.Severity
}
```

This is a Protobuf message that defines the initial configuration of a file application log.

The message has a field named `file_app_log_config` that is a sub-list for the field `field_type_name` with a length of 3.

The initial implementation of this function is able to handle the case where the `File_app_log_config_proto` library is not built with the `-create_runner` option, and therefore the `unused_style` option is enabled. This means that the initial configuration will not be used and the default implementation will be used.

The initial configuration creates an instance of the `x` struct, which does not implement any validation or checking.


```go
var file_app_log_config_proto_depIdxs = []int32{
	0, // 0: v2ray.core.app.log.Config.error_log_type:type_name -> v2ray.core.app.log.LogType
	2, // 1: v2ray.core.app.log.Config.error_log_level:type_name -> v2ray.core.common.log.Severity
	0, // 2: v2ray.core.app.log.Config.access_log_type:type_name -> v2ray.core.app.log.LogType
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_app_log_config_proto_init() }
func file_app_log_config_proto_init() {
	if File_app_log_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_app_log_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_app_log_config_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_app_log_config_proto_goTypes,
		DependencyIndexes: file_app_log_config_proto_depIdxs,
		EnumInfos:         file_app_log_config_proto_enumTypes,
		MessageInfos:      file_app_log_config_proto_msgTypes,
	}.Build()
	File_app_log_config_proto = out.File
	file_app_log_config_proto_rawDesc = nil
	file_app_log_config_proto_goTypes = nil
	file_app_log_config_proto_depIdxs = nil
}

```

# `app/log/errors.generated.go`

这段代码定义了一个名为 "log" 的包，其中包含了一个名为 "errPathObjHolder" 的类型，以及一个名为 "newError" 的函数。

函数 "newError" 接收一个或多个参数 "values"，并将它们连接成一个对象 "errPathObjHolder"。然后，使用这个对象创建一个带有错误消息和错误对象的 "errors.Error" 类型的新错误。最后，使用 "WithPathObj" 方法将错误对象的路径和对象联系起来，以便在调试时更方便地查看错误信息。

通过使用这个函数，我们可以创建一个错误对象，其中包含一个或多个参数以及一个指向错误路径对象的引用。这个函数可以用于在应用程序中捕获和处理错误，以便我们可以在出现错误时进行更详细的调试和记录。


```go
package log

import "v2ray.com/core/common/errors"

type errPathObjHolder struct{}

func newError(values ...interface{}) *errors.Error {
	return errors.New(values...).WithPathObj(errPathObjHolder{})
}

```

# `app/log/log.go`

这段代码是一个 Go 语言编写的依赖库中的一个函数，其主要作用是生成一个名为 "v2ray.com/core/common/errors/errorgen" 的只读文件，以提供 Go 运行时库中一个名为 "context" 的包的测试。

在 Go 语言中，Go 运行时库中的 "context" 包提供了异步上下文（Context）的功能。上下文可以帮助开发者更好地管理异步操作，以及确保在异步操作失败时进行错误处理。

这段代码的作用是，通过创建一个名为 "errorgen" 的只读文件，将 Go 运行时库中 "context" 包的定义和使用进行打包，并将其写入到生成的只读文件中。这个生成的只读文件可以在同一目录下使用 "go run" 命令进行运行，并在运行时使用 "context" 包。


```go
// +build !confonly

package log

//go:generate go run v2ray.com/core/common/errors/errorgen

import (
	"context"
	"sync"

	"v2ray.com/core/common"
	"v2ray.com/core/common/log"
)

// Instance is a log.Handler that handles logs.
```

该代码定义了一个名为 Instance 的日志实例结构体，其中包含一个 sync.RWMutex 类型的变量 config，一个 accessLogger log.Handler 类型的变量 errorLogger，一个 bool 类型的变量 active，以及一个作为 log.Handler 类型的函数 startInternal。

New 函数接受一个 context.Context 类型的参数，以及一个 Config 类型的参数。函数创建一个 Instance 实例，并将其 config 变量初始化为传入的 config，将 active 变量设置为 false，表示不会启动 Instance 的日志记录功能。然后，函数注册一个 accessLogger 类型的函数到 Instance，将其与 startInternal 函数一起设置为 true，以便在启动日志记录功能时使用。

startInternal 函数是一个内部函数，该函数将在 Instance 启动时启动 Instance 的日志记录功能。函数首先检查是否有可用的日志记录函数，如果没有，就创建一个新的函数并返回其实例。然后，函数开始监听所有的日志记录函数，并在这些函数开始写入日志时使用它们的输出进行日志。

该代码的目的是创建一个简单的日志实例，以便在启动时记录日志，并在日志记录功能启动后继续记录日志。


```go
type Instance struct {
	sync.RWMutex
	config       *Config
	accessLogger log.Handler
	errorLogger  log.Handler
	active       bool
}

// New creates a new log.Instance based on the given config.
func New(ctx context.Context, config *Config) (*Instance, error) {
	g := &Instance{
		config: config,
		active: false,
	}
	log.RegisterHandler(g)

	// start logger instantly on inited
	// other modules would log during init
	if err := g.startInternal(); err != nil {
		return nil, err
	}

	newError("Logger started").AtDebug().WriteToLog()
	return g, nil
}

```

这两个函数的作用是初始化日志记录器。它们接受一个 `g` 引用，代表一个自定义的 `Instance` 类型的实例。

第一个函数 `initAccessLogger` 的实现方式如下：

1. 创建一个日志处理程序和一个错误处理程序。
2. 使用 `createHandler` 函数为 `g.config.AccessLogType` 和 `g.config.AccessLogPath` 配置正确的日志记录类型和日志文件路径。
3. 将步骤 1 中的日志处理程序和错误处理程序都设置为 `g.accessLogger`，并将 `g.errorLogger` 设置为 `g.accessLogger`。
4. 返回 `nil` 表示操作成功。

第二个函数 `initErrorLogger` 的实现方式如下：

1. 创建一个日志处理程序和一个错误处理程序。
2. 使用 `createHandler` 函数为 `g.config.ErrorLogType` 和 `g.config.ErrorLogPath` 配置正确的日志记录类型和日志文件路径。
3. 将步骤 1 中的日志处理程序设置为 `g.errorLogger`，并将 `g.initErrorLogger` 返回的错误处理程序设置为 `g.errorLogger`。
4. 返回 `nil` 表示操作成功。


```go
func (g *Instance) initAccessLogger() error {
	handler, err := createHandler(g.config.AccessLogType, HandlerCreatorOptions{
		Path: g.config.AccessLogPath,
	})
	if err != nil {
		return err
	}
	g.accessLogger = handler
	return nil
}

func (g *Instance) initErrorLogger() error {
	handler, err := createHandler(g.config.ErrorLogType, HandlerCreatorOptions{
		Path: g.config.ErrorLogPath,
	})
	if err != nil {
		return err
	}
	g.errorLogger = handler
	return nil
}

```

这段代码定义了一个名为`Instance`的类型，它实现了`common.HasType`接口。

在这个类型中，有一个名为`startInternal`的方法，它返回一个指向`Instance`类型对象的`interface`类型。

该代码的主要作用是初始化一个`Instance`类型的对象，如果已经初始化过，则直接返回。否则，会尝试初始化一个访问日志和错误日志的错误，如果初始化失败，则返回一个错误。


```go
// Type implements common.HasType.
func (*Instance) Type() interface{} {
	return (*Instance)(nil)
}

func (g *Instance) startInternal() error {
	g.Lock()
	defer g.Unlock()

	if g.active {
		return nil
	}

	g.active = true

	if err := g.initAccessLogger(); err != nil {
		return newError("failed to initialize access logger").Base(err).AtWarning()
	}
	if err := g.initErrorLogger(); err != nil {
		return newError("failed to initialize error logger").Base(err).AtWarning()
	}

	return nil
}

```

该代码实现了一个名为"Instance"的共享会话实例，它实现了"common.Runnable.Start()"和"log.Handler."接口。

具体来说，该实例的"Start()"函数在开始内部处理程序之前，尝试从实例外部获取数据。然后，它使用"g.startInternal()"方法来启动内部处理程序，并返回一个错误。

该实例的"Handle()"函数用于处理接收到的日志消息。在函数中，它使用"g.RLock()"方法获取对"g.active"的引用，以确保只有当会话处于活动状态时才会处理接收到的消息。然后，它根据接收到的消息类型使用不同的日志记录器来处理消息。如果消息是一个"*log.AccessMessage"，则它将调用"g.accessLogger.Handle()"方法来处理消息。如果消息是一个"*log.GeneralMessage"，则只有当会话的错误日志记录器不为空，并且消息的 severity <= 配置的错误日志记录器级别时，才会调用"g.errorLogger.Handle()"方法来处理消息。否则，它将忽略该消息。

因此，该代码的作用是实现了一个日志记录器，可以让用户记录日志信息，并根据日志级别的不同进行不同的处理。


```go
// Start implements common.Runnable.Start().
func (g *Instance) Start() error {
	return g.startInternal()
}

// Handle implements log.Handler.
func (g *Instance) Handle(msg log.Message) {
	g.RLock()
	defer g.RUnlock()

	if !g.active {
		return
	}

	switch msg := msg.(type) {
	case *log.AccessMessage:
		if g.accessLogger != nil {
			g.accessLogger.Handle(msg)
		}
	case *log.GeneralMessage:
		if g.errorLogger != nil && msg.Severity <= g.config.ErrorLogLevel {
			g.errorLogger.Handle(msg)
		}
	default:
		// Swallow
	}
}

```

这段代码是一个 Pylint 灯炮（column发烧）工具，它实现了 common.Closable.Close() 方法的 Pylint 注释。该函数的作用是关闭一个名为 g 的实例的访问日志和错误日志。

具体来说，这段代码会执行以下操作：

1. 在屏幕上创建一个新的错误输出。
2. 获取 g 实例的锁，并确保在函数退出时释放它。
3. 如果 g 实例当前是激活状态，则将其设置为 False，并关闭对应的访问日志和错误日志。
4. 使用 common.Close() 方法关闭 g 的访问日志。
5. 使用 common.Close() 方法关闭 g 的错误日志。
6. 使用 common.Close() 方法关闭 g 的错误日志。
7. 返回 nil，表示操作成功。


```go
// Close implements common.Closable.Close().
func (g *Instance) Close() error {
	newError("Logger closing").AtDebug().WriteToLog()

	g.Lock()
	defer g.Unlock()

	if !g.active {
		return nil
	}

	g.active = false

	common.Close(g.accessLogger) // nolint: errcheck
	g.accessLogger = nil

	common.Close(g.errorLogger) // nolint: errcheck
	g.errorLogger = nil

	return nil
}

```

这段代码定义了一个名为 "init" 的函数，其作用是在函数调用时执行一些配置操作。

具体来说，它实现了以下几个步骤：

1. 从函数外部(即运行时)获取一个名为 "ctx" 的上下文对象和一个名为 "config" 的接口类型变量。

2. 通过 "common.Must" 函数，将上面获取到的上下文对象和配置接口类型变量存储在名为 "config" 的变量中，并返回一个名为 "ctx" 的上下文对象和一个名为 "new" 的函数指针。

3. 通过上下文对象 "ctx" 和配置接口类型变量 "config"，调用一个名为 "New" 的函数，并返回一个新的函数指针和一个错误类型变量 "err"。

4. 将步骤 2 中返回的上下文对象 "ctx" 和配置接口类型变量 "config" 作为参数传递给 "New" 函数，并返回该函数的返回值。

这段代码的主要目的是在函数调用时执行一些配置操作，例如注册配置信息、初始化上下文等。


```go
func init() {
	common.Must(common.RegisterConfig((*Config)(nil), func(ctx context.Context, config interface{}) (interface{}, error) {
		return New(ctx, config.(*Config))
	}))
}

```

# `app/log/log_creator.go`

这段代码定义了一个名为“log”的包，其中包含了一些与日志处理相关的函数和变量。下面是对这段代码的详细解释：

1. `//` 和 `!` 关键字：这两个关键字表示这是一个自定义的包，不需要使用包推导。

2. `package log`：定义了一个名为“log”的包，将其导入到当前项目中。

3. `import (`：从标准库中导入了一些与日志处理相关的包，包括 `log` 和 `common` 包。

4. `type HandlerCreatorOptions struct {`：定义了一个名为 `HandlerCreatorOptions` 的结构体，它包含了一个 `Path` 字段。

5. `type HandlerCreator func(LogType, HandlerCreatorOptions) (log.Handler, error)`：定义了一个名为 `HandlerCreator` 的函数类型，它接受两个参数：一个日志类型 `LogType` 和一个 `HandlerCreatorOptions` 实例。这个函数返回一个 `log.Handler` 类型的实例，一个错误 `error` 类型的实例。

6. `package code ...`：如果是输出源代码，那么这一行将输出完整的 `package` 语句，包括 `import` 和 `type` 语句。


```go
// +build !confonly

package log

import (
	"v2ray.com/core/common"
	"v2ray.com/core/common/log"
)

type HandlerCreatorOptions struct {
	Path string
}

type HandlerCreator func(LogType, HandlerCreatorOptions) (log.Handler, error)

```

这段代码定义了一个名为 `HandlerCreatorMap` 的 map，它用于存储不同的日志类型对应的手动创建器。

它还定义了一个名为 `RegisterHandlerCreator` 的函数，它接受两个参数：一个日志类型 `logType` 和一个手动创建器 `f`。这个函数的目的是将 `f` 注册到 `HandlerCreatorMap` 中，如果 `f` 是空的，函数会返回一个错误。

此外，还定义了一个名为 `createHandler` 的函数，它接受两个参数：一个日志类型 `logType` 和一个手动创建器 `options`。这个函数的目的是根据 `HandlerCreatorMap` 中存储的规则，自动创建一个日志处理程序，并返回它。如果 `HandlerCreatorMap` 中找不到 `logType` 对应的规则，函数会返回一个错误。


```go
var (
	handlerCreatorMap = make(map[LogType]HandlerCreator)
)

func RegisterHandlerCreator(logType LogType, f HandlerCreator) error {
	if f == nil {
		return newError("nil HandlerCreator")
	}

	handlerCreatorMap[logType] = f
	return nil
}

func createHandler(logType LogType, options HandlerCreatorOptions) (log.Handler, error) {
	creator, found := handlerCreatorMap[logType]
	if !found {
		return nil, newError("unable to create log handler for ", logType)
	}
	return creator(logType, options)
}

```

这段代码定义了一个名为 "init" 的函数，该函数用于初始化日志处理器的注册。

函数中调用了三个名为 "RegisterHandlerCreator" 的函数，这些函数分别用于注册日志类型为 "Console"、"File" 和 "None" 的处理器创建者。这些函数接收两个参数，一个是日志类型参数 "lt"，另一个是选项参数 "options" 和 "HandlerCreatorOptions" 分别表示日志类型设置和处理器创建者选项。

在每个 "RegisterHandlerCreator" 函数中，首先定义了一个内部函数 "Must( RegisterHandlerCreator(LogType_Console, func(lt LogType, options HandlerCreatorOptions) (log.Handler, error) { ... })"，该函数使用 "RegisterHandlerCreator" 函数作为它的 "func(lt LogType, options HandlerCreatorOptions) (log.Handler, error)" 部分，并传入一个匿名函数表达式。这个匿名函数表达式实际上是一个接受两个参数的函数，一个是日志类型参数 "lt"，另一个是选项参数 "options" 对应的 "HandlerCreatorOptions" 对象。

"Must( RegisterHandlerCreator(LogType_File, func(lt LogType, options HandlerCreatorOptions) (log.Handler, error) { ... }) )" 中的 "func(lt LogType, options HandlerCreatorOptions) (log.Handler, error)" 部分返回一个 "log.Handler" 和一个 "error" 类型的 "返回值"，分别表示注册成功和失败。

最后一个 "RegisterHandlerCreator" 函数中，有一个 empty 的函数表达式，没有进行任何操作，因此不会返回任何值。


```go
func init() {
	common.Must(RegisterHandlerCreator(LogType_Console, func(lt LogType, options HandlerCreatorOptions) (log.Handler, error) {
		return log.NewLogger(log.CreateStdoutLogWriter()), nil
	}))

	common.Must(RegisterHandlerCreator(LogType_File, func(lt LogType, options HandlerCreatorOptions) (log.Handler, error) {
		creator, err := log.CreateFileLogWriter(options.Path)
		if err != nil {
			return nil, err
		}
		return log.NewLogger(creator), nil
	}))

	common.Must(RegisterHandlerCreator(LogType_None, func(lt LogType, options HandlerCreatorOptions) (log.Handler, error) {
		return nil, nil
	}))
}

```

# `app/log/log_test.go`

package log\_test

import (
\"context\"
\"testing\"

\"github.com/golang/mock/gomock\"
\"v2ray.com/core/app/log\"
\"v2ray.com/core/common\"
\"log.transfer"
)

func TestCustomLogHandler(t *testing.T) {


```go
package log_test

import (
	"context"
	"testing"

	"github.com/golang/mock/gomock"
	"v2ray.com/core/app/log"
	"v2ray.com/core/common"
	clog "v2ray.com/core/common/log"
	"v2ray.com/core/testing/mocks"
)

func TestCustomLogHandler(t *testing.T) {
	mockCtl := gomock.NewController(t)
	defer mockCtl.Finish()

	var loggedValue []string

	mockHandler := mocks.NewLogHandler(mockCtl)
	mockHandler.EXPECT().Handle(gomock.Any()).AnyTimes().DoAndReturn(func(msg clog.Message) {
		loggedValue = append(loggedValue, msg.String())
	})

	log.RegisterHandlerCreator(log.LogType_Console, func(lt log.LogType, options log.HandlerCreatorOptions) (clog.Handler, error) {
		return mockHandler, nil
	})

	logger, err := log.New(context.Background(), &log.Config{
		ErrorLogLevel: clog.Severity_Debug,
		ErrorLogType:  log.LogType_Console,
		AccessLogType: log.LogType_None,
	})
	common.Must(err)

	common.Must(logger.Start())

	clog.Record(&clog.GeneralMessage{
		Severity: clog.Severity_Debug,
		Content:  "test",
	})

	if len(loggedValue) < 2 {
		t.Fatal("expected 2 log messages, but actually ", loggedValue)
	}

	if loggedValue[1] != "[Debug] test" {
		t.Fatal("expected '[Debug] test', but actually ", loggedValue[1])
	}

	common.Must(logger.Close())
}

```

# `app/log/command/command.go`

这段代码是一个 Go 语言编写的命令行工具，用于构建 Go 语言项目。它使用了以下目标：

+ 首先，使用 `build` 命令构建 Go 语言项目，这将生成一个名为 `.build/default.zip` 的压缩文件。

- 然后，使用 `!confonly` 标志指示该工具仅在项目配置文件中设置，以避免不必要的冲突和文件更改。

- 最后，导出 `v2ray.com/core/common/errors/errorgen`，以便与其他库或项目进行依赖管理。

在导出 `errorgen` 时，使用了 `go:generate` 指令，这是一个 Go 语言功能，用于生成其他语言的依赖文件。

另外，该命令行工具还使用了 `grpc` 库，它是一个高性能的 Go-to-Python 库，可以用于创建与后端服务的交互式网络连接。


```go
// +build !confonly

package command

//go:generate go run v2ray.com/core/common/errors/errorgen

import (
	"context"

	grpc "google.golang.org/grpc"

	"v2ray.com/core"
	"v2ray.com/core/app/log"
	"v2ray.com/core/common"
)

```

这段代码定义了一个名为 "LoggerServer" 的 struct 类型，它包含一个指向 "core.Instance" 类型对象的 "V" 字段。

该 struct 的 "RestartLogger" 函数实现了一个 "LoggerService.RestartLogger" 接口，接收一个 "RestartLoggerRequest" 类型的参数。

具体来说，该函数首先获取 "LoggerServer" 实例中的一个 "log.Instance" 类型的字段，如果该字段为 nil，那么返回一个 "nil" 类型的空 "RestartLoggerResponse"，否则关闭该实例并返回一个 "Error" 类型的错误。

接着，如果关闭和启动实例的过程出现错误，那么返回一个 "Error" 类型的错误。最终，该函数返回一个 "RestartLoggerResponse" 类型的实例，该实例包含一个空 "RestartLoggerResponse" 字段，表示成功重启了logger。


```go
type LoggerServer struct {
	V *core.Instance
}

// RestartLogger implements LoggerService.
func (s *LoggerServer) RestartLogger(ctx context.Context, request *RestartLoggerRequest) (*RestartLoggerResponse, error) {
	logger := s.V.GetFeature((*log.Instance)(nil))
	if logger == nil {
		return nil, newError("unable to get logger instance")
	}
	if err := logger.Close(); err != nil {
		return nil, newError("failed to close logger").Base(err)
	}
	if err := logger.Start(); err != nil {
		return nil, newError("failed to start logger").Base(err)
	}
	return &RestartLoggerResponse{}, nil
}

```

这段代码定义了一个名为LoggerServer的远程服务，它实现了core.LoggerServiceServer接口。这个服务提供了一个register方法，接受一个Grpc.Server参数，用于将LoggerServiceServer注册到服务器上。

具体来说，register方法接收一个Server对象和一个LoggerServiceServer实例作为参数，创建一个LoggerServer实例，并将它设置为注册服务器上的服务。register方法的实现使用了 common.Must 函数，确保了它是一个安全的统一资源管理器。

此外，还定义了一个名为service的 struct，它包含一个名为register的注册方法。该方法将LoggerServiceServer注册到服务器上，并使用该服务器实例创建一个LoggerServer实例。

最后，在代码的底部，定义了一个名为init的函数，该函数初始化Logger服务器的注册配置。通过使用 common.MustFromContext 和 register 函数，可以确保Logger服务器不会在运行时创建或销毁。


```go
func (s *LoggerServer) mustEmbedUnimplementedLoggerServiceServer() {}

type service struct {
	v *core.Instance
}

func (s *service) Register(server *grpc.Server) {
	RegisterLoggerServiceServer(server, &LoggerServer{
		V: s.v,
	})
}

func init() {
	common.Must(common.RegisterConfig((*Config)(nil), func(ctx context.Context, cfg interface{}) (interface{}, error) {
		s := core.MustFromContext(ctx)
		return &service{v: s}, nil
	}))
}

```

# `app/log/command/command_test.go`

这段代码是一个命令测试（Command Testing）包，它包含了用于测试命令功能的一些函数和变量。

具体来说，这个包的作用是用于测试命令的输入和输出。它通过定义了一些函数和变量，实现了对命令的一些操作，包括：

1. 在命令测试包中定义了一些常量，例如：`CMD_FILE`，用于表示命令测试程序要执行的文件名；
2. 定义了一个`Context`类型，用于表示命令执行上下文，包括命令前的参数列表、已执行的命令等；
3. 定义了一个`dispatcher.Dispatch`函数，用于模拟命令执行上下文中的命令调度，即根据输入参数的优先级和类型，选择合适的命令来执行；
4. 定义了一个`log.Logger`函数，用于记录命令的输出信息，可以将输出信息记录到一个名为`test.log`的文件中；
5. 定义了一个`command.Command`结构体，用于表示一个命令，它包括命令名称、命令参数等信息；
6. 定义了一个`inbound.Inbound`和`outbound.Outbound`类型，分别表示入站和出站的流量代理，它们用于管理命令的入站和出站路径；
7. 通过` common.Serial`包中的`Serializer`类型，将命令的输出信息序列化为字符串，以便记录到日志文件中。

总之，这段代码定义了一些函数和变量，用于实现命令测试程序的功能，从而方便开发人员对命令的行为进行测试和调试。


```go
package command_test

import (
	"context"
	"testing"

	"v2ray.com/core"
	"v2ray.com/core/app/dispatcher"
	"v2ray.com/core/app/log"
	. "v2ray.com/core/app/log/command"
	"v2ray.com/core/app/proxyman"
	_ "v2ray.com/core/app/proxyman/inbound"
	_ "v2ray.com/core/app/proxyman/outbound"
	"v2ray.com/core/common"
	"v2ray.com/core/common/serial"
)

```

该代码段是一个名为 "TestLoggerRestart" 的函数，属于 "core.testing" 包。其作用是测试一个名为 "LoggerServer" 的类的 "RestartLogger" 函数。

具体来说，该函数的作用是创建一个 "LoggerServer" 实例，并使用 "v" 变量中的 "Start" 方法启动它。然后，使用 "v" 实例中的 "New" 方法创建一个新的 "core.Config" 实例，该实例包含一个包含日志配置、指令代理配置和入站代理配置的 "serial.TypedMessage" 数组。

接下来，使用 " common.Must" 函数确保 "v" 实例中的 "Start" 和 "New" 方法成功，然后使用 "common.Must2" 函数创建一个 "LoggerServer" 实例，并将其 "V" 字段分配给一个名为 "server" 的变量。最后，使用 "server.RestartLogger" 函数启动 "LoggerServer" 实例，并传递一个名为 "RestartLoggerRequest" 的 "context.Background" 参数，以便在函数内部启动 "LoggerServer" 实例。


```go
func TestLoggerRestart(t *testing.T) {
	v, err := core.New(&core.Config{
		App: []*serial.TypedMessage{
			serial.ToTypedMessage(&log.Config{}),
			serial.ToTypedMessage(&dispatcher.Config{}),
			serial.ToTypedMessage(&proxyman.InboundConfig{}),
			serial.ToTypedMessage(&proxyman.OutboundConfig{}),
		},
	})
	common.Must(err)
	common.Must(v.Start())

	server := &LoggerServer{
		V: v,
	}
	common.Must2(server.RestartLogger(context.Background(), &RestartLoggerRequest{}))
}

```

# `app/log/command/config.pb.go`

该代码是一个 Go 语言编程语言中的接口定义，用于定义命令行应用程序的配置文件输出格式。

它使用了 Google.golang.org/protobuf/proto 和对应的开源协议(app/log/command/config.proto)中定义的接口类型。

该代码中定义了一个名为 "command" 的包，并在其中定义了一个名为 "config" 的接口类型。通过在 "config.proto" 文件中定义该接口类型，可以使得不同的应用程序可以以相同的方式读取和写入配置文件中的配置信息。

该代码还定义了一个名为 "Command" 的接口类型，用于定义命令行的命令名称和参数。通过在 "command.proto" 文件中定义该接口类型，可以使得不同的应用程序可以以相同的方式读取和写入命令行应用程序的配置文件中的配置信息。


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: app/log/command/config.proto

package command

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

```

这段代码是一个编译时检查，以确保它所生成的代码足够古老，同时它使用的 runtime 和 protoimpl 包的版本足够古老。它还检查了是否正在使用足够古老版本的 legacy proto 包。

具体来说，代码中定义了一个名为 Config 的结构体类型，其中包含一个名为 state 的成员，它是一个 protobuf 中的 message 类型的状态，这个结构体用于定义了在协议中声明的消息类型的实例化的一些选项。还包括一个名为 sizeCache 的成员，它是一个 protobuf 中的 field 类型的缓存，用于记录已经缓存的 field 的缓存大小。最后包括一个名为 unknownFields 的成员，它是一个 protobuf 中的 field 类型的数组，用于定义了协议中声明的消息类型的未知字段。

通过调用 protoimpl.EnforceVersion(20 - protoimpl.MinVersion) 和 protoimpl.EnforceVersion(protoimpl.MaxVersion - 20) 可以确保生成的代码足够古老，并且使用的 runtime 和 protoimpl 包的版本足够古老。同时，通过调用 proto.ProtoPackageIsVersion4 可以检查当前生成的代码是否使用了足够古老版本的 legacy proto 包。最后，通过在结构体中声明的 state 成员，可以启用或禁用 age 选项。


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Config struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

```

这段代码定义了两个函数，分别名为`Reset`和`String`，它们都是`Config`类型的方法。

1. `Reset`函数的作用是重置`Config`类型的变量`x`，将其设置为`Config{}`，即一个空的`Config`类型实例。函数的实现中，首先将`x`指向的内存单元的值设置为`Config{}`，然后检查`protoimpl.UnsafeEnabled`是否为真，如果是，则执行以下操作：

a. 获取`file_app_log_command_config_proto_msgTypes`数组中第一个元素的指针`mi`；
b. 获取`x`指向的内存单元的`MessageInfo`字段，并将其存储为`mi`指向的内存单元的值；
c. 如果`protoimpl.UnsafeEnabled`为真，则不需要执行后续操作，直接返回。

2. `String`函数的作用是将`Config`类型的变量`x`转换为字符串，并返回`string`类型的值。函数的实现中，直接返回`protoimpl.X.MessageStringOf(x)`，其中`protoimpl.X`是来自`file_app_log_command_config_proto.go`文件的类型名称，它定义了`Config`类型。


```go
func (x *Config) Reset() {
	*x = Config{}
	if protoimpl.UnsafeEnabled {
		mi := &file_app_log_command_config_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

```

这段代码定义了两个函数，分别接收一个`Config`类型的参数`x`，并返回其`Descriptor`字段类型。

函数`func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_app_log_command_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}`接收一个`Config`类型的参数`x`，并返回一个`protoreflect.Message`类型的变量`mi`。

函数`func (x *Config) Descriptor() ([]byte, []int)`接收一个`Config`类型的参数`x`，并返回其`Descriptor`字段类型。函数实现了一个简化的`Descriptor`函数，没有对`Descriptor`类型进行任何验证或记录。

函数`file_app_log_command_config_proto_rawDescGZIP()`是一个被忽略的函数，可能是因为在依赖旧版本的`file_app_log_command_config_proto`时仍然使用了`Descriptor`字段类型。


```go
func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_app_log_command_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_app_log_command_config_proto_rawDescGZIP(), []int{0}
}

```

这段代码定义了一个名为 "RestartLoggerRequest" 的结构体，它包含三个字段：state、sizeCache 和 unknownFields。其中，state 字段是一个 protoimpl.MessageState 类型的字段，用于表示该结构体所代表的含义；sizeCache 字段是一个 protoimpl.SizeCache 类型的字段，用于存储一个缓存大小，该缓存大小会在结构体被使用时根据实际需求动态调整；unknownFields 字段是一个 protoimpl.UnknownFields 类型的字段，用于存储在使用该结构体时可能不知道的未知数据类型。

另外，该结构体还包含一个名为 "Reset" 的方法，该方法的作用是重置该结构体的 state 字段，将其设置为 "resetState" 常量的默认值。由于该方法使用了 protoimpl.UnsafeEnabled 标志，因此只有当该函数在安全不被破坏的情况下才可以执行，以避免可能的不可预测行为。


```go
type RestartLoggerRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *RestartLoggerRequest) Reset() {
	*x = RestartLoggerRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_app_log_command_config_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

```

这段代码定义了一个名为`RestartLoggerRequest`的`RestartLoggerRequest`类型的函数指针。

该函数指针的类型参数为`*RestartLoggerRequest`，意味着它可以接受一个指向`RestartLoggerRequest`类型的参数。

该函数指针的`String()`函数返回一个`string`类型的值，该值由`protoimpl.X.MessageStringOf(x)`函数计算得到，其中`x`参数为指向`RestartLoggerRequest`类型的实参。

该函数指针的`ProtoMessage()`函数返回一个`[]byte`类型的值，该值由`protoimpl.X.MessageStringOf(x)`函数计算得到，其中`x`参数为指向`RestartLoggerRequest`类型的实参。

该函数指针的`ProtoReflect()`函数返回一个`protoreflect.Message`类型的值，该值由`file_app_log_command_config_proto_msgTypes[1]`类型定义得到。如果`x`参数为`nil`，则返回一个`Message`类型的空指针，否则返回一个`Message`类型的值，该值由`RestartLoggerRequest`类型的实参转换得到。


```go
func (x *RestartLoggerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RestartLoggerRequest) ProtoMessage() {}

func (x *RestartLoggerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_app_log_command_config_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

```

此代码定义了一个名为 "RestartLoggerRequest" 的类型，该类型有一个名为 "Descriptor" 的方法，该方法返回一个包含 "file_app_log_command_config_proto_rawDescGZIP" 字段值和 "1" 字段值的切片，用于描述 "file_app_log_command_config_proto_rawDescGZIP" 类型。

此外，此代码定义了一个名为 "RestartLoggerResponse" 的类型，该类型有一个名为 "Reset" 的方法，该方法重置 "RestartLoggerResponse" 的状态，并设置其 "unknownFields" 字段。

最后，此代码使用 "file_app_log_command_config_proto_rawDescGZIP" 函数描述了 "file_app_log_command_config_proto_rawDescGZIP" 类型，并将其作为 "file_app_log_command_config_proto_rawDescGZIP" 字段的值，返回给 "Descriptor" 方法使用。


```go
// Deprecated: Use RestartLoggerRequest.ProtoReflect.Descriptor instead.
func (*RestartLoggerRequest) Descriptor() ([]byte, []int) {
	return file_app_log_command_config_proto_rawDescGZIP(), []int{1}
}

type RestartLoggerResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *RestartLoggerResponse) Reset() {
	*x = RestartLoggerResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_app_log_command_config_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

```

这段代码定义了一个名为"RestartLoggerResponse"的函数接收者类型和两个名为"RestartLoggerResponse"的函数指针类型。

首先，函数接收者类型"RestartLoggerResponse"代表了一个接受"RestartLoggerResponse"类型的函数的返回值。该函数接收一个"RestartLoggerResponse"类型的参数"x"，并返回一个"RestartLoggerResponse"类型的字符串。

其次，函数指针类型"RestartLoggerResponse"代表了一个接收"RestartLoggerResponse"类型数据的函数的指针类型。

最后，函数"RestartLoggerResponse"接收一个"RestartLoggerResponse"类型的参数"x"，并返回一个指向"file_app_log_command_config_proto_msgTypes[2]"类型对象的指针。如果"RestartLoggerResponse"指针"x"不为空，则返回该指针所指向的"file_app_log_command_config_proto_msgTypes[2]"类型对象的"Message"字段。


```go
func (x *RestartLoggerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RestartLoggerResponse) ProtoMessage() {}

func (x *RestartLoggerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_app_log_command_config_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

```

I'm sorry, I'm not sure what you are asking for. Could you please provide more context or clarify your question?



```go
// Deprecated: Use RestartLoggerResponse.ProtoReflect.Descriptor instead.
func (*RestartLoggerResponse) Descriptor() ([]byte, []int) {
	return file_app_log_command_config_proto_rawDescGZIP(), []int{2}
}

var File_app_log_command_config_proto protoreflect.FileDescriptor

var file_app_log_command_config_proto_rawDesc = []byte{
	0x0a, 0x1c, 0x61, 0x70, 0x70, 0x2f, 0x6c, 0x6f, 0x67, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
	0x64, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x1a,
	0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x6c,
	0x6f, 0x67, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x22, 0x08, 0x0a, 0x06, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x22, 0x16, 0x0a, 0x14, 0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x4c,
	0x6f, 0x67, 0x67, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x17, 0x0a, 0x15,
	0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x4c, 0x6f, 0x67, 0x67, 0x65, 0x72, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x32, 0x87, 0x01, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x67, 0x65, 0x72,
	0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x76, 0x0a, 0x0d, 0x52, 0x65, 0x73, 0x74, 0x61,
	0x72, 0x74, 0x4c, 0x6f, 0x67, 0x67, 0x65, 0x72, 0x12, 0x30, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79,
	0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x4c, 0x6f, 0x67,
	0x67, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x31, 0x2e, 0x76, 0x32, 0x72,
	0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x6c, 0x6f, 0x67, 0x2e,
	0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x4c,
	0x6f, 0x67, 0x67, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42,
	0x5f, 0x0a, 0x1e, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72,
	0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x6c, 0x6f, 0x67, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
	0x64, 0x50, 0x01, 0x5a, 0x1e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63,
	0x6f, 0x72, 0x65, 0x2f, 0x61, 0x70, 0x70, 0x2f, 0x6c, 0x6f, 0x67, 0x2f, 0x63, 0x6f, 0x6d, 0x6d,
	0x61, 0x6e, 0x64, 0xaa, 0x02, 0x1a, 0x56, 0x32, 0x52, 0x61, 0x79, 0x2e, 0x43, 0x6f, 0x72, 0x65,
	0x2e, 0x41, 0x70, 0x70, 0x2e, 0x4c, 0x6f, 0x67, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64,
	0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

```

此代码定义了一个名为file_app_log_command_config_proto_rawDescOnce的变量，其类型为sync.Once，用于保证全局仅有一个实例。

该变量内部包含一个名为file_app_log_command_config_proto_rawDescData的变量，其类型为protoimpl.X.CompressGZIP，用于将长字段值压缩为字节数组。

该函数file_app_log_command_config_proto_rawDescGZIP()返回file_app_log_command_config_proto_rawDescData字节数组，其中使用了protoimpl.X.CompressGZIP函数将file_app_log_command_config_proto_rawDescData压缩为字节数组。


```go
var (
	file_app_log_command_config_proto_rawDescOnce sync.Once
	file_app_log_command_config_proto_rawDescData = file_app_log_command_config_proto_rawDesc
)

func file_app_log_command_config_proto_rawDescGZIP() []byte {
	file_app_log_command_config_proto_rawDescOnce.Do(func() {
		file_app_log_command_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_app_log_command_config_proto_rawDescData)
	})
	return file_app_log_command_config_proto_rawDescData
}

var file_app_log_command_config_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_app_log_command_config_proto_goTypes = []interface{}{
	(*Config)(nil),                // 0: v2ray.core.app.log.command.Config
	(*RestartLoggerRequest)(nil),  // 1: v2ray.core.app.log.command.RestartLoggerRequest
	(*RestartLoggerResponse)(nil), // 2: v2ray.core.app.log.command.RestartLoggerResponse
}
```

This is a Go-style protobuf definition that defines the `file_app_log_command_config_proto` message type.

The `file_app_log_command_config_proto` message type has the following fields:

- `i` is an integer field that represents the index of the field within the message.
- `v` is a pointer to a `RestartLoggerRequest` struct.
- `Exporter` is a field that represents the exporter for the `RestartLoggerResponse` field within the message.

The `file_app_log_command_config_proto` struct is used to visually represent the data in the `file_app_log_command_config_proto` message, for example, in a Go query.

The `file_app_log_command_config_proto_goTypes` field is a list of the `go types` that can be used to充实 the `file_app_log_command_config_proto` struct.

The `file_app_log_command_config_proto_file_app_log_command_config_proto_goTypes` field is a list of the `go types` that can be used to充实 the `file_app_log_command_config_proto_file_app_log_command_config_goTypes` field.

The `file_app_log_command_config_proto_file_app_log_command_config_goTypes` field is a list of the `go types` that can be used to充实 the `file_app_log_command_config_proto_file_app_log_command_config_goTypes` field.


```go
var file_app_log_command_config_proto_depIdxs = []int32{
	1, // 0: v2ray.core.app.log.command.LoggerService.RestartLogger:input_type -> v2ray.core.app.log.command.RestartLoggerRequest
	2, // 1: v2ray.core.app.log.command.LoggerService.RestartLogger:output_type -> v2ray.core.app.log.command.RestartLoggerResponse
	1, // [1:2] is the sub-list for method output_type
	0, // [0:1] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_app_log_command_config_proto_init() }
func file_app_log_command_config_proto_init() {
	if File_app_log_command_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_app_log_command_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_app_log_command_config_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RestartLoggerRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_app_log_command_config_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RestartLoggerResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_app_log_command_config_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_app_log_command_config_proto_goTypes,
		DependencyIndexes: file_app_log_command_config_proto_depIdxs,
		MessageInfos:      file_app_log_command_config_proto_msgTypes,
	}.Build()
	File_app_log_command_config_proto = out.File
	file_app_log_command_config_proto_rawDesc = nil
	file_app_log_command_config_proto_goTypes = nil
	file_app_log_command_config_proto_depIdxs = nil
}

```