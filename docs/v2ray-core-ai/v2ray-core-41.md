# v2ray-core源码解析 41

# `proxy/blackhole/config_test.go`

这段代码是黑洞测试中的一个测试函数，用于测试 HTTP 包是否正确地实现了 HTTP 请求和响应。

具体来说，这段代码实现了一个名为 `TestHTTPResponse` 的函数，它接收一个 HTTP 响应对象 `httpResponse`，将其写入一个缓冲区 `buffer`，并使用另一个名为 `bufio.NewReader` 的函数从缓冲区读取响应内容。然后，它将读取到的响应内容传递给一个名为 `http.ReadResponse` 的函数，该函数将读取缓冲区中的内容并返回一个响应对象 `response` 和一个错误 `err`。如果 `err` 为空，那么响应状态码应该为 403，否则会输出错误信息。

通过调用 `TestHTTPResponse`，可以对黑洞测试中的 HTTP 包进行测试，以验证它是否能够正确地处理 HTTP 请求和响应。


```go
package blackhole_test

import (
	"bufio"
	"net/http"
	"testing"

	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	. "v2ray.com/core/proxy/blackhole"
)

func TestHTTPResponse(t *testing.T) {
	buffer := buf.New()

	httpResponse := new(HTTPResponse)
	httpResponse.WriteTo(buf.NewWriter(buffer))

	reader := bufio.NewReader(buffer)
	response, err := http.ReadResponse(reader, nil)
	common.Must(err)
	if response.StatusCode != 403 {
		t.Error("expected status code 403, but got ", response.StatusCode)
	}
}

```

# `proxy/blackhole/errors.generated.go`

这段代码定义了一个名为 errPathObjHolder 的结构体，它包含一个空的 errors.Path Obj。

接着定义了一个名为 newError 的函数，该函数接收多个参数，可以是多个interface{}。函数内部使用 values... 来遍历输入参数，创建一个新的 errPathObjHolder 实例，并调用 errors.New 函数来创建一个抛出异常并包含 errPathObjHolder 的错误。最后使用 WithPathObj 方法将 errPathObjHolder 加入错误路径中。

这段代码的主要目的是创建一个自定义的错误处理机制，允许您在代码中捕获和处理错误。通过调用 newError 函数，您可以将自定义的错误处理逻辑与现有的错误处理机制（如 global.Errorf）结合使用，以更好地适应您的代码需求。


```go
package blackhole

import "v2ray.com/core/common/errors"

type errPathObjHolder struct{}

func newError(values ...interface{}) *errors.Error {
	return errors.New(values...).WithPathObj(errPathObjHolder{})
}

```

# `proxy/dns/config.pb.go`

这段代码定义了一个名为 "dns" 的包，其中定义了一些使用 Go 编写的 DNS 配置文件的前端代码。具体来说，它实现了以下功能：

1. 定义了 DNS 配置文件的后端接口协议 "proto.proto"。"proto.proto" 是 Google 出品的一个用于定义复杂数据结构的 Protocol Buffers 文件格式。在 "dns" 包中，它定义了一些基于这个协议的类型，包括 "address" 和 "net" 类型。

2. 实现了 protoc-gen-go v1.25.0 和 protoc 的支持，以便能够成功编译出 "dns.proto" 文件。这通过导入 "protoc-gen-go" 和 "protoc" 包以及设置 "GO_OMIT_GROWTH_为推动来的。

3. 通过导入 "reflect" 和 "net" 包，实现了 protobuf 中 "reflect" 和 "net" 类型的支持。这允许了开发人员使用这些内置类型来计算 Proto 定义的类型数量。

4. 实现了 "address" 和 "net" 类型的功能，允许用户配置 DNS 服务器和客户端的地址和子网掩码。具体来说，"address" 类型定义了 IP 地址和端口号，"net" 类型定义了 IP 地址空间、子网掩码和默认网关。

5. 通过 "protoreflect" 包，使用了 Google 的反射功能来实现对 "address" 和 "net" 类型的类型进行类型检查和转换。

6. 通过 "sync" 包，实现了对 "address" 类型进行并发操作的能力。

7. 通过 "v2ray.com/core/common/net" 包实现了与第三方库 v2ray.com 的集成。


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: proxy/dns/config.proto

package dns

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	net "v2ray.com/core/common/net"
)

```

这段代码定义了一个名为 Config 的结构体，用于表示服务器配置。它包含了服务器需要使用的信息，如服务器地址、DNS配置等。

首先，代码使用 const 关键字定义了两个变量，分别名为 _ 和 _。这两个变量然后执行了 protoimpl.EnforceVersion() 函数，传入两个参数，分别是 20 - protoimpl.MinVersion 和 protoimpl.MaxVersion - 20。这个函数的作用是检查当前的客户端是否使用了足够大的 proto 包，如果小于所需的最低版本，则会强制使用该版本。

接着，代码使用 const 关键字定义了一个名为 _ 的变量，用于表示当前使用的 proto 包版本。这个变量通过protoimpl.IsVersion4()函数获取，如果当前使用的包版本小于这个最低版本，则返回 false，否则返回 true。

然后，代码定义了一个名为 Config 的结构体，它包含了服务器的所有配置信息。这个结构体包含了三个字段：state、sizeCache 和 unknownFields。其中，state 字段表示了服务器当前的状态，sizeCache 字段缓存了服务器的 size，unknownFields 字段是一个隐藏的字段，用于存储协议定义中未定义的字段。

最后，代码使用 `protobuf` 标签定义了服务器配置的 JSON 类型。这个类型定义了服务器需要的所有字段，包括 server 字段，如果这个字段被指定了话，将覆盖原有的服务器地址。


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Config struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Server is the DNS server address. If specified, this address overrides the
	// original one.
	Server *net.Endpoint `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
}

```

这段代码定义了两个函数，以及一个名为Config的接口。这些函数主要作用于配置信息 struct 的实例 x，下面将分步解释每个函数的作用：

1. `func (x *Config) Reset()`：这是一个单例函数，用于在调用时创建一个新的配置信息实例，并将其存储在 x 变量中。其实现方式是清空 x 变量，并将 `Config{}` 赋值给 x。

2. `func (x *Config) String() string`：这也是一个单例函数，但只适用于 x 的值为 `*Config` 时。其实现方式是返回 x 的 `String` 类型，即将 x 的 `*Config` 类型转换为字符串。

3. `func (x *Config) ProtoMessage() *protoimpl.Message`：这个函数允许将 x 的 `*Config` 类型转换为 `*protoimpl.Message` 类型。通过实现这个函数，可以允许用户在需要时将 x 的 `*Config` 类型转换为 `*protoimpl.Message` 类型，以便在需要时与其他对象进行交互。

综上所述，这段代码定义了一个名为 Config 的接口，以及三个函数，分别用于创建、设置和转换 x 的 `*Config` 类型实例。通过这些函数，用户可以对 x 进行操作，以便在需要时与其他对象进行交互。


```go
func (x *Config) Reset() {
	*x = Config{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proxy_dns_config_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

```

这段代码定义了两个函数，分别接收一个指向Config类型对象的变量x，并返回相应的方法签名。

第一个函数：

* x *Config类型的对象
* returns:
* mi是文件代理协议中dns_config类型的消息类型，这个类型在代码中对应于file_proxy_dns_config_proto_msgTypes[0]。
* 如果使用了`protoimpl.UnsafeEnabled`，则返回指向x的ms类型，否则返回x的MessageOf类型。

第二个函数：

* x *Config类型的对象
* returns:
* the type of the config message in file_proxy_dns_config_proto

这个函数的作用是 deprecated，因为推荐使用Config.Descriptor函数来获取Config对象的描述信息。


```go
func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_proxy_dns_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_proxy_dns_config_proto_rawDescGZIP(), []int{0}
}

```

It appears that the output is a series of hexadecimal values. Each value is either a single byte or a double byte. The order in which the values are listed may not match the order in which they were generated.

It's important to note that the meaning of these hexadecimal values is difficult to determine without additional context.


```go
func (x *Config) GetServer() *net.Endpoint {
	if x != nil {
		return x.Server
	}
	return nil
}

var File_proxy_dns_config_proto protoreflect.FileDescriptor

var file_proxy_dns_config_proto_rawDesc = []byte{
	0x0a, 0x16, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2f, 0x64, 0x6e, 0x73, 0x2f, 0x63, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e,
	0x63, 0x6f, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x64, 0x6e, 0x73, 0x1a, 0x1c,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x6e, 0x65, 0x74, 0x2f, 0x64, 0x65, 0x73, 0x74, 0x69,
	0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x41, 0x0a, 0x06,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x37, 0x0a, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63,
	0x6f, 0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x6e, 0x65, 0x74, 0x2e, 0x45,
	0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x42,
	0x4d, 0x0a, 0x18, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x64, 0x6e, 0x73, 0x50, 0x01, 0x5a, 0x18, 0x76,
	0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x70, 0x72,
	0x6f, 0x78, 0x79, 0x2f, 0x64, 0x6e, 0x73, 0xaa, 0x02, 0x14, 0x56, 0x32, 0x52, 0x61, 0x79, 0x2e,
	0x43, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x44, 0x6e, 0x73, 0x62, 0x06,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

```

该代码定义了一个名为file_proxy_dns_config_proto_rawDescOnce的变量，其类型为sync.Once，用于保证只有一次初始化。同时，该变量还定义了一个名为file_proxy_dns_config_proto_rawDescData的变量，其类型为protoimpl.X.CompressGZIP(protoimpl.X.Config)，用于将文件_proxy_dns_config_proto_rawDescData进行GZIP压缩。

接着，代码定义了一个名为file_proxy_dns_config_proto_rawDescGZIP的函数，该函数使用file_proxy_dns_config_proto_rawDescOnce中的do函数，实现将file_proxy_dns_config_proto_rawDescData压缩为byte类型并返回，其中使用了protoimpl.X.CompressGZIP函数进行压缩。

最后，代码还定义了一个名为file_proxy_dns_config_proto_msgTypes的变量，其类型为protoimpl.MessageInfo，用于定义file_proxy_dns_config_proto_rawDescOnce和file_proxy_dns_config_proto_rawDescData的message类型，以及一个名为file_proxy_dns_config_proto_goTypes的变量，其类型为[]interface{}。


```go
var (
	file_proxy_dns_config_proto_rawDescOnce sync.Once
	file_proxy_dns_config_proto_rawDescData = file_proxy_dns_config_proto_rawDesc
)

func file_proxy_dns_config_proto_rawDescGZIP() []byte {
	file_proxy_dns_config_proto_rawDescOnce.Do(func() {
		file_proxy_dns_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_proxy_dns_config_proto_rawDescData)
	})
	return file_proxy_dns_config_proto_rawDescData
}

var file_proxy_dns_config_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_proxy_dns_config_proto_goTypes = []interface{}{
	(*Config)(nil),       // 0: v2ray.core.proxy.dns.Config
	(*net.Endpoint)(nil), // 1: v2ray.core.common.net.Endpoint
}
```

This is a protobuf file that defines the structure and fields of the file_proxy_dns_config_proto message. It is used to describe the configuration of a file proxy that uses DNS servers to resolve hostnames to IP addresses.

The file defines a sub-list for the field `field_type_name`, which is a list of field type names. The sub-list has a single element, which is an integer constant `0`:


0 


The file also defines the initializers for the `file_proxy_dns_config_proto` struct:


file_proxy_dns_config_proto_init() = iota


The `file_proxy_dns_config_proto_init` function is called when the file is first read or the `file_proxy_dns_config_proto` struct is first initialized:


func file_proxy_dns_config_proto_init() {
	if File_proxy_dns_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proxy_dns_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}


The `file_proxy_dns_config_proto_init` function reads the `file_proxy_dns_config_proto` file and generates the corresponding structs for the message types defined in the file. It also enables the unsafe code generation for the structs that have unsupported fields.

The initializers also assign the initial values for the struct fields:


type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proxy_dns_config_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proxy_dns_config_proto_goTypes,
		DependencyIndexes: file_proxy_dns_config_proto_depIdxs,
		MessageInfos:      file_proxy_dns_config_proto_msgTypes,
	}.Build()
	File_proxy_dns_config_proto = out.File
	file_proxy_dns_config_proto_rawDesc = nil
	file_proxy_dns_config_proto_goTypes = nil
	file_proxy_dns_config_proto_depIdxs = nil
}


The `file_proxy_dns_config_proto_init` function is called with the `i` field that is passed to the initializer. This field is an integer that represents the index of the struct field in the file.

The initializer reads the `file_proxy_dns_config_proto` file and generates the corresponding structs for the message types defined in the file. It also enables the unsafe code generation for the structs that have unsupported fields.


```go
var file_proxy_dns_config_proto_depIdxs = []int32{
	1, // 0: v2ray.core.proxy.dns.Config.server:type_name -> v2ray.core.common.net.Endpoint
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_proxy_dns_config_proto_init() }
func file_proxy_dns_config_proto_init() {
	if File_proxy_dns_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proxy_dns_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proxy_dns_config_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proxy_dns_config_proto_goTypes,
		DependencyIndexes: file_proxy_dns_config_proto_depIdxs,
		MessageInfos:      file_proxy_dns_config_proto_msgTypes,
	}.Build()
	File_proxy_dns_config_proto = out.File
	file_proxy_dns_config_proto_rawDesc = nil
	file_proxy_dns_config_proto_goTypes = nil
	file_proxy_dns_config_proto_depIdxs = nil
}

```

# `proxy/dns/dns.go`

这段代码是一个 Go 语言编写的 DNS 服务器构建脚本。它通过执行以下命令来构建、运行和清理 DNS 服务器：


go build
go run build.go


具体来说，代码中执行以下操作：

1. 构建（build）dns 服务器。
2. 运行时（run）build.go 脚本。
3. 清理（confonly）dns 服务器。

这段代码可能使用了以下依赖：

* Go 语言编译器（go build）
* DNS Message 编码器（golang.org/x/net/dns/dnsmessage）
* v2ray 库（v2ray.com/core）

此外，这段代码还使用了以下配置：

* `+build`：构建选项，开启构建过程。
* `!confonly`：运行选项，仅在服务器启动时执行。

这段代码的作用是构建并运行一个 DNS 服务器，允许用户通过 DNS 查询获取网络服务器的 IP 地址。


```go
// +build !confonly

package dns

import (
	"context"
	"io"
	"sync"

	"golang.org/x/net/dns/dnsmessage"

	"v2ray.com/core"
	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	"v2ray.com/core/common/net"
	dns_proto "v2ray.com/core/common/protocol/dns"
	"v2ray.com/core/common/session"
	"v2ray.com/core/common/task"
	"v2ray.com/core/features/dns"
	"v2ray.com/core/transport"
	"v2ray.com/core/transport/internet"
)

```

这段代码定义了一个名为“init”的函数，用于创建一个自定义的链接验证器函数。函数接受一个名为“ctx”的上下文对象，一个名为“config”的接口类型，以及一个名为“handler”的接口类型。函数返回一个名为“handler”的接口类型和一个名为“err”的错误类型。

函数的核心实现部分如下：


func init() {
	common.Must(common.RegisterConfig((*Config)(nil), func(ctx context.Context, config interface{}) (interface{}, error) {
		h := new(Handler)
		if err := core.RequireFeatures(ctx, func(dnsClient dns.Client) error {
			return h.Init(config.(*Config), dnsClient)
		}); err != nil {
			return nil, err
		}
		return h, nil
	}))
}


首先，函数定义了一个名为“init”的函数。这个函数使用了`common.Must`函数来注册一个名为“init”的函数，并将其返回值类型设为`func(ctx context.Context, config interface{}) (interface{}, error)`类型。这个函数接受两个参数，一个是`ctx`上下文对象，另一个是`config`的接口类型。函数内部执行以下操作：

1. 创建一个名为“handler”的接口类型和一个名为“err”的错误类型。
2. 如果调用`core.RequireFeatures`函数时出现错误，则执行以下操作：

	1. 创建一个名为“h”的实例，将其类型设为“Handler”。
	2. 如果调用`init`函数中的`core.RequireFeatures`函数成功，则执行以下操作：
	3. 调用`handler.Init`函数，并传递一个名为“config”的接口类型和一个名为“dnsClient”的匿名类型。
	4. 如果调用`handler.Init`函数时出现错误，则执行以下操作：
		1. 如果错误类型不是`nil`，则返回该错误类型。
		2. 否则，返回`nil`。
		3. 返回`h`和`nil`。


此外，还定义了一个名为“ownLinkVerifier”的接口类型，该接口类型包含一个名为“IsOwnLink”的方法，用于判断链接是否为自有链接。


```go
func init() {
	common.Must(common.RegisterConfig((*Config)(nil), func(ctx context.Context, config interface{}) (interface{}, error) {
		h := new(Handler)
		if err := core.RequireFeatures(ctx, func(dnsClient dns.Client) error {
			return h.Init(config.(*Config), dnsClient)
		}); err != nil {
			return nil, err
		}
		return h, nil
	}))
}

type ownLinkVerifier interface {
	IsOwnLink(ctx context.Context) bool
}

```

该代码定义了一个名为Handler的结构体，该结构体包含以下字段：

- ipv4Lookup：实现了dns.IPv4Lookup类型的接口，用于进行IPv4的DNS查询操作。
- ipv6Lookup：实现了dns.IPv6Lookup类型的接口，用于进行IPv6的DNS查询操作。
- ownLinkVerifier：实现了ownLinkVerifier类型的接口，用于验证链路是否可用。
- server：包含一个Net.Destination类型的字段，用于设置服务器的IP地址。

该Handler结构体表示了一个DNS服务器，它实现了dns.Client类型的接口，用于与DNS客户端进行交互。在Init函数中，首先检查DNS客户端是否实现了IPv4Lookup和IPv6Lookup类型的接口，如果未实现，则返回错误。然后，初始化IPv4和IPv6DNS查询器，以及验证链路是否可用。最后，根据服务器配置设置服务器的IP地址。


```go
type Handler struct {
	ipv4Lookup      dns.IPv4Lookup
	ipv6Lookup      dns.IPv6Lookup
	ownLinkVerifier ownLinkVerifier
	server          net.Destination
}

func (h *Handler) Init(config *Config, dnsClient dns.Client) error {
	ipv4lookup, ok := dnsClient.(dns.IPv4Lookup)
	if !ok {
		return newError("dns.Client doesn't implement IPv4Lookup")
	}
	h.ipv4Lookup = ipv4lookup

	ipv6lookup, ok := dnsClient.(dns.IPv6Lookup)
	if !ok {
		return newError("dns.Client doesn't implement IPv6Lookup")
	}
	h.ipv6Lookup = ipv6lookup

	if v, ok := dnsClient.(ownLinkVerifier); ok {
		h.ownLinkVerifier = v
	}

	if config.Server != nil {
		h.server = config.Server.AsDestination()
	}
	return nil
}

```

这两段代码定义了两个函数，分别是 `isOwnLink` 和 `parseIPQuery`。

1. `isOwnLink` 函数接收一个 `Handler` 类型的参数 `h`，并在其内部调用了一个名为 `IsOwnLink` 的函数，该函数接收一个 `ctx` 参数。函数返回值是一个布尔值，表示给定的 `Handler` 是否拥有对给定上下文 `ctx` 的 `OwnLink` 验证器。

2. `parseIPQuery` 函数接收一个字节切片 `b`，并返回三个值：一个布尔值 `r`、一个字符串 `domain` 和一个 `uint16` 类型的 `id`。函数首先使用一个名为 `parser` 的 `dnsmessage.Parser` 类型的变量，它从 `b` 开始解析数据。如果解析出现错误，函数将抛出错误并记录。然后，函数使用 `parser.Question` 函数获取一个问句，并获取其 `Type` 字段，用于确定问句类型。如果问句类型不是 `dnsmessage.TypeA` 或 `dnsmessage.TypeAAAA`，函数将返回 `true`。

函数 `parseIPQuery` 的输入参数 `b` 必须是有效的 IP 地址查询字符串，它包含两个必需字段 `id` 和 `qType`。函数 `parseIPQuery` 的作用是解析 IP 地址查询字符串，并将其转换为 `ID`、 `域名` 和 `问句类型`。


```go
func (h *Handler) isOwnLink(ctx context.Context) bool {
	return h.ownLinkVerifier != nil && h.ownLinkVerifier.IsOwnLink(ctx)
}

func parseIPQuery(b []byte) (r bool, domain string, id uint16, qType dnsmessage.Type) {
	var parser dnsmessage.Parser
	header, err := parser.Start(b)
	if err != nil {
		newError("parser start").Base(err).WriteToLog()
		return
	}

	id = header.ID
	q, err := parser.Question()
	if err != nil {
		newError("question").Base(err).WriteToLog()
		return
	}
	qType = q.Type
	if qType != dnsmessage.TypeA && qType != dnsmessage.TypeAAAA {
		return
	}

	domain = q.Name.String()
	r = true
	return
}

```

This is a Go program that implements the DNS (Domain Name System) protocol using the TCP (Transmission Control Protocol) or UDP (User Datagram Protocol) protocol. It provides a function for managing IP queries and responses.

The program creates a connection to a DNS server using the TCP protocol and listens for incoming connections. When a connection is established, it creates a reader and a writer for the connection, and when a message is received from the server, it reads and writes it.

The program defines a `request()` function that handles incoming requests from the server. It reads the message, checks if it's an IP query, and if it's an IP query, it passes it to the `handleIPQuery()` function. If it's not an IP query, it writes the message to the writer.

The program defines a `response()` function that handles outgoing messages from the server. It reads the message, writes it to the writer, and then reads the response from the server.

The program uses the `isOwnLink()` function to determine if the connection is own or leased. If it's not own, it writes a message to the owner.

The program implements the `h.isOwnLink()` function that returns whether the connection is own or leased. It sets the flag `isOwn` to `false` and writes `nil` to `ctx` to indicate an empty response. If the connection is own, it sets the flag `isOwn` to `true` and writes `"yes"` to `ctx` to indicate the owner. If the connection is leased, it sets the flag `isOwn` to `true` and writes `"no"` to `ctx` to indicate the leasigned owner.


```go
// Process implements proxy.Outbound.
func (h *Handler) Process(ctx context.Context, link *transport.Link, d internet.Dialer) error {
	outbound := session.OutboundFromContext(ctx)
	if outbound == nil || !outbound.Target.IsValid() {
		return newError("invalid outbound")
	}

	srcNetwork := outbound.Target.Network

	dest := outbound.Target
	if h.server.Network != net.Network_Unknown {
		dest.Network = h.server.Network
	}
	if h.server.Address != nil {
		dest.Address = h.server.Address
	}
	if h.server.Port != 0 {
		dest.Port = h.server.Port
	}

	newError("handling DNS traffic to ", dest).WriteToLog(session.ExportIDToError(ctx))

	conn := &outboundConn{
		dialer: func() (internet.Connection, error) {
			return d.Dial(ctx, dest)
		},
		connReady: make(chan struct{}, 1),
	}

	var reader dns_proto.MessageReader
	var writer dns_proto.MessageWriter
	if srcNetwork == net.Network_TCP {
		reader = dns_proto.NewTCPReader(link.Reader)
		writer = &dns_proto.TCPWriter{
			Writer: link.Writer,
		}
	} else {
		reader = &dns_proto.UDPReader{
			Reader: link.Reader,
		}
		writer = &dns_proto.UDPWriter{
			Writer: link.Writer,
		}
	}

	var connReader dns_proto.MessageReader
	var connWriter dns_proto.MessageWriter
	if dest.Network == net.Network_TCP {
		connReader = dns_proto.NewTCPReader(buf.NewReader(conn))
		connWriter = &dns_proto.TCPWriter{
			Writer: buf.NewWriter(conn),
		}
	} else {
		connReader = &dns_proto.UDPReader{
			Reader: buf.NewPacketReader(conn),
		}
		connWriter = &dns_proto.UDPWriter{
			Writer: buf.NewWriter(conn),
		}
	}

	request := func() error {
		defer conn.Close()

		for {
			b, err := reader.ReadMessage()
			if err == io.EOF {
				return nil
			}

			if err != nil {
				return err
			}

			if !h.isOwnLink(ctx) {
				isIPQuery, domain, id, qType := parseIPQuery(b.Bytes())
				if isIPQuery {
					go h.handleIPQuery(id, qType, domain, writer)
					continue
				}
			}

			if err := connWriter.WriteMessage(b); err != nil {
				return err
			}
		}
	}

	response := func() error {
		for {
			b, err := connReader.ReadMessage()
			if err == io.EOF {
				return nil
			}

			if err != nil {
				return err
			}

			if err := writer.WriteMessage(b); err != nil {
				return err
			}
		}
	}

	if err := task.Run(ctx, request, response); err != nil {
		return newError("connection ends").Base(err)
	}

	return nil
}

```

This is a function that formats an IPv4 address question or answer message and writes it to a log. It takes a struct that implements the `dnsmessage.Message` interface and an optional writer.

The function first creates a new `buf` buffer and an optional writer. It then extracts any raw bytes from the input buffer and creates a new `dnsmessage.Builder` instance with those raw bytes.

The builder is then used to construct a new message by calling the various methods and passing in the required parameters. This includes setting the question or answer's ID, class, type, and other fields.

The `RecursionDesired` field is set to `true` to enable recursion for DNS servers, and the `Authoritative` field is set to `true` to indicate that the answer is final.

The builder is then configured to compress the message using the `EnableCompression` method.

Next, the function calls the `StartQuestions` method to start the question or answer loop. This is followed by a call to `StartAnswers` to start the loop when it is finished.

Finally, the function extracts any questions from the builder and writes the answer to the specified writer. If any errors occur during the process, the function logs them and releases the `buf`.


```go
func (h *Handler) handleIPQuery(id uint16, qType dnsmessage.Type, domain string, writer dns_proto.MessageWriter) {
	var ips []net.IP
	var err error

	switch qType {
	case dnsmessage.TypeA:
		ips, err = h.ipv4Lookup.LookupIPv4(domain)
	case dnsmessage.TypeAAAA:
		ips, err = h.ipv6Lookup.LookupIPv6(domain)
	}

	rcode := dns.RCodeFromError(err)
	if rcode == 0 && len(ips) == 0 && err != dns.ErrEmptyResponse {
		newError("ip query").Base(err).WriteToLog()
		return
	}

	b := buf.New()
	rawBytes := b.Extend(buf.Size)
	builder := dnsmessage.NewBuilder(rawBytes[:0], dnsmessage.Header{
		ID:                 id,
		RCode:              dnsmessage.RCode(rcode),
		RecursionAvailable: true,
		RecursionDesired:   true,
		Response:           true,
		Authoritative:      true,
	})
	builder.EnableCompression()
	common.Must(builder.StartQuestions())
	common.Must(builder.Question(dnsmessage.Question{
		Name:  dnsmessage.MustNewName(domain),
		Class: dnsmessage.ClassINET,
		Type:  qType,
	}))
	common.Must(builder.StartAnswers())

	rHeader := dnsmessage.ResourceHeader{Name: dnsmessage.MustNewName(domain), Class: dnsmessage.ClassINET, TTL: 600}
	for _, ip := range ips {
		if len(ip) == net.IPv4len {
			var r dnsmessage.AResource
			copy(r.A[:], ip)
			common.Must(builder.AResource(rHeader, r))
		} else {
			var r dnsmessage.AAAAResource
			copy(r.AAAA[:], ip)
			common.Must(builder.AAAAResource(rHeader, r))
		}
	}
	msgBytes, err := builder.Finish()
	if err != nil {
		newError("pack message").Base(err).WriteToLog()
		b.Release()
		return
	}
	b.Resize(0, int32(len(msgBytes)))

	if err := writer.WriteMessage(b); err != nil {
		newError("write IP answer").Base(err).WriteToLog()
	}
}

```

该代码定义了一个名为 "outboundConn" 的类型，该类型包含一个名为 "access" 的 sync.Mutex 和一个名为 "dialer" 的函数，以及一个名为 "conn" 的net.Conn 变量和一个名为 "connReady" 的chan struct{}。

具体来说，"outboundConn" 类型表示一个可以进行网络连接的 "InternetConnection" 类型对象的实例。该类型的实例包含一个用于互斥锁 "access"（即原子操作），用于在连接建立后防止多个连接同时访问该连接；一个用于获取连接的 "dialer" 函数，该函数返回一个互联网连接对象和一个错误；一个名为 "conn" 的net.Conn 变量，用于存储当前的网络连接；以及一个名为 "connReady" 的chan struct{}，用于通知连接已准备好使用。

当 "dialer" 函数返回一个互联网连接对象时，"outboundConn.connReady" 事件将触发，通知 "outboundConn" 类型的实例已准备好使用该连接进行网络通信。而当 "dialer" 函数返回一个错误时，将 "err" 字段设置为该错误对象的值，并通知 "outboundConn.connReady" 事件。


```go
type outboundConn struct {
	access sync.Mutex
	dialer func() (internet.Connection, error)

	conn      net.Conn
	connReady chan struct{}
}

func (c *outboundConn) dial() error {
	conn, err := c.dialer()
	if err != nil {
		return err
	}
	c.conn = conn
	c.connReady <- struct{}{}
	return nil
}

```

这段代码定义了一个名为`func`的函数，接收一个名为`outboundConn`的指针变量作为参数，并返回两个整数类型的参数：一个表示成功写入数据的大小，另一个是错误。函数的具体实现如下：

1. 使用`c.access.Lock()`方法对传入的`outboundConn`进行加锁操作，以保证在函数内部对`outboundConn`的操作 mutual exclusion。

2. 如果`outboundConn`为空，尝试使用`c.dial()`方法进行拨号操作，并将错误信息记录为`newError`。如果`c.dial()`成功，则尝试解除加锁操作，否则继续错误处理。

3. 调用`c.conn.Write(b)`方法，并返回写入字节数组`b`的结果。

4. 释放加锁操作的资源，以便其他 gRPC 函数可以访问到`outboundConn`。


```go
func (c *outboundConn) Write(b []byte) (int, error) {
	c.access.Lock()

	if c.conn == nil {
		if err := c.dial(); err != nil {
			c.access.Unlock()
			newError("failed to dial outbound connection").Base(err).AtWarning().WriteToLog()
			return len(b), nil
		}
	}

	c.access.Unlock()

	return c.conn.Write(b)
}

```

该函数的作用是连接到远程服务器并读取数据。函数接收一个指向输出连接的指针变量c和一个字节数组b，并返回数据读取的接收次数和错误。

具体来说，函数首先创建一个名为conn的网络连接对象，然后使用该连接对象的访问器对象的Lock方法对连接进行加锁，以确保在函数内部对连接的操作是互斥的。

接下来，函数使用一个名为c的指针变量来存储当前连接对象，并解开之前对连接的加锁。然后使用conn.Read函数读取数据，并将其存储在变量b中。

如果conn在函数内部之前没有被创建，函数将会尝试使用conn.connReady函数尝试连接到远程服务器。如果该函数返回一个非零值，则说明连接成功，否则说明出现错误。如果conn在函数内部已经被创建，那么就直接使用conn.Read函数读取数据，不会再调用conn.connReady函数。

总的来说，该函数的作用是创建一个安全的网络连接并读取数据，适用于需要从一个远程服务器获取数据的应用程序。


```go
func (c *outboundConn) Read(b []byte) (int, error) {
	var conn net.Conn
	c.access.Lock()
	conn = c.conn
	c.access.Unlock()

	if conn == nil {
		_, open := <-c.connReady
		if !open {
			return 0, io.EOF
		}
		conn = c.conn
	}

	return conn.Read(b)
}

```

该函数名为`func (c *outboundConn) Close() error`，它接收一个指向`outboundConn`类型的参数`c`。

函数的作用是关闭`outboundConn`类型的对象`c`，并返回一个错误。具体实现包括以下步骤：

1. 使用`c.access.Lock()`方法对`c.connReady`缓冲区进行锁定，防止其他进程或线程访问该缓冲区。
2. 使用`close(c.connReady)`方法关闭`c.connReady`缓冲区。
3. 如果`c.conn`参数不是一个` nil`值，则执行以下操作：
  1. 使用`c.conn.Close()`方法关闭与`c.conn`的连接。
  2. 调用`c.access.Unlock()`方法释放对`c.connReady`的锁定。

函数的实现确保了`c`对象在退出函数时可以安全关闭与连接的交互，并且不会导致内存泄漏。


```go
func (c *outboundConn) Close() error {
	c.access.Lock()
	close(c.connReady)
	if c.conn != nil {
		c.conn.Close()
	}
	c.access.Unlock()
	return nil
}

```

# `proxy/dns/dns_test.go`

这段代码是一个 Go 语言编写的测试包，用于测试 DNS 代理的功能。主要包含以下功能：

1. 导入必要的库：
	* "strconv"：字符串解析库
	* "testing"：用于测试的库
	* "time"：用于测试的时间库
	* "github.com/google/go-cmp/cmp"：用于比较的库
	* "github.com/miekg/dns"：用于 DNS 解析的库
	* "v2ray.com/core"：DNS 代理库
	* "v2ray.com/core/app/dispatcher"：用于路由代理的库
	* "v2ray.com/core/app/policy"：用于策略路由的库
	* "v2ray.com/core/app/proxyman"：DNS 代理库的子库
	* "v2ray.com/core/app/proxyman/inbound"：用于入站的代理库
	* "v2ray.com/core/app/proxyman/outbound"：用于出站的代理库
	* "v2ray.com/core/app/common"：公共包
	* "v2ray.com/core/app/serial"：用于序列化的库
	* "v2ray.com/core/app/v2ray"：用于 V2Ray 代理的库
	* "v2ray.com/core/cli"：用于 CLI 工具的库
2. 定义测试函数：
	* "test_dns_proxy": 用于测试 DNS 代理代理功能
	* "test_dns": 用于测试 DNS 解析功能
	* "test_proxyman": 用于测试代理库功能
	* "test_proxyman_inbound": 用于测试入站代理代理功能
	* "test_proxyman_outbound": 用于测试出站代理代理功能
	* "test_policy": 用于测试策略路由功能
	* "test_dns_proxy_in": 用于测试入站代理代理功能
	* "test_dns_proxy_out": 用于测试出站代理代理功能
	* "test_dns_proxy_in_async": 用于测试异步入站代理代理功能
	* "test_dns_proxy_out_async": 用于测试异步出站代理代理功能
	* "test_policy_async": 用于测试异步策略路由功能
	* "test_dns_proxy_in_fp": 用于测试入站代理代理功能
	* "test_dns_proxy_out_fp": 用于测试出站代理代理功能
	* "test_policy_fp": 用于测试策略路由功能
	* "test_url": 用于测试 URL 解析功能
	* "test_host": 用于测试主机解析功能
	* "test_port": 用于测试端口解析功能
	* "test_tcp": 用于测试 TCP 代理代理功能
	* "test_udp": 用于测试 UDP 代理代理功能
	* "test_ policy": 用于测试策略路由功能
	* "test_dns_proxy": 用于测试 DNS 代理代理功能
	* "test_dns": 用于测试 DNS 解析功能
	* "test_proxyman": 用于测试代理库功能
	* "test_proxyman_inbound": 用于测试入站代理代理功能
	* "test_proxyman_outbound": 用于测试出站代理代理功能
	* "test_proxyman_async": 用于测试异步代理代理功能
	* "test_cli": 用于测试 CLI 工具功能
	* "test_server": 用于测试服务器功能
	* "test_udp": 用于测试 UDP 代理代理功能


```go
package dns_test

import (
	"strconv"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/miekg/dns"

	"v2ray.com/core"
	"v2ray.com/core/app/dispatcher"
	dnsapp "v2ray.com/core/app/dns"
	"v2ray.com/core/app/policy"
	"v2ray.com/core/app/proxyman"
	_ "v2ray.com/core/app/proxyman/inbound"
	_ "v2ray.com/core/app/proxyman/outbound"
	"v2ray.com/core/common"
	"v2ray.com/core/common/net"
	"v2ray.com/core/common/serial"
	dns_proxy "v2ray.com/core/proxy/dns"
	"v2ray.com/core/proxy/dokodemo"
	"v2ray.com/core/testing/servers/tcp"
	"v2ray.com/core/testing/servers/udp"
)

```

This is a Wireshark implementation that parses DNS queries from a network packet and extracts the query name, query type, and query answer. The query name is compared to several known query names for common websites and the answer is compared to the expected answer. If the query name matches "google.com." or "facebook.com.", the answer is considered a success and the answer and the root of the answer are printed to the Wirehpperanswer queue. If the query name matches "ipv6.google.com.", the answer is considered a success and the answer and the "回答" record are printed to the Wirehpperanswer queue. If the query name matches "ipv6.google.com.IN," the answer is considered a success and the answer and the "回答" record are printed to the Wirehpperanswer queue. If the query name matches "notexist.google.com." and the query type is A, a DNS resolution error is thrown.


```go
type staticHandler struct {
}

func (*staticHandler) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {
	ans := new(dns.Msg)
	ans.Id = r.Id

	var clientIP net.IP

	opt := r.IsEdns0()
	if opt != nil {
		for _, o := range opt.Option {
			if o.Option() == dns.EDNS0SUBNET {
				subnet := o.(*dns.EDNS0_SUBNET)
				clientIP = subnet.Address
			}
		}
	}

	for _, q := range r.Question {
		if q.Name == "google.com." && q.Qtype == dns.TypeA {
			if clientIP == nil {
				rr, _ := dns.NewRR("google.com. IN A 8.8.8.8")
				ans.Answer = append(ans.Answer, rr)
			} else {
				rr, _ := dns.NewRR("google.com. IN A 8.8.4.4")
				ans.Answer = append(ans.Answer, rr)
			}
		} else if q.Name == "facebook.com." && q.Qtype == dns.TypeA {
			rr, _ := dns.NewRR("facebook.com. IN A 9.9.9.9")
			ans.Answer = append(ans.Answer, rr)
		} else if q.Name == "ipv6.google.com." && q.Qtype == dns.TypeA {
			rr, err := dns.NewRR("ipv6.google.com. IN A 8.8.8.7")
			common.Must(err)
			ans.Answer = append(ans.Answer, rr)
		} else if q.Name == "ipv6.google.com." && q.Qtype == dns.TypeAAAA {
			rr, err := dns.NewRR("ipv6.google.com. IN AAAA 2001:4860:4860::8888")
			common.Must(err)
			ans.Answer = append(ans.Answer, rr)
		} else if q.Name == "notexist.google.com." && q.Qtype == dns.TypeAAAA {
			ans.MsgHdr.Rcode = dns.RcodeNameError
		}
	}
	w.WriteMsg(ans)
}

```

This is a Go program that performs a DNS resolution using the "net" package. It performs a query to a DNS server and checks if the query's answer is valid.

The program first checks if the DNS server responds to the query for the IP address of "google.com". If the server responds, it performs a recursive query for the IP address of "ipv4only.google.com" (which is the IPv4 address of the Google DNS server), and checks if the query's answer is valid. If the answer is not valid, the program sends a DNS query for the non-existent domain "notexist.google.com".

The program uses a DNS client to perform the DNS queries and it uses the "Exchange" method of the DNS client to connect to the DNS server. The "Exchange" method sends a DNS query to the DNS server and receives a response, and returns the response. The program uses the "Timeout" method to specify a timeout for the DNS query. If the query takes longer than the specified timeout, the program will raise an error.

Overall, the program is designed to check if the DNS server responds to the query and if the answer is valid or not.


```go
func TestUDPDNSTunnel(t *testing.T) {
	port := udp.PickPort()

	dnsServer := dns.Server{
		Addr:    "127.0.0.1:" + port.String(),
		Net:     "udp",
		Handler: &staticHandler{},
		UDPSize: 1200,
	}
	defer dnsServer.Shutdown()

	go dnsServer.ListenAndServe()
	time.Sleep(time.Second)

	serverPort := udp.PickPort()
	config := &core.Config{
		App: []*serial.TypedMessage{
			serial.ToTypedMessage(&dnsapp.Config{
				NameServers: []*net.Endpoint{
					{
						Network: net.Network_UDP,
						Address: &net.IPOrDomain{
							Address: &net.IPOrDomain_Ip{
								Ip: []byte{127, 0, 0, 1},
							},
						},
						Port: uint32(port),
					},
				},
			}),
			serial.ToTypedMessage(&dispatcher.Config{}),
			serial.ToTypedMessage(&proxyman.OutboundConfig{}),
			serial.ToTypedMessage(&proxyman.InboundConfig{}),
			serial.ToTypedMessage(&policy.Config{}),
		},
		Inbound: []*core.InboundHandlerConfig{
			{
				ProxySettings: serial.ToTypedMessage(&dokodemo.Config{
					Address:  net.NewIPOrDomain(net.LocalHostIP),
					Port:     uint32(port),
					Networks: []net.Network{net.Network_UDP},
				}),
				ReceiverSettings: serial.ToTypedMessage(&proxyman.ReceiverConfig{
					PortRange: net.SinglePortRange(serverPort),
					Listen:    net.NewIPOrDomain(net.LocalHostIP),
				}),
			},
		},
		Outbound: []*core.OutboundHandlerConfig{
			{
				ProxySettings: serial.ToTypedMessage(&dns_proxy.Config{}),
			},
		},
	}

	v, err := core.New(config)
	common.Must(err)
	common.Must(v.Start())
	defer v.Close()

	{
		m1 := new(dns.Msg)
		m1.Id = dns.Id()
		m1.RecursionDesired = true
		m1.Question = make([]dns.Question, 1)
		m1.Question[0] = dns.Question{Name: "google.com.", Qtype: dns.TypeA, Qclass: dns.ClassINET}

		c := new(dns.Client)
		in, _, err := c.Exchange(m1, "127.0.0.1:"+strconv.Itoa(int(serverPort)))
		common.Must(err)

		if len(in.Answer) != 1 {
			t.Fatal("len(answer): ", len(in.Answer))
		}

		rr, ok := in.Answer[0].(*dns.A)
		if !ok {
			t.Fatal("not A record")
		}
		if r := cmp.Diff(rr.A[:], net.IP{8, 8, 8, 8}); r != "" {
			t.Error(r)
		}
	}

	{
		m1 := new(dns.Msg)
		m1.Id = dns.Id()
		m1.RecursionDesired = true
		m1.Question = make([]dns.Question, 1)
		m1.Question[0] = dns.Question{Name: "ipv4only.google.com.", Qtype: dns.TypeAAAA, Qclass: dns.ClassINET}

		c := new(dns.Client)
		c.Timeout = 10 * time.Second
		in, _, err := c.Exchange(m1, "127.0.0.1:"+strconv.Itoa(int(serverPort)))
		common.Must(err)

		if len(in.Answer) != 0 {
			t.Fatal("len(answer): ", len(in.Answer))
		}
	}

	{
		m1 := new(dns.Msg)
		m1.Id = dns.Id()
		m1.RecursionDesired = true
		m1.Question = make([]dns.Question, 1)
		m1.Question[0] = dns.Question{Name: "notexist.google.com.", Qtype: dns.TypeAAAA, Qclass: dns.ClassINET}

		c := new(dns.Client)
		in, _, err := c.Exchange(m1, "127.0.0.1:"+strconv.Itoa(int(serverPort)))
		common.Must(err)

		if in.Rcode != dns.RcodeNameError {
			t.Error("expected NameError, but got ", in.Rcode)
		}
	}
}

```

This is a Go program that sets up a DNS server on a local server and listens for incoming requests. The program creates a DNS proxy using the `proxyman` package and starts it with the `core` layer of the Go framework.

The DNS server has a single server port that is handled by a `core.OutboundHandlerConfig` object. This configures the proxy to listen for incoming requests on the specified port and forward them to the DNS proxy.

The DNS server also has a `dns_proxy.Config` object that sets the proxy's network settings, such as the IP address and port range for the network.

The DNS server receives incoming requests using a `core.InboundHandlerConfig` object that specifies the IP address and port range for the network being used for incoming requests.

The DNS server then performs DNS lookups using the `dns.Client` object and the specified IP address and port range for the network. If a response is received for a query, it is compared to the previous response to see if any changes have been made.

If you want to modify the DNS server to perform more extensive tests, you may want to add more fields to the `dns_proxy.Config` object, such as the type of queries that the proxy supports and the maximum age of responses. You may also want to add additional fields to the `core.OutboundHandlerConfig` object, such as the handler's name or the IP address of the handler.


```go
func TestTCPDNSTunnel(t *testing.T) {
	port := udp.PickPort()

	dnsServer := dns.Server{
		Addr:    "127.0.0.1:" + port.String(),
		Net:     "udp",
		Handler: &staticHandler{},
	}
	defer dnsServer.Shutdown()

	go dnsServer.ListenAndServe()
	time.Sleep(time.Second)

	serverPort := tcp.PickPort()
	config := &core.Config{
		App: []*serial.TypedMessage{
			serial.ToTypedMessage(&dnsapp.Config{
				NameServer: []*dnsapp.NameServer{
					{
						Address: &net.Endpoint{
							Network: net.Network_UDP,
							Address: &net.IPOrDomain{
								Address: &net.IPOrDomain_Ip{
									Ip: []byte{127, 0, 0, 1},
								},
							},
							Port: uint32(port),
						},
					},
				},
			}),
			serial.ToTypedMessage(&dispatcher.Config{}),
			serial.ToTypedMessage(&proxyman.OutboundConfig{}),
			serial.ToTypedMessage(&proxyman.InboundConfig{}),
			serial.ToTypedMessage(&policy.Config{}),
		},
		Inbound: []*core.InboundHandlerConfig{
			{
				ProxySettings: serial.ToTypedMessage(&dokodemo.Config{
					Address:  net.NewIPOrDomain(net.LocalHostIP),
					Port:     uint32(port),
					Networks: []net.Network{net.Network_TCP},
				}),
				ReceiverSettings: serial.ToTypedMessage(&proxyman.ReceiverConfig{
					PortRange: net.SinglePortRange(serverPort),
					Listen:    net.NewIPOrDomain(net.LocalHostIP),
				}),
			},
		},
		Outbound: []*core.OutboundHandlerConfig{
			{
				ProxySettings: serial.ToTypedMessage(&dns_proxy.Config{}),
			},
		},
	}

	v, err := core.New(config)
	common.Must(err)
	common.Must(v.Start())
	defer v.Close()

	m1 := new(dns.Msg)
	m1.Id = dns.Id()
	m1.RecursionDesired = true
	m1.Question = make([]dns.Question, 1)
	m1.Question[0] = dns.Question{Name: "google.com.", Qtype: dns.TypeA, Qclass: dns.ClassINET}

	c := &dns.Client{
		Net: "tcp",
	}
	in, _, err := c.Exchange(m1, "127.0.0.1:"+serverPort.String())
	common.Must(err)

	if len(in.Answer) != 1 {
		t.Fatal("len(answer): ", len(in.Answer))
	}

	rr, ok := in.Answer[0].(*dns.A)
	if !ok {
		t.Fatal("not A record")
	}
	if r := cmp.Diff(rr.A[:], net.IP{8, 8, 8, 8}); r != "" {
		t.Error(r)
	}
}

```

This is a Go program that sets up a DNS resolver to use a DNS proxy. The DNS proxy receives queries from clients and forward them to a DNS resolver. The DNS resolver responds to the queries by returning the IP address of the authoritative DNS server for the requested domain.

The program sets up a DNS proxy by listening on a specified server port and using the localhost IP address as the listen address. The program then sets up an outgoing connection to the DNS resolver, which is configured to use TCP and listen on the same server port.

The program then sets up a DNS client to connect to the DNS resolver. The client is configured to use the specified server port and the localhost IP address as the connection address.

The program then enters an infinite loop, which continuously receives DNS queries from the client and forwards them to the DNS resolver. The program also handles incoming DNS queries from the DNS client and performs the necessary transformations on the query to ensure that it is properly formatted for the DNS resolver.

Once the program finishes running, it should have a working DNS resolver that can receive queries from clients and forward them to the DNS resolver configured to use it.


```go
func TestUDP2TCPDNSTunnel(t *testing.T) {
	port := tcp.PickPort()

	dnsServer := dns.Server{
		Addr:    "127.0.0.1:" + port.String(),
		Net:     "tcp",
		Handler: &staticHandler{},
	}
	defer dnsServer.Shutdown()

	go dnsServer.ListenAndServe()
	time.Sleep(time.Second)

	serverPort := tcp.PickPort()
	config := &core.Config{
		App: []*serial.TypedMessage{
			serial.ToTypedMessage(&dnsapp.Config{
				NameServer: []*dnsapp.NameServer{
					{
						Address: &net.Endpoint{
							Network: net.Network_UDP,
							Address: &net.IPOrDomain{
								Address: &net.IPOrDomain_Ip{
									Ip: []byte{127, 0, 0, 1},
								},
							},
							Port: uint32(port),
						},
					},
				},
			}),
			serial.ToTypedMessage(&dispatcher.Config{}),
			serial.ToTypedMessage(&proxyman.OutboundConfig{}),
			serial.ToTypedMessage(&proxyman.InboundConfig{}),
			serial.ToTypedMessage(&policy.Config{}),
		},
		Inbound: []*core.InboundHandlerConfig{
			{
				ProxySettings: serial.ToTypedMessage(&dokodemo.Config{
					Address:  net.NewIPOrDomain(net.LocalHostIP),
					Port:     uint32(port),
					Networks: []net.Network{net.Network_TCP},
				}),
				ReceiverSettings: serial.ToTypedMessage(&proxyman.ReceiverConfig{
					PortRange: net.SinglePortRange(serverPort),
					Listen:    net.NewIPOrDomain(net.LocalHostIP),
				}),
			},
		},
		Outbound: []*core.OutboundHandlerConfig{
			{
				ProxySettings: serial.ToTypedMessage(&dns_proxy.Config{
					Server: &net.Endpoint{
						Network: net.Network_TCP,
					},
				}),
			},
		},
	}

	v, err := core.New(config)
	common.Must(err)
	common.Must(v.Start())
	defer v.Close()

	m1 := new(dns.Msg)
	m1.Id = dns.Id()
	m1.RecursionDesired = true
	m1.Question = make([]dns.Question, 1)
	m1.Question[0] = dns.Question{Name: "google.com.", Qtype: dns.TypeA, Qclass: dns.ClassINET}

	c := &dns.Client{
		Net: "tcp",
	}
	in, _, err := c.Exchange(m1, "127.0.0.1:"+serverPort.String())
	common.Must(err)

	if len(in.Answer) != 1 {
		t.Fatal("len(answer): ", len(in.Answer))
	}

	rr, ok := in.Answer[0].(*dns.A)
	if !ok {
		t.Fatal("not A record")
	}
	if r := cmp.Diff(rr.A[:], net.IP{8, 8, 8, 8}); r != "" {
		t.Error(r)
	}
}

```

# `proxy/dns/errors.generated.go`

这段代码定义了一个名为 "dns" 的包，它导入了 "v2ray.com/core/common/errors" 包，可能是用于在 DNS 查询中处理错误。

该包中包含一个名为 "errPathObjHolder" 的结构体，它是一个空 struct，没有成员变量。

该结构体中包含一个名为 "newError" 的函数，该函数接受多个参数，这些参数可能是整数、字符串或接口类型。该函数返回一个 errors.Error 类型的对象，该对象包含一个 "WithPathObj" 方法，它接受一个 errPathObjHolder 类型的参数，并使用它来设置错误路径对象。

根据 errPathObjHolder 的定义，它是一个空 struct，没有任何成员变量或方法。因此，errPathObjHolder 的 "WithPathObj" 方法可能是一个默认的方法，用于在创建错误路径对象时设置错误路径对象。

总的来说，这段代码定义了一个用于在 DNS 查询中处理错误的包，其中包括一个用于创建错误路径对象的函数。


```go
package dns

import "v2ray.com/core/common/errors"

type errPathObjHolder struct{}

func newError(values ...interface{}) *errors.Error {
	return errors.New(values...).WithPathObj(errPathObjHolder{})
}

```

# `proxy/dokodemo/config.go`

这段代码定义了一个名为 "dokodemo" 的包，其中包含以下函数：

1. 函数名为 "GetPredefinedAddress"，该函数接收一个 "Config" 类型的变量 "v"，并返回该配置中的默认地址。

2. 函数首先从 "proto" 配置中获取定义的地址，如果地址无效，则返回 nil。

3. 函数中的 "v.Address" 是一个 "net.Address" 类型的变量，它用于存储从 "proto" 中获得的地址。

4. 如果 "v.Address" 的值为 nil，则返回 nil，否则使用 "v.Address" 的默认类型，将其转换为 "net.Address" 类型并返回。

5. 最后，函数返回从 "proto" 中获得的地址，如果地址无效，则返回 nil。


```go
package dokodemo

import (
	"v2ray.com/core/common/net"
)

// GetPredefinedAddress returns the defined address from proto config. Null if address is not valid.
func (v *Config) GetPredefinedAddress() net.Address {
	addr := v.Address.AsAddress()
	if addr == nil {
		return nil
	}
	return addr
}

```

# `proxy/dokodemo/config.pb.go`

该代码是一个Go语言编写的，通过 protoc-gen-go 工具生成的类型定义文件。它定义了一个名为 "dokodemo" 的包，包含了与 "dokodemo" 相关的数据结构和接口定义。以下是可能有助于理解此代码的说明：

1. 该代码依赖于两个名为 "github.com/golang/protobuf/proto" 和 "google.golang.org/protobuf/reflect/protoreflect" 的Maven或Golang依赖项。
2. 该代码中定义了一个名为 "config" 的接口，它通过 "google.golang.org/protobuf/reflect/protoreflect" 导入了反射功能。
3. 该代码中定义了一个名为 "dokodemo" 的包，并导入了 "reflect" 和 "sync" 包，这两个包与 "golang.org/x/net/rtp" 包关联，用于与互联网传输数据。
4. 该代码中定义了一个名为 "proxy/dokodemo/config" 的类型，该类型定义了一个 "Configuration" 类型的接口。该类型包含一个 "UDP" 类型的字段，它表示该Configuration实例应该采用的UDP端口号。
5. 该代码中定义了一个名为 "dokodemo/icontroller" 的类型，该类型定义了一个 "IController" 类型的接口。该接口定义了一个 "Configuration" 字段，它表示该实体的底层Configuration实例。
6. 该代码中定义了一个名为 "dokodemo/endpoint" 的类型，该类型定义了一个 "Endpoint" 类型的接口。该接口定义了一个 "Configuration" 字段，它表示该实体的底层Configuration实例。
7. 该代码中定义了一个名为 "dokodemo/message" 的类型，该类型定义了一个 "Message" 类型的接口。该接口定义了一个 "dokodemo" 字段，它表示该实体的身份。
8. 该代码中定义了一个名为 "dokodemo/rpc" 的类型，该类型定义了一个 "RPC" 类型的接口。该接口定义了一个 "dokodemo" 字段，它表示该实体的身份。
9. 该代码中定义了一个名为 "dokodemo/transport" 的类型，该类型定义了一个 "Transport" 类型的接口。该接口定义了一个 "dokodemo" 字段，它表示该实体的身份。
10. 该代码中定义了一个名为 "dokodemo/tls" 的类型，该类型定义了一个 "TLS" 类型的接口。该接口定义了一个 "dokodemo" 字段，它表示该实体的身份。
11. 该代码中定义了一个名为 "dokodemo/utils" 的类型，该类型定义了一个 "Utils" 类型的接口。该接口定义了一个 "dokodemo" 字段，它表示该实体的身份。

该代码定义了一个名为 "dokodemo" 的包，它包含了与 "dokodemo" 相关的接口和数据结构定义，可能用于定义一个与HTTP/HTTPS流量有关的后端服务。


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: proxy/dokodemo/config.proto

package dokodemo

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	net "v2ray.com/core/common/net"
)

```

The Config struct is a message that is used to configure the settings of an application.

The fields of the Config struct that are shown in the code snippet are:

* address: This field is used to specify the address of the Dokodemo server.
* port: This field is used to specify the port number that the Dokodemo server will listen for incoming connections.
* networkList: This field is used to specify the networks that the Dokodemo server accepts.
* Networks: This field is used to specify the networks that the Dokodemo server accepts.
* timeout: This field is used to specify the timeout for the connections to the Dokodemo server.
* followRedirect: This field is used to specify whether the server should follow redirects.
* userLevel: This field is used to specify the user level of the Dokodemo server.

It is important to note that the `protobuf` package defines the structure of the message and the fields that are required or optional. The specific fields that are used in the Config struct should be defined in accordance with the requirements of the specific application.


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Config struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address *net.IPOrDomain `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port    uint32          `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	// List of networks that the Dokodemo accepts.
	// Deprecated. Use networks.
	//
	// Deprecated: Do not use.
	NetworkList *net.NetworkList `protobuf:"bytes,3,opt,name=network_list,json=networkList,proto3" json:"network_list,omitempty"`
	// List of networks that the Dokodemo accepts.
	Networks []net.Network `protobuf:"varint,7,rep,packed,name=networks,proto3,enum=v2ray.core.common.net.Network" json:"networks,omitempty"`
	// Deprecated: Do not use.
	Timeout        uint32 `protobuf:"varint,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
	FollowRedirect bool   `protobuf:"varint,5,opt,name=follow_redirect,json=followRedirect,proto3" json:"follow_redirect,omitempty"`
	UserLevel      uint32 `protobuf:"varint,6,opt,name=user_level,json=userLevel,proto3" json:"user_level,omitempty"`
}

```

这段代码定义了两个函数：

1. `Reset()`函数接收一个指向`Config`类型的参数 `x`，并将其赋值为`Config{}`。然后，代码块使用条件语句 `if protoimpl.UnsafeEnabled` 来判断是否启用`file_proxy_dokodemo_config_proto_unused_言归。如果启用`file_proxy_dokodemo_config_proto_unused_言归`，则代码块执行以下操作：

- 创建一个空的`Config`类型变量 `Config{}`。
- 如果`file_proxy_dokodemo_config_proto_unused_言归`启用，则执行以下操作：
 - 获取`file_proxy_dokodemo_config_proto_dokodem 的类型 `ms`。
 - 使用`ms`类型将一个指向`Config`类型数组的指针 `x` 转换为 `ms` 类型。
 - 调用`ms.StoreMessageInfo(mi)`将`mi`类型设置为`Config{}`。

2. `String()`函数返回一个指向`Config`类型数组的指针 `x` 的字符串表示。

3. `ProtoMessage()`函数用于生成`Config`类型参数的可读性消息类型。


```go
func (x *Config) Reset() {
	*x = Config{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proxy_dokodemo_config_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

```

这段代码定义了两个函数，分别接收一个`Config`类型的参数`x`，并返回其`Descriptor`字段。

函数`Descriptor`接收一个`Config`类型的`x`，并返回其`Descriptor`字段的值。如果`x`为` nil`，则返回一个字节切片和一个表示没有描述性的零个字节数组。这个函数在函数头中使用的是`file_proxy_dokodemo_config_proto_rawDescGZIP()`，它将函数内部的类型转换为字节切片，并将这些字节片存储为字节切片类型。

函数`ProtoReflect`接收一个`Config`类型的`x`，并返回一个`protoreflect.Message`类型的`mi`。它通过调用`protoimpl.UnsafeEnabled`和`x`的`MessageStateOf`函数来尝试获取一个`Message`实例，如果没有成功，则返回`mi`。`mi`是一个指向`file_proxy_dokodemo_config_proto_msgTypes`类型对象的指针，它包含一个与传入的`x``同名的`Message`类型对象的`Message`字段。

函数`UnsafeEnabled`检查`x`是否为`nil`。如果是，则禁止函数内部使用`UnsafeEnabled`，因为这样可能会导致安全漏洞。但是，如果`x`不是`nil`，则允许函数内部使用`UnsafeEnabled`，这样就可以尝试从`x`内部获取一个`Message`实例。


```go
func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_proxy_dokodemo_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_proxy_dokodemo_config_proto_rawDescGZIP(), []int{0}
}

```

这两函数是使用Go编程语言编写的，它们的作用是获取Config结构体中的IP地址和端口号。

第一个函数（`func (x *Config) GetAddress() *net.IPOrDomain`）将`x`容器的值作为参数，并尝试返回一个`net.IPOrDomain`类型的引用。如果`x`容器不为空，则返回`x`中的`地址`；如果`x`容器为空，则返回`nil`。

第二个函数（`func (x *Config) GetPort() uint32`）将`x`容器的值作为参数，并尝试返回一个`uint32`类型的整数。如果`x`容器不为空，则返回`x`中的`端口号`；如果`x`容器为空，则返回`0`。

需要注意的是，第一个函数有一个注释，它说这个函数是“Deprecated”，这意味着这个函数在将来会被删除，不应该在现有的代码中使用。因此，我们应该避免在现有的代码中调用这两个函数，以免导致程序出现问题。


```go
func (x *Config) GetAddress() *net.IPOrDomain {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *Config) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

// Deprecated: Do not use.
```

这两段代码都是函数，它们都接受一个名为“x”的参数，并返回一个名为“*net.NetworkList”或“*net.Network”的类型。

在第一段代码中，函数名为“func”，它内部包含一个名为“x”的指针变量和一个名为“GetNetworkList”的函数。如果指针“x”不为空，那么调用“x.NetworkList”获取一个网络列表并返回。否则，返回一个空指针。

在第二段代码中，函数名为“func”，它内部包含一个名为“x”的指针变量和一个名为“GetNetworks”的函数。如果指针“x”不为空，那么调用“x.Networks”获取一个网络列表并返回。否则，返回一个空指针。

第一段代码和第二段代码都使用了相同的“Deprecated”注释，这意味着它们是过时的，不应该在生产环境中使用。


```go
func (x *Config) GetNetworkList() *net.NetworkList {
	if x != nil {
		return x.NetworkList
	}
	return nil
}

func (x *Config) GetNetworks() []net.Network {
	if x != nil {
		return x.Networks
	}
	return nil
}

// Deprecated: Do not use.
```

这段代码定义了三个函数，分别接收一个名为Config的32字节的指针参数。

第一个函数GetTimeout()返回一个uint32类型的变量，表示Config中的超时时间设置。函数首先检查参数x是否为nil，如果是，则直接返回0。否则，函数使用x.Timeout值作为超时时间设置。

第二个函数GetFollowRedirect()返回一个bool类型的变量，表示Config中是否啟用跟随Redirect。函数同样首先检查参数x是否为nil，如果是，则返回false。否则，函数使用x.FollowRedirect值作为是否啟用跟随Redirect的判断。

第三个函数GetUserLevel()返回一个uint32类型的变量，表示Config中的用戶級別。函数同样首先检查参数x是否为nil，如果是，则返回0。否则，函数使用x.UserLevel值作为用戶級別的设置。


```go
func (x *Config) GetTimeout() uint32 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *Config) GetFollowRedirect() bool {
	if x != nil {
		return x.FollowRedirect
	}
	return false
}

func (x *Config) GetUserLevel() uint32 {
	if x != nil {
		return x.UserLevel
	}
	return 0
}

```

0x2a 0x01 0x4a 0x68 0x6f 0x72 0x6c 0x64 0x61 0x74 0x65 0x73 0x2a 0x02 0x33 0x44 0x6f 0x6b 0x6f 0x64 0x65 0x61 0x79 0x2e 0x43 0x61 0x79 0x2e 0x56 0x32 0x52 0x61 0x79 0x2e 0x6f 0x78 0x79 0x2e 0x64 0x6f 0x62 0x06 0x70 0x72 0x6f 0x74 0x6f 0x33



```go
var File_proxy_dokodemo_config_proto protoreflect.FileDescriptor

var file_proxy_dokodemo_config_proto_rawDesc = []byte{
	0x0a, 0x1b, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2f, 0x64, 0x6f, 0x6b, 0x6f, 0x64, 0x65, 0x6d, 0x6f,
	0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x19, 0x76,
	0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e,
	0x64, 0x6f, 0x6b, 0x6f, 0x64, 0x65, 0x6d, 0x6f, 0x1a, 0x18, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2f, 0x6e, 0x65, 0x74, 0x2f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x1a, 0x18, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x6e, 0x65, 0x74, 0x2f, 0x6e,
	0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc6, 0x02, 0x0a,
	0x06, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x3b, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79,
	0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x6e, 0x65, 0x74,
	0x2e, 0x49, 0x50, 0x4f, 0x72, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x52, 0x07, 0x61, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x49, 0x0a, 0x0c, 0x6e, 0x65, 0x74, 0x77,
	0x6f, 0x72, 0x6b, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22,
	0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x6e, 0x65, 0x74, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x4c, 0x69,
	0x73, 0x74, 0x42, 0x02, 0x18, 0x01, 0x52, 0x0b, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x4c,
	0x69, 0x73, 0x74, 0x12, 0x3a, 0x0a, 0x08, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x18,
	0x07, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f,
	0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x6e, 0x65, 0x74, 0x2e, 0x4e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x52, 0x08, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x12,
	0x1c, 0x0a, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d,
	0x42, 0x02, 0x18, 0x01, 0x52, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x27, 0x0a,
	0x0f, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x52, 0x65,
	0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6c,
	0x65, 0x76, 0x65, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x75, 0x73, 0x65, 0x72,
	0x4c, 0x65, 0x76, 0x65, 0x6c, 0x42, 0x5c, 0x0a, 0x1d, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x32, 0x72,
	0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x64, 0x6f,
	0x6b, 0x6f, 0x64, 0x65, 0x6d, 0x6f, 0x50, 0x01, 0x5a, 0x1d, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e,
	0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2f, 0x64,
	0x6f, 0x6b, 0x6f, 0x64, 0x65, 0x6d, 0x6f, 0xaa, 0x02, 0x19, 0x56, 0x32, 0x52, 0x61, 0x79, 0x2e,
	0x43, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x44, 0x6f, 0x6b, 0x6f, 0x64,
	0x65, 0x6d, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

```

这段代码定义了一个名为file_proxy_dokodemo_config_proto_rawDescOnce的变量，该变量是一个Once类型，也就是一个函数，该函数的实现为同步方式(sync.Once)。

函数的实现中，先定义了一个名为file_proxy_dokodemo_config_proto_rawDescData的变量，该变量被赋值为file_proxy_dokodemo_config_proto_rawDesc，该文件_proxy_dokodemo_config_proto_rawDesc是一个类型为protoimpl.X.CompressGZIP的函数的返回值，该函数的作用是压缩GZIP格式的字节切片。

然后，函数实现了一个名为file_proxy_dokodemo_config_proto_rawDescGZIP的函数，该函数接收file_proxy_dokodemo_config_proto_rawDescOnce中的函数，使用protoimpl.X.CompressGZIP函数将file_proxy_dokodemo_config_proto_rawDescData字节切片压缩为字节切片，并返回该字节切片。

接着，定义了一个名为file_proxy_dokodemo_config_proto_msgTypes的变量，该变量被赋值为make([]protoimpl.MessageInfo, 1)，该类型是一个包含1个messageInfo类型的元组，该元组包含一个接口类型声明，该接口类型声明包含2个参数，分别是一个Config类型和一个net.IPOrDomain类型，该接口类型声明定义了file_proxy_dokodemo_config_proto_goTypes类型的变量。

最后，定义了一个名为file_proxy_dokodemo_config_proto_goTypes的变量，该变量被赋值为[]interface{}，该变量是一个包含一个接口类型声明的元组，该接口类型声明定义了file_proxy_dokodemo_config_proto_goTypes类型的变量，该变量中包含的接口类型声明包含了一个名为net.NetworkList的类型，该类型包含一个名为Network的类型，该类型包含一个名为0的整数类型参数，因此，该接口类型声明定义了一个net.Network类型的变量，该变量中包含一个名为0的整数类型参数，也就是一个没有定义的类型，file_proxy_dokodemo_config_proto_goTypes实际上就是[]net.Network类型的变量。


```go
var (
	file_proxy_dokodemo_config_proto_rawDescOnce sync.Once
	file_proxy_dokodemo_config_proto_rawDescData = file_proxy_dokodemo_config_proto_rawDesc
)

func file_proxy_dokodemo_config_proto_rawDescGZIP() []byte {
	file_proxy_dokodemo_config_proto_rawDescOnce.Do(func() {
		file_proxy_dokodemo_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_proxy_dokodemo_config_proto_rawDescData)
	})
	return file_proxy_dokodemo_config_proto_rawDescData
}

var file_proxy_dokodemo_config_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_proxy_dokodemo_config_proto_goTypes = []interface{}{
	(*Config)(nil),          // 0: v2ray.core.proxy.dokodemo.Config
	(*net.IPOrDomain)(nil),  // 1: v2ray.core.common.net.IPOrDomain
	(*net.NetworkList)(nil), // 2: v2ray.core.common.net.NetworkList
	(net.Network)(0),        // 3: v2ray.core.common.net.Network
}
```

This is a function definition for the `file_proxy_dokodemo_config_proto_init()` function. It is used to initialize the `file_proxy_dokodemo_config_proto` package's default values.

The function takes no arguments and returns nothing.

It is defined in the `file_proxy_dokodemo_config_proto_init.go` file in the `file_proxy_dokodemo_config_proto_messages` package.


```go
var file_proxy_dokodemo_config_proto_depIdxs = []int32{
	1, // 0: v2ray.core.proxy.dokodemo.Config.address:type_name -> v2ray.core.common.net.IPOrDomain
	2, // 1: v2ray.core.proxy.dokodemo.Config.network_list:type_name -> v2ray.core.common.net.NetworkList
	3, // 2: v2ray.core.proxy.dokodemo.Config.networks:type_name -> v2ray.core.common.net.Network
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_proxy_dokodemo_config_proto_init() }
func file_proxy_dokodemo_config_proto_init() {
	if File_proxy_dokodemo_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proxy_dokodemo_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proxy_dokodemo_config_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proxy_dokodemo_config_proto_goTypes,
		DependencyIndexes: file_proxy_dokodemo_config_proto_depIdxs,
		MessageInfos:      file_proxy_dokodemo_config_proto_msgTypes,
	}.Build()
	File_proxy_dokodemo_config_proto = out.File
	file_proxy_dokodemo_config_proto_rawDesc = nil
	file_proxy_dokodemo_config_proto_goTypes = nil
	file_proxy_dokodemo_config_proto_depIdxs = nil
}

```