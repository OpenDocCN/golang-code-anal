# v2ray-core源码解析 73

# `transport/internet/udp/hub_other.go`

这段代码是一个 Go 语言编写的 UDP 库，实现了一个 UDP 网络服务，允许用户通过在客户端和服务器之间传输 UDP 数据包。以下是代码的一些关键部分的功能解释：

1. `// +build !linux,!freebsd`：这是一个构建命令，告诉 Go build 工具在编译时不要为 Linux 和 FreeBSD 平台生成二进制文件。

2. `package udp`：这个包的名称是 "udp"，表示它与 UDP 传输有关。

3. `import ( "v2ray.com/core/common/net" )`：这个导入语句从 "v2ray.com/core/common/net" 包中导入 "net" 字面。

4. `func RetrieveOriginalDest(oob []byte) net.Destination`：这个函数接收一个 OOB（输出双向无序列化的字节切片）作为参数，然后返回一个 net.Destination 类型的变量。这个函数在没有接收到数据的情况下，返回一个空 net.Destination 类型，表示数据包的原始发送目的。

5. `func ReadUDPMsg(conn *net.UDPConn, payload []byte, oob []byte) (int, int, int, *net.UDPAddr, error)`：这个函数接收一个 UDP 连接对象（conn），一个字节切片（payload）和一个 OOB 作为参数。它通过调用 UDP 连接的 `ReadFromUDP` 方法来接收数据，然后返回读取的数据字节数、接收到数据的精确位置、接收到数据的目标 UDP 地址，以及可能的错误。

6. `nBytes, addr, err := conn.ReadFromUDP(payload)`：这个函数通过调用 UDP 连接的 `ReadFromUDP` 方法，接收一个字节切片（payload）并返回读取的数据字节数、接收到数据的精确位置和错误。

7. `return nBytes, 0, 0, addr, err`：这个函数返回从 UDP 连接读取数据后获得的成功返回值，包括读取到的数据字节数、接收到数据的精确位置、接收到数据的目标 UDP 地址，以及可能的错误。

8. `<-// +build !linux,!freebsd`：这个是一个描述性注释，告诉您 Go build 工具在编译时不要为 Linux 和 FreeBSD 平台生成二进制文件。


```go
// +build !linux,!freebsd

package udp

import (
	"v2ray.com/core/common/net"
)

func RetrieveOriginalDest(oob []byte) net.Destination {
	return net.Destination{}
}

func ReadUDPMsg(conn *net.UDPConn, payload []byte, oob []byte) (int, int, int, *net.UDPAddr, error) {
	nBytes, addr, err := conn.ReadFromUDP(payload)
	return nBytes, 0, 0, addr, err
}

```

# `transport/internet/udp/udp.go`

这段代码定义了一个名为 "udp" 的 UDP 协议。它包含了一个常量 "protocolName"，用于标识该协议。

同时，该代码还导入了 "udp" 包到 "v2ray.com/core/common/errors/errorgen" 包中，以便在程序运行时生成 UDP 相关的错误信息。

另外，由于没有具体的函数或变量被定义，所以无法进一步了解该代码的实际作用。


```go
package udp

//go:generate go run v2ray.com/core/common/errors/errorgen

const protocolName = "udp"

```

# `transport/internet/websocket/config.go`

这段代码是一个 C++ 语言编写的 websocket 库，它的主要目的是提供了一个 WebSocket 服务器，允许客户端通过 HTTP 连接与服务器通信。以下是对该代码的一些解释：

1. `// +build !confonly`：这是一个构建时预处理指令，告诉编译器在编译之前进行这些预处理操作。`!confonly` 表示这个指令不会在编译器输出中出现，仅在构建时执行。
2. `package websocket`：定义了该库的包名，通常是 `websocket_init.h` 和 `websocket_main.h`。
3. `import (`：引入了以下依赖项：
	* `net/http`：用于在 WebSocket 客户端和服务器之间传输 HTTP 请求和响应。
	* `v2ray.com/core/common`：用于与 V2Ray 服务器进行通信的库。
	* `v2ray.com/core/transport/internet`：用于与互联网进行通信的库。
4. `const protocolName = "websocket"`：定义了一个常量 `protocolName`，值为 "websocket"，表示该库支持 WebSocket 协议。
5. `func (c *Config) GetNormalizedPath() string`：定义了一个名为 `GetNormalizedPath` 的函数，接收一个 `*Config` 类型的参数 `c`，并返回客户端应用程序相对于配置文件夹的路径。
6. `path := c.Path`：将 `c.Path` 赋值为 `c` 指向的 `*Config` 对象中的 `path` 字段，用于存储客户端应用程序的原始请求路径。
7. `if path == ""`：如果 `path` 为空，执行以下操作：
	* 将 `path` 变量设置为 `"/"`，表示客户端应用程序请求的默认路径。
	* 如果 `path` 不是以 `/` 开头的字符串，则执行以下操作：
		+ 将 `path` 变量设置为 `path` 加上 `"/"`，相当于执行 `path = path + "/"`。
8. `return path`：返回 `path` 变量的值，用于将客户端应用程序的请求路径转换为相对于配置文件夹的路径。
9. `func (c *Config) GetNormalizedPath() string`：定义了一个名为 `GetNormalizedPath` 的函数，但这个函数在第一次调用时不会返回路径，只有在 `c` 指向的 `*Config` 对象没有被创建时才会执行，以确保 `path` 变量有意义。
10. `package net/http`：引入了 `net/http` 包，用于在 WebSocket 客户端和服务器之间传输 HTTP 请求和响应。


```go
// +build !confonly

package websocket

import (
	"net/http"

	"v2ray.com/core/common"
	"v2ray.com/core/transport/internet"
)

const protocolName = "websocket"

func (c *Config) GetNormalizedPath() string {
	path := c.Path
	if path == "" {
		return "/"
	}
	if path[0] != '/' {
		return "/" + path
	}
	return path
}

```

这段代码定义了一个名为`func`的函数，其接收一个名为`c`的参数，代表一个`Config`结构体。

这个函数的作用是获取请求头（Request Header）并返回一个`http.Header`类型的变量。它通过遍历`c.Header`切片，获取每个`http.Header`结构体的`Key`和`Value`字段，并将它们添加到一个新的`http.Header`结构体中。

最后，它返回这个`http.Header`结构体，可以使用在`http.Header`中的字面量（Key和Value）访问其中的字段。


```go
func (c *Config) GetRequestHeader() http.Header {
	header := http.Header{}
	for _, h := range c.Header {
		header.Add(h.Key, h.Value)
	}
	return header
}

func init() {
	common.Must(internet.RegisterProtocolConfigCreator(protocolName, func() interface{} {
		return new(Config)
	}))
}

```

# `transport/internet/websocket/config.pb.go`

这段代码定义了一个名为 "websocket" 的包，其中包含了一些定义、声明和常量。

首先，它导入了来自 "github.com/golang/protobuf/proto" 和 "google.golang.org/protobuf/reflect/protoreflect" 包的 protobuf定义。

然后，它使用反射功能从 protobuf 包中读取定义，并将其存储在名为 "websocket.proto" 的文件中。

接着，它定义了一些类型，如 "config.Message" 和 "config.把持器" 类型，以及一个名为 "sendMessage" 的函数，它接受一个 "config.Message" 类型的参数，并将其转换为 "message" 类型的参数。

最后，它定义了一个名为 "wsUpdater" 的函数，该函数使用一个 "sync" 包中的 "channel" 类型的变量来发送消息。


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: transport/internet/websocket/config.proto

package websocket

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

```

这段代码是一个高亮代码，用于表明它生成的代码已经足够更新。它使用了 protobuf 中的 enforceVersion 函数。该函数的作用是验证生成的代码是否与预期的兼容版本。如果两个版本的兼容性版本号之间存在差异，则会抛出一个错误。

在这段注释中，作者还提到了一个编译时 assertion，即 "This is a compile-time assertion that a sufficiently up-to-date version of the legacy proto package is being used."。这个 assertion 的作用是在编译时检查版本号是否与预期的兼容。

最后，该代码定义了一个 Header 结构体，其中包含了一些 protobuf 中的类型字段。


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Header struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

```

这段代码定义了两个函数，以及一个Header类型的类型转换函数。

这两个函数是方法的实现，用于重置Header类型的实例x，并将其包装为文件传输传输协议互联网 WebSocket 配置协议的简单类型。

if protoimpl.UnsafeEnabled {
   mi := &file_transport_internet_websocket_config_proto_msgTypes[0]
   ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   ms.StoreMessageInfo(mi)
}

func (x *Header) Reset() {
   *x = Header{}
   if protoimpl.UnsafeEnabled {
       protoimpl.X.UnsafeMonero(x).Send(&x, "reset")
   }
}

func (x *Header) String() string {
   return protoimpl.X.MessageStringOf(x)
}

func (x *Header) ProtoMessage() *Header {
   return x
}

在这段注释中，还可以看到一些说明。

- `func (x *Header) Reset()` 函数将清空 `Header` 类型的实例 x。
- `func (x *Header) String()` 函数返回 `Header` 类型实例 x 的字符串表示。
- `func (x *Header) ProtoMessage() *Header` 函数返回 `Header` 类型实例 x 的 `*Header` 类型表示，这个类型转换通过 `protoimpl.X.MessageTypeOf()` 实现。


```go
func (x *Header) Reset() {
	*x = Header{}
	if protoimpl.UnsafeEnabled {
		mi := &file_transport_internet_websocket_config_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Header) ProtoMessage() {}

```

这段代码定义了一个名为 "func" 的函数，它接收一个名为 "x" 的整数类型的指针参数，并返回一个名为 "prototypeReflect" 的函数指针类型。

函数的作用是通过反射操作获取一个名为 "file_transport_internet_websocket_config_proto_msgTypes" 的接口类型对象，然后根据传入的整数类型的指针参数，检查是否启用了 "UnsafeEnabled" 选项，如果是，就执行以下操作：

1. 从 "x" 指向的内存区域加载一个 "file_transport_internet_websocket_config_proto_msgTypes" 类型的大约 7 字节长度的消息类型信息，然后解码其中的元数据。
2. 如果 "UnsafeEnabled" 选项为真，并且 "x" 指向的内存区域包含一个有效的 "file_transport_internet_websocket_config_proto_msgTypes" 类型实例，那么执行以下操作：

	1. 从 "x" 指向的内存区域加载一个 "file_transport_internet_websocket_config_proto_msgTypes" 类型的大约 7 字节长度的消息类型信息，然后解码其中的元数据。
	2. 如果 "UnsafeEnabled" 选项为真，并且 "x" 指向的内存区域包含一个有效的 "file_transport_internet_websocket_config_proto_msgTypes" 类型实例，那么返回消息类型信息作为 "prototypeReflect" 函数的返回值，否则返回 "file_transport_internet_websocket_config_proto_msgTypes" 类型对象的 "MessageOf" 函数返回的原始 "file_transport_internet_websocket_config_proto_msgTypes" 类型对象的 "MessageOf" 函数的原始类型。

另外，还定义了一个名为 "Descriptor" 的函数，它接收一个 "Header" 类型的指针参数，并返回一个字符串类型的字节数组和两个整数类型的参数，其中第一个整数类型表示消息类型信息解码后得到的索引，第二个整数类型表示消息类型信息解码后得到的编码。


```go
func (x *Header) ProtoReflect() protoreflect.Message {
	mi := &file_transport_internet_websocket_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Header.ProtoReflect.Descriptor instead.
func (*Header) Descriptor() ([]byte, []int) {
	return file_transport_internet_websocket_config_proto_rawDescGZIP(), []int{0}
}

```

这段代码定义了一个名为`Config`的结构体类型，用于表示WebSocket服务的配置。

该结构体包含以下字段：

* `state`：一个`protoimpl.MessageState`类型的字段，用于保存当前连接状态的优先级。
* `sizeCache`：一个`protoimpl.SizeCache`类型的字段，用于缓存已经下载的数据大小。
* `unknownFields`：一个`protoimpl.UnknownFields`类型的字段，用于保存无法解析的序列化字段。

此外，还包含一个字段`Path`，表示WebSocket服务的URL路径。

另外，该结构体还定义了一个名为`Header`的类型，用于定义WebSocket请求和响应头。

该类型包含一个字段`*Header`，用于保存`Header`字段的引用。

最后，定义了一个名为`AcceptProxyProtocol`的布尔字段，表示是否启用代理协议接受连接。


```go
func (x *Header) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Header) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type Config struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// URL path to the WebSocket service. Empty value means root(/).
	Path                string    `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Header              []*Header `protobuf:"bytes,3,rep,name=header,proto3" json:"header,omitempty"`
	AcceptProxyProtocol bool      `protobuf:"varint,4,opt,name=accept_proxy_protocol,json=acceptProxyProtocol,proto3" json:"accept_proxy_protocol,omitempty"`
}

```

这段代码定义了两个函数，以及一个名为`func`的函数指针。这些函数主要作用于一个名为`Config`的接口类型的变量`x`。下面将分别解释每个函数的作用：

1. `func (x *Config) Reset()`

这个函数的主要作用是重置`Config`对象`x`的内部状态，将其设置为一个新的`Config`对象的初始状态。这通常是在需要在启动一个全新的`Config`实例时执行的。

1. `func (x *Config) String() string`

这个函数的主要作用是将`Config`对象`x`转换为字符串表示。它返回的结果将按照`Config`的`String`函数的实现来打印。

1. `func (x *Config) ProtoMessage()`

这个函数的主要作用是将`Config`对象`x`包装成一个`protoimpl.Message`类型。包装后的`Config`对象将具有`Config`接口的`Message`字段和`protoimpl.Message`类型的`Message`字段。这个函数的返回值将按照`Config`的`Message`函数的实现来打印。


```go
func (x *Config) Reset() {
	*x = Config{}
	if protoimpl.UnsafeEnabled {
		mi := &file_transport_internet_websocket_config_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

```

这段代码定义了两个函数，分别接收一个`Config`类型的参数`x`，并返回其`Descriptor`字段。

第一个函数`func (x *Config) ProtoReflect() protoreflect.Message`接收一个`Config`类型的指针`x`，并返回一个与`file_transport_internet_websocket_config_proto_msgTypes`数组长度为1的`Message`类型的`mi`。如果`protoimpl.UnsafeEnabled`为`true`，则创建一个包含`x`的`MessageStateOf`函数，并检查其是否为`nil`。如果是，则将其设置为`mi`，并返回`mi`。否则，直接返回`mi`。

第二个函数`func (x *Config) Descriptor() ([]byte, []int)`接收一个`Config`类型的参数`x`，并返回其`Descriptor`字段的原始字节数组和长度。它与大多数Go语言中的`descriptor`函数的行为相同，返回一个表示`Config`类型的字节数组，其中包含一个包含`x`的描述符。


```go
func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_transport_internet_websocket_config_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_transport_internet_websocket_config_proto_rawDescGZIP(), []int{1}
}

```

这段代码定义了三个函数，分别接收一个Config类型的参数x。

第一个函数GetPath()返回一个字符串类型的路径。函数首先检查参数x是否为nil，如果是，则直接返回一个空字符串""。否则，函数调用x的Path属性，并返回该路径。

第二个函数GetHeader()返回一个接口类型的头信息。函数首先检查参数x是否为nil，如果是，则返回一个空的切片类型[]Header。否则，函数调用x的Header属性，并返回该头信息。

第三个函数GetAcceptProxyProtocol()返回一个布尔类型的接受代理协议协议。函数首先检查参数x是否为nil，如果是，则返回false。否则，函数调用x的AcceptProxyProtocol属性，并返回该代理协议协议。


```go
func (x *Config) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *Config) GetHeader() []*Header {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *Config) GetAcceptProxyProtocol() bool {
	if x != nil {
		return x.AcceptProxyProtocol
	}
	return false
}

```

I'm sorry, I'm not sure what you are asking. Could you please provide more context or clarify your question?



```go
var File_transport_internet_websocket_config_proto protoreflect.FileDescriptor

var file_transport_internet_websocket_config_proto_rawDesc = []byte{
	0x0a, 0x29, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x2f, 0x69, 0x6e, 0x74, 0x65,
	0x72, 0x6e, 0x65, 0x74, 0x2f, 0x77, 0x65, 0x62, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2f, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x27, 0x76, 0x32, 0x72,
	0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72,
	0x74, 0x2e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x2e, 0x77, 0x65, 0x62, 0x73, 0x6f,
	0x63, 0x6b, 0x65, 0x74, 0x22, 0x30, 0x0a, 0x06, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x9f, 0x01, 0x0a, 0x06, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x70, 0x61, 0x74, 0x68, 0x12, 0x47, 0x0a, 0x06, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x18,
	0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f,
	0x72, 0x65, 0x2e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x2e, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x6e, 0x65, 0x74, 0x2e, 0x77, 0x65, 0x62, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e,
	0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x06, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x32,
	0x0a, 0x15, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x5f, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x5f, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x13, 0x61,
	0x63, 0x63, 0x65, 0x70, 0x74, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x4a, 0x04, 0x08, 0x01, 0x10, 0x02, 0x42, 0x86, 0x01, 0x0a, 0x2b, 0x63, 0x6f, 0x6d,
	0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x74, 0x72, 0x61, 0x6e,
	0x73, 0x70, 0x6f, 0x72, 0x74, 0x2e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x2e, 0x77,
	0x65, 0x62, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x50, 0x01, 0x5a, 0x2b, 0x76, 0x32, 0x72, 0x61,
	0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x74, 0x72, 0x61, 0x6e, 0x73,
	0x70, 0x6f, 0x72, 0x74, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x2f, 0x77, 0x65,
	0x62, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0xaa, 0x02, 0x27, 0x56, 0x32, 0x52, 0x61, 0x79, 0x2e,
	0x43, 0x6f, 0x72, 0x65, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x2e, 0x49,
	0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x2e, 0x57, 0x65, 0x62, 0x73, 0x6f, 0x63, 0x6b, 0x65,
	0x74, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

```

此代码定义了一个名为file_transport_internet_websocket_config_proto的函数，其作用是将文件传输网络网页Socket配置Protobuf格式的数据进行GZIP压缩。以下是该函数的实现过程：

1. 定义变量：file_transport_internet_websocket_config_proto_rawDescOnce和file_transport_internet_websocket_config_proto_rawDescData分别定义了两个变量，分别代表原始的文件传输网络网页Socket配置Protobuf格式的数据和经过GZIP压缩后的数据。

2. 函数实现：file_transport_internet_websocket_config_proto_rawDescGZIP函数首先调用file_transport_internet_websocket_config_proto_rawDescOnce.Do函数，该函数的作用是将file_transport_internet_websocket_config_proto_rawDescData进行GZIP压缩。

3. 返回数据：file_transport_internet_websocket_config_proto_rawDescGZIP函数返回file_transport_internet_websocket_config_proto_rawDescData，即经过GZIP压缩后的文件传输网络网页Socket配置Protobuf格式的数据。

4. 定义变量：file_transport_internet_websocket_config_proto_msgTypes定义了两个变量，分别表示请求和响应的Protobuf消息类型。

5. 定义变量：file_transport_internet_websocket_config_proto_goTypes定义了两个变量，分别表示v2ray.core.transport.internet.websocket.Header和v2ray.core.transport.internet.websocket.Config的类型接口。

file_transport_internet_websocket_config_proto_rawDescOnce和file_transport_internet_websocket_config_proto_rawDescData作为函数的输入参数，file_transport_internet_websocket_config_proto_rawDescGZIP函数返回的数据显示了函数的最终执行结果。


```go
var (
	file_transport_internet_websocket_config_proto_rawDescOnce sync.Once
	file_transport_internet_websocket_config_proto_rawDescData = file_transport_internet_websocket_config_proto_rawDesc
)

func file_transport_internet_websocket_config_proto_rawDescGZIP() []byte {
	file_transport_internet_websocket_config_proto_rawDescOnce.Do(func() {
		file_transport_internet_websocket_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_transport_internet_websocket_config_proto_rawDescData)
	})
	return file_transport_internet_websocket_config_proto_rawDescData
}

var file_transport_internet_websocket_config_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_transport_internet_websocket_config_proto_goTypes = []interface{}{
	(*Header)(nil), // 0: v2ray.core.transport.internet.websocket.Header
	(*Config)(nil), // 1: v2ray.core.transport.internet.websocket.Config
}
```

This is a Python implementation of the file "transport\_internet\_websocket\_config" which defines the structure of data used by the Protocol Buffers encoding/decoding program.

This program uses the Protocol Buffers library to define the data structure of the file, which is then used to serialize the data to and from various data types.

The program has several fields that are used to store different types of data. These fields include:

* config: This is a field of type Config which is a prototype for a data structure that is used to configure a WebSocket connection.
* state: This is a field of type Config which is a prototype for a data structure that is used to store the current state of a WebSocket connection.
* sizeCache: This is a field of type Config which is a prototype for a data structure that is used to store the size of a WebSocket connection cache.
* unknownFields: This is a field of type Config which is a prototype for a data structure that is used to store any fields that the decoder does not know how to decode.
* connections: This is a field of type List[TransportInternetWebSocketConfig] which is used to store a list of WebSocketConfig instances.

The program also has several methods that are used to retrieve and set the values of the fields in the data structure. These methods include:

* load: This method is used to read the data from the file and then set the values of the fields in the data structure.
* save: This method is used to save the data to the file.
* loadFrom: This method is used to load the data from another WebSocket connection instance.
* saveTo: This method is used to save the data to another WebSocket connection instance.
* clear: This method is used to clear the data structure.

Note that this program uses the Protocol Buffers library to define the data structure of the file, which is then used to serialize the data to and from various data types.


```go
var file_transport_internet_websocket_config_proto_depIdxs = []int32{
	0, // 0: v2ray.core.transport.internet.websocket.Config.header:type_name -> v2ray.core.transport.internet.websocket.Header
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_transport_internet_websocket_config_proto_init() }
func file_transport_internet_websocket_config_proto_init() {
	if File_transport_internet_websocket_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_transport_internet_websocket_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Header); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_transport_internet_websocket_config_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_transport_internet_websocket_config_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_transport_internet_websocket_config_proto_goTypes,
		DependencyIndexes: file_transport_internet_websocket_config_proto_depIdxs,
		MessageInfos:      file_transport_internet_websocket_config_proto_msgTypes,
	}.Build()
	File_transport_internet_websocket_config_proto = out.File
	file_transport_internet_websocket_config_proto_rawDesc = nil
	file_transport_internet_websocket_config_proto_goTypes = nil
	file_transport_internet_websocket_config_proto_depIdxs = nil
}

```

# `transport/internet/websocket/connection.go`

这段代码是一个 Go 语言编写的依赖项，用于创建一个 WebSocket 服务器。它包含了一个名为 "websocket" 的包，通过使用 Gorilla-WebSocket 库实现 WebSocket 服务器。

首先，它会使用以下命令进行编译：

go build

接下来，它会生成一个名为 "websocket.confonly" 的文件，这个文件会被持久化到系统的配置文件目录（通常是 $HOME/.config 目录）中。
sql
nano ~/.config/websocket.confonly

在这段注释中，开发者解释了这段代码的作用，它是通过在本地机器上构建一个 WebSocket 服务器，然后让服务器在后台运行，以便在本地机器上测试 WebSocket 服务器。它使用 Gorilla-WebSocket 库来实现 WebSocket 服务器，然后将 WebSocket 服务器导出到一个名为 "websocket.confonly" 的文件中，以便在需要时进行持久化配置。


```go
// +build !confonly

package websocket

import (
	"io"
	"net"
	"time"

	"github.com/gorilla/websocket"
	"v2ray.com/core/common/buf"
	"v2ray.com/core/common/errors"
	"v2ray.com/core/common/serial"
)

```

这段代码定义了一个名为`newConnection`的函数，它接受两个参数：一个`websocket.Conn`类型的变量`conn`和一个`net.Addr`类型的变量`remoteAddr`。

该函数首先创建一个名为`_buf.Writer`的缓冲区，然后将其赋值为`(*connection)(nil)`，这里`nil`是一个代表`nil`值的特殊类型。

接下来，该函数内部创建一个名为`connection`的匿名结构体，该结构体包含一个`websocket.Conn`类型的变量`conn`，一个`io.Reader`类型的变量`reader`和一个`net.Addr`类型的变量`remoteAddr`。

最后，该函数返回一个指向`connection`结构体的指针。


```go
var (
	_ buf.Writer = (*connection)(nil)
)

// connection is a wrapper for net.Conn over WebSocket connection.
type connection struct {
	conn       *websocket.Conn
	reader     io.Reader
	remoteAddr net.Addr
}

func newConnection(conn *websocket.Conn, remoteAddr net.Addr) *connection {
	return &connection{
		conn:       conn,
		remoteAddr: remoteAddr,
	}
}

```

这段代码定义了一个名为`Read`的函数，该函数接收一个`net.Conn`类型的`c`指针和一个字节数组`b`。它的作用是读取`c`连接到目标主机或远程服务器上的数据。

函数内部首先获取一个`net.Reader`类型的`reader`，然后使用该`reader`读取目标字节数组`b`中的数据。如果读取过程中出现错误，函数将返回`0`和相应的错误信息。如果所有的数据读取完成后，连接仍然存在，函数将设置`c.reader`为`nil`，以便在需要时自动关闭连接。

如果错误是由于操作链中的`io.EOF`错误，那么函数将结束读取并关闭连接。


```go
// Read implements net.Conn.Read()
func (c *connection) Read(b []byte) (int, error) {
	for {
		reader, err := c.getReader()
		if err != nil {
			return 0, err
		}

		nBytes, err := reader.Read(b)
		if errors.Cause(err) == io.EOF {
			c.reader = nil
			continue
		}
		return nBytes, err
	}
}

```

该代码定义了两个函数：`func (c *connection) getReader() (io.Reader, error)` 和 `func (c *connection) Write(b []byte) (int, error)`。

第一个函数 `getReader()` 返回一个 `io.Reader` 和一个 `error` 类型的值。它首先检查 `c.reader` 是否已设置，如果没有设置，它将从 `c.conn.NextReader()` 中获得读取器。然后，它将 `c.reader` 和一个 `nil` 值返回。如果设置了一个读取器，它将返回读取器和 `nil`。

第二个函数 `Write()` 返回一个 `int` 和一个 `error` 类型的值。它首先检查 `c.conn.WriteMessage(websocket.BinaryMessage, b)` 是否成功。如果不成功，它将返回 0 和错误。如果成功，它将返回写入的字节数和 `nil`。


```go
func (c *connection) getReader() (io.Reader, error) {
	if c.reader != nil {
		return c.reader, nil
	}

	_, reader, err := c.conn.NextReader()
	if err != nil {
		return nil, err
	}
	c.reader = reader
	return reader, nil
}

// Write implements io.Writer.
func (c *connection) Write(b []byte) (int, error) {
	if err := c.conn.WriteMessage(websocket.BinaryMessage, b); err != nil {
		return 0, err
	}
	return len(b), nil
}

```

这两段代码是go语言中的函数，主要作用是负责连接到websocket服务器，并在客户端和服务器之间进行数据传输。

`func (c *connection) WriteMultiBuffer(mb buf.MultiBuffer) error {
	mb = buf.Compact(mb)
	mb, err := buf.WriteMultiBuffer(c, mb)
	buf.ReleaseMulti(mb)
	return err
}`

该函数接收一个`MultiBuffer`类型的参数，然后执行`WriteMultiBuffer`函数并返回错误。如果执行成功，则调用`buf.ReleaseMulti`函数释放内存。如果执行失败，则返回错误。

`func (c *connection) Close() error {
	var errors []interface{}
	if err := c.conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""), time.Now().Add(time.Second*5)); err != nil {
		errors = append(errors, err)
	}
	if err := c.conn.Close(); err != nil {
		errors = append(errors, err)
	}
	if len(errors) > 0 {
		return newError("failed to close connection").Base(newError(serial.Concat(errors...)))
	}
	return nil
}`

该函数执行关闭连接操作。首先调用`c.conn.WriteControl`并设置`websocket.CloseMessage`并返回。如果执行失败，则调用`c.conn.Close`并返回。如果同时存在错误，则返回一个错误。


```go
func (c *connection) WriteMultiBuffer(mb buf.MultiBuffer) error {
	mb = buf.Compact(mb)
	mb, err := buf.WriteMultiBuffer(c, mb)
	buf.ReleaseMulti(mb)
	return err
}

func (c *connection) Close() error {
	var errors []interface{}
	if err := c.conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""), time.Now().Add(time.Second*5)); err != nil {
		errors = append(errors, err)
	}
	if err := c.conn.Close(); err != nil {
		errors = append(errors, err)
	}
	if len(errors) > 0 {
		return newError("failed to close connection").Base(newError(serial.Concat(errors...)))
	}
	return nil
}

```

这段代码定义了三个函数，分别返回一个名为 connection 的接口的 LocalAddr、RemoteAddr 和 SetDeadline 方法的函数指针。

函数1 `func (c *connection) LocalAddr() net.Addr` 返回一个名为 connection 的接口的 LocalAddr 方法的函数指针，它将调用 c.conn.LocalAddr() 方法返回的地址作为参数，并将其作为 net.Addr 类型的返回值。

函数2 `func (c *connection) RemoteAddr() net.Addr` 返回一个名为 connection 的接口的 RemoteAddr 方法的函数指针，它将调用 c.remoteAddr 属性，返回它的地址作为参数，并将其作为 net.Addr 类型的返回值。

函数3 `func (c *connection) SetDeadline(t time.Time) error` 接受一个名为 t 的时间作为参数，并将 c.SetReadDeadline(t) 和 c.SetWriteDeadline(t) 方法同时设置为 t，如果设置失败，则返回错误。


```go
func (c *connection) LocalAddr() net.Addr {
	return c.conn.LocalAddr()
}

func (c *connection) RemoteAddr() net.Addr {
	return c.remoteAddr
}

func (c *connection) SetDeadline(t time.Time) error {
	if err := c.SetReadDeadline(t); err != nil {
		return err
	}
	return c.SetWriteDeadline(t)
}

```

这两位函数分别设置连接的读写超时时间。

在调用方正确设置超时时，函数将返回状态无错误(no error)。否则，函数将返回一个错误对象。

这两个函数的实现主要围绕时间判断有关。在网络通信中，为了防止连接超时或网络不可用等情况，常常需要设置连接的超时时间。当设置的超时时间过短时，可能会导致一些网络问题，而设置的超时时间过长时，则可能会导致一些应用问题。

函数的实现主要在两个方面：

1. 判断是否设置了一个合理超时时间，并在合理的时间范围内设置。
2. 如果设置的时间过短或过高，则会抛出一个错误，以便用户能够正确地理解错误的原因。


```go
func (c *connection) SetReadDeadline(t time.Time) error {
	return c.conn.SetReadDeadline(t)
}

func (c *connection) SetWriteDeadline(t time.Time) error {
	return c.conn.SetWriteDeadline(t)
}

```

# `transport/internet/websocket/dialer.go`

这段代码是一个 Go 语言编写的WEBSocket服务器构建脚本，它使用了 Gorilla WebSocket库。其作用是构建一个 HTTP 服务器，监听在本地 8080 端口上，等待客户端连接，并使用 HTTP 方法 /ws 连接到客户端的推送通知。

具体来说，这段代码做了以下几件事情：

1. 导入了 Gorilla WebSocket、time、net 和 tls 包，这些包分别用于 WebSocket 服务器、时间、网络和 TLS 加密。
2. 定义了一个名为 "websocket" 的包，其中定义了一个名为 "WebsocketServer" 的类型，这个类型包含了一些方法，如 "build" 和 "confonly"，以及一个 "CreateTLS" 的函数。
3. 在 "WebsocketServer" 类型的构造函数中，调用了 "CreateTLS" 的函数，生成了一个 TLS 证书，然后将此证书添加到服务器上下文中。
4. 在 "WebsocketServer" 的 "run" 方法中，创建了一个 HTTP 的上下文，然后使用上下文的 "StartRing" 方法启动服务器，使用 HTTP 方法 /ws 监听客户端的连接请求。
5. 在 "WebsocketServer" 的 "handleMessage" 方法中，接收到客户端推送的 WebSocket 消息时，解析消息并执行相应的操作，如推送消息、发送消息给服务器等。

这段代码的作用是构建一个 HTTP WebSocket 服务器，用于接收客户端推送的 WebSocket 消息，实现了一个简单的聊天应用。


```go
// +build !confonly

package websocket

import (
	"context"
	"time"

	"github.com/gorilla/websocket"
	"v2ray.com/core/common"
	"v2ray.com/core/common/net"
	"v2ray.com/core/common/session"
	"v2ray.com/core/transport/internet"
	"v2ray.com/core/transport/internet/tls"
)

```

该代码定义了一个名为Dial的函数，它 dials a WebSocket connection to the given destination。函数的第一个参数是一个上下文表示器，第二个参数是要连接的目标网络目标，第三个参数是流设置结构体。如果初始化成功，该函数将调用dialWebsocket函数来创建与目标目标的WebSocket连接，并在成功连接后返回该连接。如果出现错误，函数将返回一个错误对象。

函数首先创建一个错误并将其写入到session.ExportIDToError上下文中。然后使用dialWebsocket函数尝试创建与目标目标的WebSocket连接。如果调用该函数时出现错误，函数将返回一个错误对象，并将其传递给dialWebsocket函数。如果调用dialWebsocket函数成功，函数将通过该连接创建一个internet.Connection对象，并将其返回。如果初始化成功，函数将返回 nil，否则将返回一个错误对象。


```go
// Dial dials a WebSocket connection to the given destination.
func Dial(ctx context.Context, dest net.Destination, streamSettings *internet.MemoryStreamConfig) (internet.Connection, error) {
	newError("creating connection to ", dest).WriteToLog(session.ExportIDToError(ctx))

	conn, err := dialWebsocket(ctx, dest, streamSettings)
	if err != nil {
		return nil, newError("failed to dial WebSocket").Base(err)
	}
	return internet.Connection(conn), nil
}

func init() {
	common.Must(internet.RegisterTransportDialer(protocolName, Dial))
}

```

该函数使用Go标准库中的websocket包和tls包，实现了一个能够连接到远程服务器并获取实时数据的场景。其作用如下：

1. 创建一个名为`dialWebsocket`的函数，接受一个上下文`ctx`、一个目标网络`dest`和一个流设置`streamSettings`，并返回一个网络连接`conn`和一个错误`err`。
2. 函数内部首先创建一个名为`wsSettings`的变量，该变量是一个`streamSettings.ProtocolSettings`类型的变量，该类型代表设置了一次HTTP协议的WebSocket协议设置。
3. 接下来，函数内部创建一个名为`dialer`的变量，该变量是一个`websocket.Dialer`类型的变量，内部包含一个网络连接的拨号函数，用于在接收到数据时创建一个新的网络连接。该函数的第一个参数是一个网络协议，第二个参数是一个目标地址，第三个参数是一个流设置，第四个参数是一个表示超时时间的参数。
4. 然后，函数内部根据设置的`protocol`参数，使用`tls.ConfigFromStreamSettings`函数从`streamSettings`中读取并设置TLS客户端配置，其中`tls.WithDestination`函数用于将目标地址添加到`tlsClientConfig`中，而`tls.WithNextProto`函数用于设置HTTP协议的下一版本。
5. 接下来，函数内部根据设置的`protocol`参数，以及目标地址和端口的当前设置，创建一个URI，该URI将用于连接到远程服务器。
6. 最后，函数内部使用`dialer.Dial`函数尝试连接到URI，并返回一个网络连接`conn`和一个错误`err`。如果连接建立成功，函数内部使用`newConnection`函数返回一个新的网络连接，并将当前的远程地址作为参数传递给该函数。如果连接建立失败，函数内部使用`newError`函数返回一个错误，并使用提供给定的错误消息和当前错误。


```go
func dialWebsocket(ctx context.Context, dest net.Destination, streamSettings *internet.MemoryStreamConfig) (net.Conn, error) {
	wsSettings := streamSettings.ProtocolSettings.(*Config)

	dialer := &websocket.Dialer{
		NetDial: func(network, addr string) (net.Conn, error) {
			return internet.DialSystem(ctx, dest, streamSettings.SocketSettings)
		},
		ReadBufferSize:   4 * 1024,
		WriteBufferSize:  4 * 1024,
		HandshakeTimeout: time.Second * 8,
	}

	protocol := "ws"

	if config := tls.ConfigFromStreamSettings(streamSettings); config != nil {
		protocol = "wss"
		dialer.TLSClientConfig = config.GetTLSConfig(tls.WithDestination(dest), tls.WithNextProto("http/1.1"))
	}

	host := dest.NetAddr()
	if (protocol == "ws" && dest.Port == 80) || (protocol == "wss" && dest.Port == 443) {
		host = dest.Address.String()
	}
	uri := protocol + "://" + host + wsSettings.GetNormalizedPath()

	conn, resp, err := dialer.Dial(uri, wsSettings.GetRequestHeader())
	if err != nil {
		var reason string
		if resp != nil {
			reason = resp.Status
		}
		return nil, newError("failed to dial to (", uri, "): ", reason).Base(err)
	}

	return newConnection(conn, conn.RemoteAddr()), nil
}

```

# `transport/internet/websocket/errors.generated.go`

这段代码定义了一个名为 "websocket" 的包，它包含了以下内容：

1. 导入 "v2ray.com/core/common/errors" 包以从该包中导入 errors。
2. 定义了一个名为 "errPathObjHolder" 的结构体，它包含一个空的字符串字段。
3. 定义了一个名为 "newError" 的函数，该函数接收一个或多个参数（可以是任意类型），然后创建一个错误对象并将其与一个 errPathObjHolder 类型的对象进行关联。最后，使用 errors.New() 函数创建一个带有时钟对象（可能是指错误对象的时钟）的错误，并将其与 errPathObjHolder 类型的对象进行关联。

这段代码的主要目的是提供在遇到错误时回传一个错误对象，该对象包含了错误的相关信息，如错误类型、错误消息和错误堆栈等。通过调用该函数，可以在程序中捕获和处理错误，使代码更加健壮和鲁棒。


```go
package websocket

import "v2ray.com/core/common/errors"

type errPathObjHolder struct{}

func newError(values ...interface{}) *errors.Error {
	return errors.New(values...).WithPathObj(errPathObjHolder{})
}

```

# `transport/internet/websocket/hub.go`

这段代码是一个 Go 语言编写的 Websocket 库，它的作用是实现与服务器之间的通信。它包含了以下功能：

1. 定义了一个名为 "websocket" 的包。
2. 导入了 "context"、"crypto/tls"、"net/http" 和 "sync" 包。
3. 定义了一个名为 "websocketImpl" 的函数，它的作用是创建一个 Websocket 连接。
4. 调用 "websocketImpl" 函数，并传入以下参数：
	* 上下文对象（与 gRUla WebSocket 库中的不同，这里可能用于某些其他目的）
	* 鉴权信息（如果使用 HTTPS，需要传递此值，否则不需要传递）
	* WebSocket 目标 URI（可选，但建议使用实际的 URI，而不是 IP 地址和端口号）
	* 设置连接时间间隔以及是否启用确认消息。
	* 会话超时时间（可选，单位为毫秒，默认为 30 秒）
	* 设置服务器发送消息的最大数量以及单位（可选，单位为字节，默认为 1024）
	* 设置发送消息的最低大小以及单位（可选，单位为字节，默认为 1024）
	* 设置 TLS 证书来源（可选，可以是本地文件或一个提供者，例如 n招商发展有限公司）
	* 如果使用 TLS，那么启用 TLS 证书自动检测。
	* 设置 WebSocket 类型（可选，值可以是 "wss" 或 "ws"，默认值为 "ws")
2. 导入 "github.com/gorilla/websocket" 和 "github.com/pires/go-proxyproto"，用于与 WebSocket 服务器通信。
3. 导入 "v2ray.com/core/common/net"，用于与客户端的网络通信。
4. 导入 "v2ray.com/core/common/session"，用于会话同步和管理。
5. 导入 "v2ray.com/core/transport/internet"，用于与 TLS 证书验证服务器通信。
6. 导入 "v2tls"，用于与 TLS 证书验证服务器通信。


```go
// +build !confonly

package websocket

import (
	"context"
	"crypto/tls"
	"net/http"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"github.com/pires/go-proxyproto"

	"v2ray.com/core/common"
	"v2ray.com/core/common/net"
	http_proto "v2ray.com/core/common/protocol/http"
	"v2ray.com/core/common/session"
	"v2ray.com/core/transport/internet"
	v2tls "v2ray.com/core/transport/internet/tls"
)

```

该代码定义了一个名为 requestHandler 的 struct 类型，它包含一个路径 string 和一个指向 listener 的指针ln。

接着定义了一个名为 upgrading 的函数，它是一个 websocket.Upgrader 类型的实例，具有读取缓冲区大小 4194、写入缓冲区大小 4194 和握手超时时间 4 秒等功能。

在 ServeHTTP 函数中，首先检查请求的路径是否与给出的路径相同，如果不相同，则向http.ResponseNotFound发送一个错误消息并返回。

接着使用 Upgrader.Upgrade函数将 websocket 升级到新的连接，如果升级成功，则将连接添加到上下文（handler）中。注意，在添加连接时，使用了新的net.TCPAddr类型来获取 remoteAddr 字段。

最后，在 ServeHTTP 的结尾，将上下文中的连接添加到上下文上下文中，这样就可以处理 HTTP 和 WebSocket 连接。


```go
type requestHandler struct {
	path string
	ln   *Listener
}

var upgrader = &websocket.Upgrader{
	ReadBufferSize:   4 * 1024,
	WriteBufferSize:  4 * 1024,
	HandshakeTimeout: time.Second * 4,
	CheckOrigin: func(r *http.Request) bool {
		return true
	},
}

func (h *requestHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {
	if request.URL.Path != h.path {
		writer.WriteHeader(http.StatusNotFound)
		return
	}
	conn, err := upgrader.Upgrade(writer, request, nil)
	if err != nil {
		newError("failed to convert to WebSocket connection").Base(err).WriteToLog()
		return
	}

	forwardedAddrs := http_proto.ParseXForwardedFor(request.Header)
	remoteAddr := conn.RemoteAddr()
	if len(forwardedAddrs) > 0 && forwardedAddrs[0].Family().IsIP() {
		remoteAddr.(*net.TCPAddr).IP = forwardedAddrs[0].IP()
	}

	h.ln.addConn(newConnection(conn, remoteAddr))
}

```

This is a Go function that creates a TCP listener for a WebSocket server. The function takes several parameters, including the IP address and port of the WebSocket server, the port settings, and the settings of the TCP stream settings.

The function starts by creating a TCP listener on the IP address and port of the WebSocket server, and then sets up a connection to the server using the TCP stream settings.

If an error occurs while listening for the WebSocket server, the function returns an error and includes a new warning in the log.

If the WebSocket server is accepting a proxy protocol, the function creates a TCP listener that accepts the PROXY protocol and returns a Proxy policy and an error in the log.

If the WebSocket server is not accepting a proxy protocol, the function creates a TCP listener that accepts the PROXY protocol and returns a Proxy policy and an error in the log.

The function uses a variable to store the WebSocket server and another variable to store the settings of the TCP stream.

The function uses the v2tls.


```go
type Listener struct {
	sync.Mutex
	server   http.Server
	listener net.Listener
	config   *Config
	addConn  internet.ConnHandler
}

func ListenWS(ctx context.Context, address net.Address, port net.Port, streamSettings *internet.MemoryStreamConfig, addConn internet.ConnHandler) (internet.Listener, error) {
	listener, err := internet.ListenSystem(ctx, &net.TCPAddr{
		IP:   address.IP(),
		Port: int(port),
	}, streamSettings.SocketSettings)
	if err != nil {
		return nil, newError("failed to listen TCP(for WS) on", address, ":", port).Base(err)
	}
	newError("listening TCP(for WS) on ", address, ":", port).WriteToLog(session.ExportIDToError(ctx))

	wsSettings := streamSettings.ProtocolSettings.(*Config)

	if wsSettings.AcceptProxyProtocol {
		policyFunc := func(upstream net.Addr) (proxyproto.Policy, error) { return proxyproto.REQUIRE, nil }
		listener = &proxyproto.Listener{Listener: listener, Policy: policyFunc}
		newError("accepting PROXY protocol").AtWarning().WriteToLog(session.ExportIDToError(ctx))
	}

	if config := v2tls.ConfigFromStreamSettings(streamSettings); config != nil {
		if tlsConfig := config.GetTLSConfig(); tlsConfig != nil {
			listener = tls.NewListener(listener, tlsConfig)
		}
	}

	l := &Listener{
		config:   wsSettings,
		addConn:  addConn,
		listener: listener,
	}

	l.server = http.Server{
		Handler: &requestHandler{
			path: wsSettings.GetNormalizedPath(),
			ln:   l,
		},
		ReadHeaderTimeout: time.Second * 4,
		MaxHeaderBytes:    2048,
	}

	go func() {
		if err := l.server.Serve(l.listener); err != nil {
			newError("failed to serve http for WebSocket").Base(err).AtWarning().WriteToLog(session.ExportIDToError(ctx))
		}
	}()

	return l, err
}

```

该代码定义了一个名为Addr的实现了net.Listener.Addr接口的监听器。Addr接口定义了监听器的一些基本属性和方法，如Addr().Close().

具体来说，代码中实现了一个名为ln的监听器对象，它包含两个方法：Addr()和Close().

Addr()方法的实现方式如下：


ln.listener.Addr()


这个方法调用了被监听的传输层的Addr().函数，用来获取被监听的TCP套接字上监听的源地址。

Close()方法的实现方式如下：


ln.listener.Close()


这个方法调用了被监听的传输层的Close().函数，用来关闭被监听的TCP套接字。

最后，代码中还实现了一个名为init的函数，该函数注册了一个基于网络的监听器。通过调用该函数，可以实现对目标网络的监听，并获取目标网络中的数据报。


```go
// Addr implements net.Listener.Addr().
func (ln *Listener) Addr() net.Addr {
	return ln.listener.Addr()
}

// Close implements net.Listener.Close().
func (ln *Listener) Close() error {
	return ln.listener.Close()
}

func init() {
	common.Must(internet.RegisterTransportListener(protocolName, ListenWS))
}

```

# `transport/internet/websocket/ws.go`

这段代码定义了一个名为 "websocket" 的包，该包实现了一个名为 "Websocket" 的传输协议，其功能是实现一个 HTTP(S) 兼容的、具有可观察性证明的传输方法，具有合理否认性。

具体来说，该传输协议允许客户端与服务器之间建立安全、可靠的连接，并允许客户端发送实时数据给服务器。由于该传输协议是 HTTP(S) 兼容的，因此它可以在 HTTP 应用程序中无缝运行，而不需要进行任何修改。

此外，该传输协议具有可观察性证明，这意味着客户端可以得到一个证明，证明服务器接收到了客户端发送的数据。这对于安全应用程序非常有用，因为它允许客户端确定数据是否被正确接收和传输。

最后，该代码还使用了 Go 的包导出功能，用于将导出的函数解析为可执行文件。


```go
/*Package websocket implements Websocket transport

Websocket transport implements an HTTP(S) compliable, surveillance proof transport method with plausible deniability.
*/
package websocket

//go:generate go run v2ray.com/core/common/errors/errorgen

```

# `transport/internet/websocket/ws_test.go`

这段代码是一个 Go 语言编写的测试套件，用于测试 v2ray.com 提供的 WebSocket 功能。具体来说，它包括以下组件：

1. 导入必要的包：
	* "context"
	* "runtime"
	* "testing"
	* "time"
	* "v2ray.com/core/common"
	* "v2ray.com/core/common/net"
	* "v2ray.com/core/common/protocol/tls/cert"
	* "v2ray.com/core/transport/internet"
	* "v2ray.com/core/transport/internet/tls"
	* "v2ray.com/core/transport/internet/websocket"

2. 导入 v2ray.com/core/transport/internet/websocket 包：

3. 定义一个名为 "websocket_test.go" 的函数入口，它将负责测试 v2ray.com/core/transport/internet/websocket 包的功能。

4. 在 "websocket_test.go" 函数入口中，定义了一些变量和函数：

	* 一个名为 "ctx" 的上下文对象，它将在每个测试用例中使用。
	* 一个名为 "transport" 的 v2ray.com/core/transport/internet 包的实例。
	* 一个名为 "cert" 的 v2ray.com/core/common/protocol/tls/cert 包的实例。
	* 一个名为 "net" 的 v2ray.com/core/common/net 包的实例。
	* 一个名为 "tls" 的 v2ray.com/core/transport/internet/tls 包的实例。
	* 一个名为 "websocket" 的 v2ray.com/core/transport/internet/websocket 包的实例。
	* 一个名为 "time" 的 time 包的实例。
	* 一个名为 "httpie" 的 golang.org/x/net/httpie 包的实例。
	* 一个名为 "ctx/ws" 的上下文对象，它将用于在 Websocket 连接中发送消息。

	* 一个名为 "sendMessage" 的函数，它将使用 cert 和 tls 包发送消息。
	* 一个名为 "close" 的函数，它将用于关闭 Websocket 连接。
	* 一个名为 "start" 的函数，它将开始一个 Websocket 连接。
	* 一个名为 "stop" 的函数，它将停止一个 Websocket 连接。

5. 在 "websocket_test.go" 函数入口中，定义了一些测试函数，包括：

	* "TestConnect" 函数，用于测试 Websocket 连接的建立。
	* "TestSendMessage" 函数，用于测试 Websocket 发送消息的功能。
	* "TestClose" 函数，用于测试 Websocket 连接的关闭。
	* "TestStart" 函数，用于测试 Websocket 连接的启动。
	* "TestStop" 函数，用于测试 Websocket 连接的停止。
	* "TestWebsocket" 函数，用于测试 Websocket 的所有功能。

6. 在 "websocket_test.go" 函数入口中，定义了一个名为 "main" 的函数，它将在运行时使用上述定义的函数进行测试。


```go
package websocket_test

import (
	"context"
	"runtime"
	"testing"
	"time"

	"v2ray.com/core/common"
	"v2ray.com/core/common/net"
	"v2ray.com/core/common/protocol/tls/cert"
	"v2ray.com/core/transport/internet"
	"v2ray.com/core/transport/internet/tls"
	. "v2ray.com/core/transport/internet/websocket"
)

```

This appears to be a Go program that sets up a WebSocket connection to a remote server. It uses the "Dial" function from the "net" package to establish a connection to the server, and the "Write" and "Read" functions from the same package to write and read data from the connection, respectively.

The program sets up a streamSettings object to configure the connection, and then enters a loop to receive data from the server. within the loop, it reads data from the server, and then sends a "Response" message back to the server using the "Write" function.

It also includes a section where it reads data from the first connection, and then reads data from the second connection, and then sends a "Response" message back to the server using the "Write" function.

It also includes a Config struct which defines the path to the WebSocket file.

Please note that, this program is a simple example and it may not cover all possible use cases and edge cases, and also this program may not handle errors that may occur during the connection and/or data transfer.


```go
func Test_listenWSAndDial(t *testing.T) {
	listen, err := ListenWS(context.Background(), net.LocalHostIP, 13146, &internet.MemoryStreamConfig{
		ProtocolName: "websocket",
		ProtocolSettings: &Config{
			Path: "ws",
		},
	}, func(conn internet.Connection) {
		go func(c internet.Connection) {
			defer c.Close()

			var b [1024]byte
			_, err := c.Read(b[:])
			if err != nil {
				return
			}

			common.Must2(c.Write([]byte("Response")))
		}(conn)
	})
	common.Must(err)

	ctx := context.Background()
	streamSettings := &internet.MemoryStreamConfig{
		ProtocolName:     "websocket",
		ProtocolSettings: &Config{Path: "ws"},
	}
	conn, err := Dial(ctx, net.TCPDestination(net.DomainAddress("localhost"), 13146), streamSettings)

	common.Must(err)
	_, err = conn.Write([]byte("Test connection 1"))
	common.Must(err)

	var b [1024]byte
	n, err := conn.Read(b[:])
	common.Must(err)
	if string(b[:n]) != "Response" {
		t.Error("response: ", string(b[:n]))
	}

	common.Must(conn.Close())
	<-time.After(time.Second * 5)
	conn, err = Dial(ctx, net.TCPDestination(net.DomainAddress("localhost"), 13146), streamSettings)
	common.Must(err)
	_, err = conn.Write([]byte("Test connection 2"))
	common.Must(err)
	n, err = conn.Read(b[:])
	common.Must(err)
	if string(b[:n]) != "Response" {
		t.Error("response: ", string(b[:n]))
	}
	common.Must(conn.Close())

	common.Must(listen.Close())
}

```

该代码使用了go-sql-driver库来测试WebSocket连接。具体来说，该代码实现了以下功能：

1. 定义了一个名为TestDialWithRemoteAddr的函数，该函数接受一个测试场景作为参数，并在函数内部使用ListenWS函数监听来自本地主机的IP地址13148的WebSocket连接，然后通过Dial函数与远程主机连接并发送数据。
2. TestDialWithRemoteAddr函数的具体实现包括以下步骤：
a. 使用ListenWS函数监听来自本地主机的IP地址13148的WebSocket连接，并返回一个监听器错误和一个Internet连接错误。
b. 通过Dial函数与远程主机连接，并发送一个"Test connection 1"数据到远程主机。
c. 通过Internet. MemoryStreamConfig结构体中的path参数，指定数据从连接中读取的内容。
d. 通过Internet. Connection实现的Write和Read方法，向远程主机发送数据并读取数据。
3. 在函数内部，变量b是一个1024字节的缓冲区，用于存储从远程主机接收到的数据。
4. 如果函数内部在Dial或ListenWS函数中发生错误，则会关闭连接并打印错误信息，以便于调试。


```go
func TestDialWithRemoteAddr(t *testing.T) {
	listen, err := ListenWS(context.Background(), net.LocalHostIP, 13148, &internet.MemoryStreamConfig{
		ProtocolName: "websocket",
		ProtocolSettings: &Config{
			Path: "ws",
		},
	}, func(conn internet.Connection) {
		go func(c internet.Connection) {
			defer c.Close()

			var b [1024]byte
			_, err := c.Read(b[:])
			//common.Must(err)
			if err != nil {
				return
			}

			_, err = c.Write([]byte("Response"))
			common.Must(err)
		}(conn)
	})
	common.Must(err)

	conn, err := Dial(context.Background(), net.TCPDestination(net.DomainAddress("localhost"), 13148), &internet.MemoryStreamConfig{
		ProtocolName:     "websocket",
		ProtocolSettings: &Config{Path: "ws", Header: []*Header{{Key: "X-Forwarded-For", Value: "1.1.1.1"}}},
	})

	common.Must(err)
	_, err = conn.Write([]byte("Test connection 1"))
	common.Must(err)

	var b [1024]byte
	n, err := conn.Read(b[:])
	common.Must(err)
	if string(b[:n]) != "Response" {
		t.Error("response: ", string(b[:n]))
	}

	common.Must(listen.Close())
}

```

该代码旨在测试一个名为“Test_listenWSAndDial_TLS”的函数，以验证它是否正确地监听WebSocket并连接到TLS服务器。

以下是代码的功能：

1. 如果当前运行时架构（GOARCH）是arm64，那么函数将直接返回，因为该架构已经支持TLS。
2. 设置WebSocket流设置，包括协议名称（websocket）和安全类型（TLS）。
3. 监听WS端口，并等待客户端连接。当客户端连接时，函数内部的一个处理函数会继续监听连接，以便在客户端关闭时执行。
4. 使用Dial函数连接到TLS服务器。在连接成功后，函数将关闭连接并返回。
5. 测试函数将在收到客户端发送的数据时继续运行，即使客户端已经关闭。
6. 如果函数在等待5秒钟后仍未收到客户端数据，则会错误地判断客户端连接到服务器的最长时间。

函数的输入参数为：

- t：测试.追踪（Testing）对象。
- *testing.T：当函数正在被测试时，它接收的测试套件。

函数的时间局部变量为：

- start：客户端连接到服务器的时间。
- end：客户端关闭或连接终止的时间。


```go
func Test_listenWSAndDial_TLS(t *testing.T) {
	if runtime.GOARCH == "arm64" {
		return
	}

	start := time.Now()

	streamSettings := &internet.MemoryStreamConfig{
		ProtocolName: "websocket",
		ProtocolSettings: &Config{
			Path: "wss",
		},
		SecurityType: "tls",
		SecuritySettings: &tls.Config{
			AllowInsecure: true,
			Certificate:   []*tls.Certificate{tls.ParseCertificate(cert.MustGenerate(nil, cert.CommonName("localhost")))},
		},
	}
	listen, err := ListenWS(context.Background(), net.LocalHostIP, 13143, streamSettings, func(conn internet.Connection) {
		go func() {
			_ = conn.Close()
		}()
	})
	common.Must(err)
	defer listen.Close()

	conn, err := Dial(context.Background(), net.TCPDestination(net.DomainAddress("localhost"), 13143), streamSettings)
	common.Must(err)
	_ = conn.Close()

	end := time.Now()
	if !end.Before(start.Add(time.Second * 5)) {
		t.Error("end: ", end, " start: ", start)
	}
}

```

# `transport/internet/xtls/config.go`

这段代码是一个Go语言编写的命令行工具，用于将指定的证书（CA或受信任的CA）导出为镜像文件，并将其传输到本地。工具名称为“xtls”或“xtls-cli”。

具体来说，这段代码实现了以下功能：

1. 从主服务器下载证书（CA或受信任的CA）并写入到名为“cert.txt”的文件中。
2. 将下载的证书导出为镜像文件（.tls)，并将其保存到本地仓库的“/cert/”目录中。
3. 创建一个名为“confonly”的文件夹，并在其中创建一个名为“xtls.conf”的配置文件。
4. 如果本地仓库中不存在名为“confonly”的文件夹，则创建该文件夹。

这段代码使用了以下依赖：

* Go 语言编译器（build）
* Go标准库中的 "sync" 和 "time" 包
* xtls库（github.com/xtls/go）
* v2ray.com 库（用于与 V2Ray 服务器通信）


```go
// +build !confonly

package xtls

import (
	"crypto/x509"
	"sync"
	"time"

	xtls "github.com/xtls/go"

	"v2ray.com/core/common/net"
	"v2ray.com/core/common/protocol/tls/cert"
	"v2ray.com/core/transport/internet"
)

```

这段代码定义了一个名为 "var" 的变量，它是一个包含一个名为 "globalSessionCache" 的一个名为 "xtls.NewLRUClientSessionCache" 的函数的指针类型。

接着，定义了一个名为 "ParseCertificate" 的函数，它接受一个名为 "c" 的名为 "cert.Certificate" 的参数，并将其转换为名为 "Certificate" 的类型。这个函数将 cert.Certificate 的二进制数据转换为 PEM 格式的数据，并将结果存储在名为 "certPEM" 的变量中。接着，将 PEM 格式的数据中的证书存储在一个名为 "keyPEM" 的变量中，最后返回一个名为 "Certificate" 的类型，包含了证书和私钥。

然后，定义了一个名为 "loadSelfCertPool" 的函数，它接受一个名为 "c" 的名为 "Config" 的参数，并返回一个名为 "x509.CertPool" 的类型和一个名为 "error" 的类型的变量。这个函数查找本地计算机上所有根证书颁发机构(CA)的证书，并将它们存储在一个名为 "root" 的名为 "x509.CertPool" 的类型的变量中。如果查找失败，它将返回一个名为 "error" 的类型的变量，并记录错误信息。

最后，通过 "globalSessionCache" 函数获取一个 "xtls.NewLRUClientSessionCache" 的实例，并将其存储在 "globalSessionCache" 变量中，用于存储客户端会话的信息。


```go
var (
	globalSessionCache = xtls.NewLRUClientSessionCache(128)
)

// ParseCertificate converts a cert.Certificate to Certificate.
func ParseCertificate(c *cert.Certificate) *Certificate {
	certPEM, keyPEM := c.ToPEM()
	return &Certificate{
		Certificate: certPEM,
		Key:         keyPEM,
	}
}

func (c *Config) loadSelfCertPool() (*x509.CertPool, error) {
	root := x509.NewCertPool()
	for _, cert := range c.Certificate {
		if !root.AppendCertsFromPEM(cert.Certificate) {
			return nil, newError("failed to append cert").AtWarning()
		}
	}
	return root, nil
}

```

这段代码定义了一个名为`BuildCertificates`的函数，该函数的作用是从接口定义中构建一个包含TLS证书的列表。函数接收一个`Config`类型的参数，并在函数内部创建一个空的TLS证书列表。

函数内部循环遍历`Certificate`类型的字段，如果该字段的`Usage`不等于`Certificate_ENCIPHERMENT`，则说明该证书是一个加密证书，需要将其添加到生成的证书列表中。接着，函数使用`xtls.X509KeyPair`函数从证书中提取公钥，并将提取得到的密钥对生成的证书进行签名，将签名后的证书添加到生成的证书列表中。

最后，函数返回生成的证书列表。


```go
// BuildCertificates builds a list of TLS certificates from proto definition.
func (c *Config) BuildCertificates() []xtls.Certificate {
	certs := make([]xtls.Certificate, 0, len(c.Certificate))
	for _, entry := range c.Certificate {
		if entry.Usage != Certificate_ENCIPHERMENT {
			continue
		}
		keyPair, err := xtls.X509KeyPair(entry.Certificate, entry.Key)
		if err != nil {
			newError("ignoring invalid X509 key pair").Base(err).AtWarning().WriteToLog()
			continue
		}
		certs = append(certs, keyPair)
	}
	return certs
}

```

该代码定义了两个函数：isCertificateExpired 和 issueCertificate。

isCertificateExpired 的作用是检查给定的证书是否过期。它接收一个 xtls.Certificate 类型的参数 c，并检查 c 的叶子节点是否为空，以及 c 中证书的长度是否大于零。然后，它尝试使用 x509.ParseCertificate 函数解析 c 中的第一个证书，并将其存储在 c.Leaf 中。如果解析成功，则函数的返回值为 true，否则返回 false。

issueCertificate 的作用是颁发一个新的证书。它接收一个 Certificate 类型的参数 rawCA，以及一个域名参数 domain。它首先尝试使用 cert.ParseCertificate 函数解析 rawCA 中的证书，并获取其根节点。然后，它使用 cert.Generate 函数生成一个新的证书，该证书使用该根节点作为其根节点，并在新的证书中指定给定的域名。最后，它将新证书转换为 PEM 格式并返回。如果在这个过程中出现错误，该函数将返回一个 error。


```go
func isCertificateExpired(c *xtls.Certificate) bool {
	if c.Leaf == nil && len(c.Certificate) > 0 {
		if pc, err := x509.ParseCertificate(c.Certificate[0]); err == nil {
			c.Leaf = pc
		}
	}

	// If leaf is not there, the certificate is probably not used yet. We trust user to provide a valid certificate.
	return c.Leaf != nil && c.Leaf.NotAfter.Before(time.Now().Add(-time.Minute))
}

func issueCertificate(rawCA *Certificate, domain string) (*xtls.Certificate, error) {
	parent, err := cert.ParseCertificate(rawCA.Certificate, rawCA.Key)
	if err != nil {
		return nil, newError("failed to parse raw certificate").Base(err)
	}
	newCert, err := cert.Generate(parent, cert.CommonName(domain), cert.DNSNames(domain))
	if err != nil {
		return nil, newError("failed to generate new certificate for ", domain).Base(err)
	}
	newCertPEM, newKeyPEM := newCert.ToPEM()
	cert, err := xtls.X509KeyPair(newCertPEM, newKeyPEM)
	return &cert, err
}

```

This is a Go function called `IssueCertificate` that takes in a certificate authority (CA) certificate and a domain name to create a certificate for. It uses the `xtls` package to perform the following steps:

1. If the certificate authority certificate is valid and has not expired, the function returns the certificate and nil.
2. If the certificate has expired, the function checks if any of the certificates in the current CA is valid and not expired. If a valid certificate is found, the function returns the certificate, and if not, it sets the `certExpired` flag and returns nil.
3. If the certificate has expired, the function creates a new set of certificates and sets the `issuedCertificate` to the first in the new set.
4. The function then creates the certificate's name in the certificate by calling the `BuildNameToCertificate` function.
5. Finally, the function unlocks the certificate and returns it.

It is important to note that the function assumes that the CA certificate has not expired and that the `BuildNameToCertificate` function is defined and implemented properly.


```go
func (c *Config) getCustomCA() []*Certificate {
	certs := make([]*Certificate, 0, len(c.Certificate))
	for _, certificate := range c.Certificate {
		if certificate.Usage == Certificate_AUTHORITY_ISSUE {
			certs = append(certs, certificate)
		}
	}
	return certs
}

func getGetCertificateFunc(c *xtls.Config, ca []*Certificate) func(hello *xtls.ClientHelloInfo) (*xtls.Certificate, error) {
	var access sync.RWMutex

	return func(hello *xtls.ClientHelloInfo) (*xtls.Certificate, error) {
		domain := hello.ServerName
		certExpired := false

		access.RLock()
		certificate, found := c.NameToCertificate[domain]
		access.RUnlock()

		if found {
			if !isCertificateExpired(certificate) {
				return certificate, nil
			}
			certExpired = true
		}

		if certExpired {
			newCerts := make([]xtls.Certificate, 0, len(c.Certificates))

			access.Lock()
			for _, certificate := range c.Certificates {
				if !isCertificateExpired(&certificate) {
					newCerts = append(newCerts, certificate)
				}
			}

			c.Certificates = newCerts
			access.Unlock()
		}

		var issuedCertificate *xtls.Certificate

		// Create a new certificate from existing CA if possible
		for _, rawCert := range ca {
			if rawCert.Usage == Certificate_AUTHORITY_ISSUE {
				newCert, err := issueCertificate(rawCert, domain)
				if err != nil {
					newError("failed to issue new certificate for ", domain).Base(err).WriteToLog()
					continue
				}

				access.Lock()
				c.Certificates = append(c.Certificates, *newCert)
				issuedCertificate = &c.Certificates[len(c.Certificates)-1]
				access.Unlock()
				break
			}
		}

		if issuedCertificate == nil {
			return nil, newError("failed to create a new certificate for ", domain)
		}

		access.Lock()
		c.BuildNameToCertificate()
		access.Unlock()

		return issuedCertificate, nil
	}
}

```

此代码定义了一个名为 func 的函数，接收一个名为 Config 的 Config 类型的参数。

func (c *Config) parseServerName() string {
   return c.ServerName
}

此函数的作用是获取 Config 中服务器名称的值，如果 Config 中包含此字段，则返回其值，否则返回空字符串。

函数的实现较为复杂，但可以通俗地解释为：首先获取系统根证书，然后根据用户提供的选项，将 Config 中的部分字段指定为相应的选项，接着加载证书根、证书和 FQ DNS，然后验证证书并获取服务器名，最后将服务器名添加到 Config 中。

函数的实现使用了多态技术，因为通过参数传递不同的选项，可以覆盖掉 Config 中可能存在的同名字段，从而避免了可能的编译错误。


```go
func (c *Config) parseServerName() string {
	return c.ServerName
}

// GetXTLSConfig converts this Config into xtls.Config.
func (c *Config) GetXTLSConfig(opts ...Option) *xtls.Config {
	root, err := c.getCertPool()
	if err != nil {
		newError("failed to load system root certificate").AtError().Base(err).WriteToLog()
	}

	config := &xtls.Config{
		ClientSessionCache:     globalSessionCache,
		RootCAs:                root,
		InsecureSkipVerify:     c.AllowInsecure,
		NextProtos:             c.NextProtocol,
		SessionTicketsDisabled: c.DisableSessionResumption,
	}
	if c == nil {
		return config
	}

	for _, opt := range opts {
		opt(config)
	}

	config.Certificates = c.BuildCertificates()
	config.BuildNameToCertificate()

	caCerts := c.getCustomCA()
	if len(caCerts) > 0 {
		config.GetCertificate = getGetCertificateFunc(config, caCerts)
	}

	if sn := c.parseServerName(); len(sn) > 0 {
		config.ServerName = sn
	}

	if len(config.NextProtos) == 0 {
		config.NextProtos = []string{"h2", "http/1.1"}
	}

	return config
}

```

这段代码定义了三个函数，它们都是用来设置 XTLS 配置选项的。

第一个函数是`WithOption`，它接收一个`Option`类型的参数，并在其中设置指定的选项。

第二个函数是`WithDestination`，它接收一个`net.Destination`类型的参数，并在其中设置服务器名称。具体来说，如果服务器名称在配置中没有设置，则将其设置为服务器地址的域名。

第三个函数是`WithNextProtocol`，它接收一个或多个`string`类型的参数，并在其中设置 ALPN 值。ALPN 是一种定义了第二层协议（如 TLS 1.1）中可选协议的选项，通过在 ALPN 字段中指定这些协议来允许使用其他库或实现。

这些函数都是 optional（可选的）的，因为它们都基于接收者（也就是 `xtls.Config` 类型）的设置。通过调用这些函数，可以改变 XTLS 配置选项的设置，从而影响加密和解密数据的安全性。


```go
// Option for building XTLS config.
type Option func(*xtls.Config)

// WithDestination sets the server name in XTLS config.
func WithDestination(dest net.Destination) Option {
	return func(config *xtls.Config) {
		if dest.Address.Family().IsDomain() && config.ServerName == "" {
			config.ServerName = dest.Address.Domain()
		}
	}
}

// WithNextProto sets the ALPN values in XTLS config.
func WithNextProto(protocol ...string) Option {
	return func(config *xtls.Config) {
		if len(config.NextProtos) == 0 {
			config.NextProtos = protocol
		}
	}
}

```

这段代码定义了一个名为 `ConfigFromStreamSettings` 的函数，它接受一个名为 `settings` 的互联网 `MemoryStreamConfig` 类型的参数。

如果 `settings` 为空，函数返回一个 `nil` 值。否则，函数在返回值中使用 `if` 语句检查 `settings` 是否为 `nil`，如果是，则返回 `nil`。否则，函数将 `settings` 的 `SecuritySettings` 属性的值拷贝到一个名为 `config` 的 `Config` 类型的变量中，并返回该 `config` 类型的变量。

这段代码的作用是获取一个 `internet.MemoryStreamConfig` 类型的参数，并根据设置在该参数中的stream settings获取一个配置，如果无法获取，则返回 `nil`。


```go
// ConfigFromStreamSettings fetches Config from stream settings. Nil if not found.
func ConfigFromStreamSettings(settings *internet.MemoryStreamConfig) *Config {
	if settings == nil {
		return nil
	}
	config, ok := settings.SecuritySettings.(*Config)
	if !ok {
		return nil
	}
	return config
}

```