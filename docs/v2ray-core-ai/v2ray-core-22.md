# v2ray-core源码解析 22

# `common/log/log.pb.go`

该代码是一个 Go 语言编程语言中的接口，定义了名为 "log" 的包。通过 protoc-gen-go 工具，从输入的 ".proto" 文件自动生成 Go 代码。这段代码中定义了一个名为 "log.proto" 的消息类型，该类型定义了 "log" 包的内容。

具体来说，这段代码中定义了一个名为 "log" 的包，该包中定义了一个名为 "log.proto" 的消息类型。这个消息类型定义了 "log" 包的输入和输出，以及该包中方法的一些基本属性和方法。

然后，该代码中定义了一些来自 protoc-gen-go 的函数和变量，用于将 "log.proto" 消息类型与 Go 语言中的 "log" 包进行关联。最后，该代码中定义了一些名为 "reflect" 和 "sync" 的包，用于在 "log" 包中声明一些通用的同步和反射方法。


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: common/log/log.proto

package log

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

```

这段代码是一个工具函数，它包含两个变量，一个是一个名为 _ 的常量，另一个是一个名为 Severity 的枚举类型。

const _: protoimpl.EnforceVersion<20 - protoimpl.MinVersion>是一个编译时检查，用于确保生成的代码足够更新，以至于与当前流行的定义相符。

const _: protoimpl.EnforceVersion<protoimpl.MaxVersion - 20>也是一个编译时检查，用于确保生成的代码足够更新，以至于与当前流行的定义相符。

const _ = proto.ProtoPackageIsVersion4 是一个编译时检查，用于确保运行时使用的proto package版本4足够更新，以至于与当前流行的定义相符。

另外， Severity 是一个名为 Severity 的枚举类型，它定义了不同级别的错误、警告、信息、调试等级别。这些枚举类型可能用于检查是否支持某种特定的设置，或者根据某种情况返回一个特定级别的消息。但是，对于这些信息，没有提供进一步的上下文，因此无法确定具体使用场景。


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Severity int32

const (
	Severity_Unknown Severity = 0
	Severity_Error   Severity = 1
	Severity_Warning Severity = 2
	Severity_Info    Severity = 3
	Severity_Debug   Severity = 4
)

```

这段代码定义了一个名为 "Severity" 的枚举类型，并定义了与该枚举类型对应的 severity 名称和值：

- severity 名称地图：{0: "Unknown", 1: "Error", 2: "Warning", 3: "Info", 4: "Debug"}
- severity 值地图：{0: 0, 1: 1, 2: 2, 3: 3, 4: 4}

这个代码定义了四个不同的 severity 等级，并为每个等级定义了一个唯一的名称。severity 枚举类型有两个成员变量，分别对应 severity 名称和 severity 值。通过 map 函数将 severity 名称转换为整数类型，使用 0 作为键，将 severity 值转换为整数类型，使用成员变量 Severity_value 的键。


```go
// Enum value maps for Severity.
var (
	Severity_name = map[int32]string{
		0: "Unknown",
		1: "Error",
		2: "Warning",
		3: "Info",
		4: "Debug",
	}
	Severity_value = map[string]int32{
		"Unknown": 0,
		"Error":   1,
		"Warning": 2,
		"Info":    3,
		"Debug":   4,
	}
)

```

这段代码定义了一个名为 "func" 的函数，它接受一个整数参数 "x"，并返回一个 "Severity" 类型的指针变量 "p"。

函数内部使用了以下操作：

1. 创建了一个名为 "Severity" 的新类型，并将其赋值给整数变量 "x"。
2. 创建了一个名为 "p" 的新 "Severity" 类型变量，并将其赋值为整数 "x"。
3. 返回新创建的 "p"。

接下来，函数 "func" 还定义了两个名为 "String" 和 "Descriptor" 的函数：

1. 函数 "String" 接收一个 "Severity" 类型的参数，并将其 "Descriptor" 字段返回。函数使用 "protoimpl.X.EnumStringOf" 函数将 "Severity" 类型转换为字符串。
2. 函数 "Descriptor" 接收一个 "Severity" 类型的参数，并将其 "Descriptor" 字段返回。函数使用 "file_common_log_log_proto_enumTypes" 内部类型，根据传入的 "x" 返回对应的字符串。
3. 最后，函数 "func" 还定义了一个名为 "Type" 的函数，接收一个 "Severity" 类型的参数，并将其返回为 "protoreflect.EnumType"。


```go
func (x Severity) Enum() *Severity {
	p := new(Severity)
	*p = x
	return p
}

func (x Severity) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Severity) Descriptor() protoreflect.EnumDescriptor {
	return file_common_log_log_proto_enumTypes[0].Descriptor()
}

func (Severity) Type() protoreflect.EnumType {
	return &file_common_log_log_proto_enumTypes[0]
}

```

It looks like a series of hexadecimal values. Each value is made up of two hexadecimal digits, which may indicate a field or a part of a larger unit of measurement. Without more context, it's difficult to determine what each value represents.



```go
func (x Severity) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Severity.Descriptor instead.
func (Severity) EnumDescriptor() ([]byte, []int) {
	return file_common_log_log_proto_rawDescGZIP(), []int{0}
}

var File_common_log_log_proto protoreflect.FileDescriptor

var file_common_log_log_proto_rawDesc = []byte{
	0x0a, 0x14, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x6c, 0x6f, 0x67, 0x2f, 0x6c, 0x6f, 0x67,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x15, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f,
	0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x6c, 0x6f, 0x67, 0x2a, 0x44, 0x0a,
	0x08, 0x53, 0x65, 0x76, 0x65, 0x72, 0x69, 0x74, 0x79, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x6e, 0x6b,
	0x6e, 0x6f, 0x77, 0x6e, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x10,
	0x01, 0x12, 0x0b, 0x0a, 0x07, 0x57, 0x61, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x10, 0x02, 0x12, 0x08,
	0x0a, 0x04, 0x49, 0x6e, 0x66, 0x6f, 0x10, 0x03, 0x12, 0x09, 0x0a, 0x05, 0x44, 0x65, 0x62, 0x75,
	0x67, 0x10, 0x04, 0x42, 0x50, 0x0a, 0x19, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79,
	0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x6c, 0x6f, 0x67,
	0x50, 0x01, 0x5a, 0x19, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f,
	0x72, 0x65, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x6c, 0x6f, 0x67, 0xaa, 0x02, 0x15,
	0x56, 0x32, 0x52, 0x61, 0x79, 0x2e, 0x43, 0x6f, 0x72, 0x65, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x4c, 0x6f, 0x67, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

```

该代码定义了一个名为"file_common_log_log_proto_rawDescOnce"的变量，其作用是确保一个名为"file_common_log_log_proto_rawDescData"的变量只被访问一次，并在该变量的"do"函数中执行一个只读的"Once"操作。

变量"file_common_log_log_proto_rawDescOnce.Do"函数的代码将读取一个名为"file_common_log_log_proto_rawDescData"的静态变量，并使用一个名为"protoimpl.X.CompressGZIP"的函数将其进行压缩GZIP编码。然后，被压缩的值被赋给"file_common_log_log_proto_rawDescData"，从而将原始值作为静态变量存储。

变量"file_common_log_log_proto_enumTypes"定义了一个名为"file_common_log_log_proto_rawDescOnce"的静态变量，其作用是在函数中使用。

变量"file_common_log_log_proto_goTypes"定义了一个名为"file_common_log_log_proto_rawDescOnce"的静态变量，其作用是在函数中使用。


```go
var (
	file_common_log_log_proto_rawDescOnce sync.Once
	file_common_log_log_proto_rawDescData = file_common_log_log_proto_rawDesc
)

func file_common_log_log_proto_rawDescGZIP() []byte {
	file_common_log_log_proto_rawDescOnce.Do(func() {
		file_common_log_log_proto_rawDescData = protoimpl.X.CompressGZIP(file_common_log_log_proto_rawDescData)
	})
	return file_common_log_log_proto_rawDescData
}

var file_common_log_log_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_common_log_log_proto_goTypes = []interface{}{
	(Severity)(0), // 0: v2ray.core.common.log.Severity
}
```

此代码定义了一个名为 `file_common_log_log_proto_depIdxs` 的整数数组，用于存储与 `file_common_log_log_proto` 相关的依赖关系信息。

在 `file_common_log_log_proto_init` 函数中，首先检查 `File_common_log_log_proto` 是否为空，如果是，则直接返回。否则，使用 `protoimpl.TypeBuilder` 创建一个新类型实例，指定 `GoPackagePath`、`RawDescriptor` 和 `NumEnums`、`NumMessages`、`NumExtensions` 和 `NumServices` 等相关选项，然后将创建好的类型实例存储到 `File_common_log_log_proto_file` 变量中，并将依赖关系信息存储到 `file_common_log_log_proto_rawDesc`、`file_common_log_log_proto_goTypes` 和 `file_common_log_log_proto_depIdxs` 变量中。

最后，将创建好的类型实例存储到 `File_common_log_log_proto` 变量中，并将依赖关系信息存储到 `file_common_log_log_proto_rawDesc`、`file_common_log_log_proto_goTypes` 和 `file_common_log_log_proto_depIdxs` 变量中。


```go
var file_common_log_log_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_common_log_log_proto_init() }
func file_common_log_log_proto_init() {
	if File_common_log_log_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_common_log_log_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   0,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_common_log_log_proto_goTypes,
		DependencyIndexes: file_common_log_log_proto_depIdxs,
		EnumInfos:         file_common_log_log_proto_enumTypes,
	}.Build()
	File_common_log_log_proto = out.File
	file_common_log_log_proto_rawDesc = nil
	file_common_log_log_proto_goTypes = nil
	file_common_log_log_proto_depIdxs = nil
}

```

# `common/log/logger.go`

这段代码定义了一个名为“log”的包，该包包含了一些用于写入日志的接口、类型和函数。

具体来说，这段代码实现了一个Writer接口，它提供了一个将字符串写入到标准输出的函数，并且支持关闭输出缓冲器和操作系统相关的操作。

同时，该接口还定义了一个名为“Logger”的类型，它实现了Writer接口，并提供了一些额外的功能，如将多个Logger实例合并为单个的Logger实例，设置一个日志输出器等。

此外，代码还引入了“v2ray.com/core/common/platform”包中的“common/signal”包，它提供了“done”和“semaphore”信号，用于在一些情况下取消日志的输出。


```go
package log

import (
	"io"
	"log"
	"os"
	"time"

	"v2ray.com/core/common/platform"
	"v2ray.com/core/common/signal/done"
	"v2ray.com/core/common/signal/semaphore"
)

// Writer is the interface for writing logs.
type Writer interface {
	Write(string) error
	io.Closer
}

```

这段代码定义了一个名为WriterCreator的函数，用于创建日志写入器。

定义了一个名为generalLogger的结构体，该结构体包含一个名为creator的写入器实例，一个用于存储消息的缓冲区通道，一个指向完成工作的semaphore实例和一个指向已完成工作的semaphore实例。

定义了一个名为NewLogger的函数，该函数接收一个名为logWriterCreator的日志写入器实例作为参数，并返回一个可以处理所有类型消息的通用日志处理程序。该函数创建了一个generalLogger实例，该实例包含一个可以写入到缓冲区的频道通道，一个用于存储消息的频道通道，一个指向已完成工作的semaphore实例和一个指向已完成工作的semaphore实例。

通过调用NewLogger函数，可以创建一个可以处理所有类型消息的通用日志处理程序，该程序将所有消息写入缓冲区，当缓冲区满时，将进行清理并丢弃最新的消息。当缓冲区为空或已完成工作的时候，该函数将返回一个空闲的、未完成工作的日志处理程序。


```go
// WriterCreator is a function to create LogWriters.
type WriterCreator func() Writer

type generalLogger struct {
	creator WriterCreator
	buffer  chan Message
	access  *semaphore.Instance
	done    *done.Instance
}

// NewLogger returns a generic log handler that can handle all type of messages.
func NewLogger(logWriterCreator WriterCreator) Handler {
	return &generalLogger{
		creator: logWriterCreator,
		buffer:  make(chan Message, 16),
		access:  semaphore.New(1),
		done:    done.New(),
	}
}

```

该函数是一个名为`func`的匿名函数，接受一个名为`generalLogger`的整数类型的参数，并返回一个整数类型的变量`int`类型的结果。

函数内部的作用如下：

1. 创建一个名为`logger`的输出日志函数，如果`logger`为`nil`，则直接返回，否则关闭`logger`并返回。

2. 创建一个名为`ticker`的时间轮询函数，每隔`time.Minute`时间间隔轮询一次，如果`ticker`正在运行，则停止`ticker`并返回，否则开始`ticker`的运行。

3. 循环等待以下几种情况：

   a. `l.done`已完成的等待，停止循环并返回。
   b. 接收到`l.buffer`中的新消息，将消息字符串附加到`logger`的输出并继续等待下一个轮询。
   c. 轮询到`ticker`的时间，停止`ticker`并继续等待下一个轮询。

4. 在循环中，如果接收到`l.done`的等待，退出循环并返回。


```go
func (l *generalLogger) run() {
	defer l.access.Signal()

	dataWritten := false
	ticker := time.NewTicker(time.Minute)
	defer ticker.Stop()

	logger := l.creator()
	if logger == nil {
		return
	}
	defer logger.Close() // nolint: errcheck

	for {
		select {
		case <-l.done.Wait():
			return
		case msg := <-l.buffer:
			logger.Write(msg.String() + platform.LineSeparator()) // nolint: errcheck
			dataWritten = true
		case <-ticker.C:
			if !dataWritten {
				return
			}
			dataWritten = false
		}
	}
}

```

这两函数一起作用于 `generalLogger` 类型的 `l` 变量。

第一个函数 `Handle` 接收一个 `msg` 并将其传递给 `l.buffer` 作为输入。如果没有从 `l.buffer` 接收数据， 该函数将导致悬停。然后， 函数将使用 `select` 语句等待来自 `l.access` 链的调用， 并且在调用成功时执行 `l.run` 函数。如果调用失败， 函数将返回一个 `error`。

第二个函数 `Close` 返回一个 `error` 类型的 `l.done` 链的 `Close` 方法， 该方法关闭与 `l.done` 链的连接。如果该函数没有执行任何实际的资源关闭操作， 它将导致不确定的错误。


```go
func (l *generalLogger) Handle(msg Message) {
	select {
	case l.buffer <- msg:
	default:
	}

	select {
	case <-l.access.Wait():
		go l.run()
	default:
	}
}

func (l *generalLogger) Close() error {
	return l.done.Close()
}

```

这段代码定义了两个不同类型的日志Writer，一个是ConsoleLogWriter，另一个是FileLogWriter。

ConsoleLogWriter结构体包含一个日志Writer实例和一个指向logger的引用。它的Write函数将一个字符串s写入到logger，然后返回一个 nil值。Close函数返回一个 nil值。

FileLogWriter结构体包含一个文件和一个日志Writer实例。它的Write函数将一个字符串s写入到文件。它的Close函数返回一个错误。

在代码中，首先定义了两个日志Writer类型，然后定义了一个FileLogWriter实例和一个ConsoleLogWriter实例。然后，为这两个实例分别实现了Write和Close函数。

这段代码的主要目的是创建和关闭两个不同类型的日志Writer实例，以便用户可以根据需要选择不同的日志记录器。在代码中，通过使用这两个实例，用户可以将日志信息记录到不同的目标，包括屏幕和文件。


```go
type consoleLogWriter struct {
	logger *log.Logger
}

func (w *consoleLogWriter) Write(s string) error {
	w.logger.Print(s)
	return nil
}

func (w *consoleLogWriter) Close() error {
	return nil
}

type fileLogWriter struct {
	file   *os.File
	logger *log.Logger
}

```

这段代码定义了两个函数，一个是`func (w *fileLogWriter) Write(s string) error`，另一个是`func (w *fileLogWriter) Close() error`。

这两个函数的功能是：

1. `Write(s string) error`函数的作用是将`s`这个字符串写入到`fileLogWriter`中的`logger`字段中，并返回一个`error`类型的结果。具体实现是，将`s`通过`fmt.Println`函数打印到`logger`字段的` Print`方法中，然后将结果返回。

2. `Close() error`函数的作用是关闭`fileLogWriter`中的`file`，并返回一个`error`类型的结果。具体实现是，关闭`file`并返回，如果`file`关闭失败，则返回一个`error`。

3. `CreateStdoutLogWriter() WriterCreator`函数的作用是返回一个`WriterCreator`，用于将`stdout`作为参数创建一个`Logger`实例。具体实现是，创建一个`consoleLogWriter`实例，将其`logger`字段设置为输出到`stdout`的`fmt.Println`函数的输出，然后返回。

4. `func (w *fileLogWriter) Write(s string) error`函数的实现与上述类似，但是将`file`替换为了`fileLogWriter`中的`logger`字段，因此返回一个`error`类型的结果。


```go
func (w *fileLogWriter) Write(s string) error {
	w.logger.Print(s)
	return nil
}

func (w *fileLogWriter) Close() error {
	return w.file.Close()
}

// CreateStdoutLogWriter returns a LogWriterCreator that creates LogWriter for stdout.
func CreateStdoutLogWriter() WriterCreator {
	return func() Writer {
		return &consoleLogWriter{
			logger: log.New(os.Stdout, "", log.Ldate|log.Ltime),
		}
	}
}

```

这段代码定义了两个函数，分别用于创建将输出到控制台和将输出到指定文件的日志Writer。

函数`CreateStderrLogWriter`返回一个将输出到控制台文件的`WriterCreator`。具体来说，它创建了一个新的`LogWriter`实例，将`log.Ldate`和`log.Ltime`作为`logger`的参数，并将输出重定向到控制台。

函数`CreateFileLogWriter`返回一个将输出到指定文件的`WriterCreator`。具体来说，它打开一个文件，以指定的权限写入数据，并返回一个将写入数据到该文件的`Writer`实例。如果打开文件时出现错误，函数返回一个非空错误。

这两个函数的实现细节使得我们可以创建一个简单的日志库，记录程序运行时发生的错误、警告和其他日志信息。


```go
// CreateStderrLogWriter returns a LogWriterCreator that creates LogWriter for stderr.
func CreateStderrLogWriter() WriterCreator {
	return func() Writer {
		return &consoleLogWriter{
			logger: log.New(os.Stderr, "", log.Ldate|log.Ltime),
		}
	}
}

// CreateFileLogWriter returns a LogWriterCreator that creates LogWriter for the given file.
func CreateFileLogWriter(path string) (WriterCreator, error) {
	file, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		return nil, err
	}
	file.Close()
	return func() Writer {
		file, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
		if err != nil {
			return nil
		}
		return &fileLogWriter{
			file:   file,
			logger: log.New(file, "", log.Ldate|log.Ltime),
		}
	}, nil
}

```

这段代码定义了一个名为 "init" 的函数，它接受一个空括号作为参数，并在括号内部创建了一个新的函数实参 "this"(使用参数列表圆括号表示)。

接下来，函数使用 "RegisterHandler" 函数将一个名为 "NewLogger" 的函数作为实参传递，并将 "CreateStdoutLogWriter" 的函数作为另一个实参传递给 "RegisterHandler" 函数。 "NewLogger" 函数的实参是一个新的函数声明，它指定了要创建一个新的日志输出器。 "CreateStdoutLogWriter" 函数的实参是一个函数声明，它指定了要创建一个新的标准输出日志 writer。

最后，函数创建了一个新的函数主体，其中包含以下语句：


func init() {
	RegisterHandler(NewLogger(CreateStdoutLogWriter()))
}


这个函数的作用是创建一个新的日志输出器，以便在函数内输出日志信息。这个日志输出器将所有输出打 indent 缩进，并将其保存到标准输出流中。


```go
func init() {
	RegisterHandler(NewLogger(CreateStdoutLogWriter()))
}

```

# `common/log/logger_test.go`

这段代码是一个测试用例，名为 "file_logger.go"。它的作用是测试一个名为 "file_logger" 的包。

具体来说，它实现了以下操作：

1. 创建一个临时文件，用于存储日志数据。
2. 创建一个名为 "vtest" 的文件，并写入一些测试日志。
3. 创建一个名为 "file_logger.go" 的文件，并写入以下内容：

package log_test

import (
	"io/ioutil"
	"os"
	"strings"
	"testing"
	"time"

	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	. "v2ray.com/core/common/log"
)

func TestFileLogger(t *testing.T) {
	f, err := ioutil.TempFile("", "vtest")
	common.Must(err)
	path := f.Name()
	common.Must(f.Close())

	creator, err := CreateFileLogWriter(path)
	common.Must(err)

	handler := NewLogger(creator)
	handler.Handle(&GeneralMessage{Content: "Test Log"})
	time.Sleep(2 * time.Second)

	common.Must(common.Close(handler))

	f, err = os.Open(path)
	common.Must(err)
	defer f.Close() // nolint: errcheck

	b, err := buf.ReadAllToBytes(f)
	common.Must(err)
	if !strings.Contains(string(b), "Test Log") {
		t.Fatal("Expect log text contains 'Test Log', but actually: ", string(b))
	}
}

在这段代码中，首先创建了一个名为 "file_logger.go" 的文件。接着，创建了一个名为 "vtest.go" 的文件，并向其中写入了 3 行测试日志。然后，创建了一个名为 "file_logger" 的包，并创建了一个名为 "file_logger.go" 的文件，向其中写入了以下内容：

package log_test

import (
	"io/ioutil"
	"os"
	"strings"
	"testing"
	"time"

	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	. "v2ray.com/core/common/log"
)

func TestFileLogger(t *testing.T) {
	f, err := ioutil.TempFile("", "vtest")
	common.Must(err)
	path := f.Name()
	common.Must(f.Close())

	creator, err := CreateFileLogWriter(path)
	common.Must(err)

	handler := NewLogger(creator)
	handler.Handle(&GeneralMessage{Content: "Test Log"})
	time.Sleep(2 * time.Second)

	common.Must(common.Close(handler))

	f, err = os.Open(path)
	common.Must(err)
	defer f.Close() // nolint: errcheck

	b, err := buf.ReadAllToBytes(f)
	common.Must(err)
	if !strings.Contains(string(b), "Test Log") {
		t.Fatal("Expect log text contains 'Test Log', but actually: ", string(b))
	}
}

最后，导入了 "v2ray.com/core/common" 和 "v2ray.com/core/common/buf"，并定义了一个名为 "TestFileLogger" 的测试用例 "file_logger.go"。这个测试用例创建了一个临时文件，创建了一个 "file_logger" 的实例，并向其中写入了


```go
package log_test

import (
	"io/ioutil"
	"os"
	"strings"
	"testing"
	"time"

	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	. "v2ray.com/core/common/log"
)

func TestFileLogger(t *testing.T) {
	f, err := ioutil.TempFile("", "vtest")
	common.Must(err)
	path := f.Name()
	common.Must(f.Close())

	creator, err := CreateFileLogWriter(path)
	common.Must(err)

	handler := NewLogger(creator)
	handler.Handle(&GeneralMessage{Content: "Test Log"})
	time.Sleep(2 * time.Second)

	common.Must(common.Close(handler))

	f, err = os.Open(path)
	common.Must(err)
	defer f.Close() // nolint: errcheck

	b, err := buf.ReadAllToBytes(f)
	common.Must(err)
	if !strings.Contains(string(b), "Test Log") {
		t.Fatal("Expect log text contains 'Test Log', but actually: ", string(b))
	}
}

```

# `common/log/log_test.go`

这段代码定义了一个名为 `testLogger` 的类型，它包含一个名为 `value` 的字段，类型为 `string`。

接下来，该代码导入了一系列包：`testing`、`github.com/google/go-cmp/cmp` 和 `v2ray.com/core/common/net`。

然后，该代码定义了一个名为 `testLogger` 的结构体，它包含一个名为 `value` 的字段。

接着，该代码使用 `github.com/google/go-cmp/cmp` 包中的 `cmp.Spec` 函数为 `testLogger` 类型定义了一个测试接口。

最后，该代码在 `v2ray.com/core/common/log` 包中定义了一个名为 `log` 的接口，它提供了一个将消息发送到日志中的方法。

总之，这段代码定义了一个名为 `testLogger` 的类型，该类型包含一个字符串字段 `value`，该类型定义了一个测试接口，该接口使用 `github.com/google/go-cmp/cmp` 包中的 `cmp.Spec` 函数进行定义。同时，该代码还定义了一个名为 `log` 的接口，该接口提供了一个将消息发送到日志中的方法。


```go
package log_test

import (
	"testing"

	"github.com/google/go-cmp/cmp"

	"v2ray.com/core/common/log"
	"v2ray.com/core/common/net"
)

type testLogger struct {
	value string
}

```

这段代码定义了一个名为`func`的函数，接收一个名为`testLogger`的整数类型的参数，以及一个`log.Message`类型的参数`msg`。

函数的作用是将`msg`的`String()`方法返回的值存储在`l`的`value`字段中。

接下来，定义了一个名为`TestLogRecord`的函数，该函数将`testLogger`作为参数，并将一个`log.GeneralMessage`类型的参数传递给`log.RegisterHandler`函数。

然后，使用`ip`来创建一个`log.GeneralMessage`类型的实例，并设置其`Severity`字段为`log.Severity_Error`,`Content`字段为`net.ParseAddress(ip)`。

接着，调用`log.Record`函数，并将上面创建的`log.GeneralMessage`实例传递给该函数。

最后，比较`"[Error] "+ip`和`logger.value`之间的差异，并将结果输出到控制台。如果两者之间的差异不为空，则表示函数`TestLogRecord`没有达到预期的行为，从而产生错误。


```go
func (l *testLogger) Handle(msg log.Message) {
	l.value = msg.String()
}

func TestLogRecord(t *testing.T) {
	var logger testLogger
	log.RegisterHandler(&logger)

	ip := "8.8.8.8"
	log.Record(&log.GeneralMessage{
		Severity: log.Severity_Error,
		Content:  net.ParseAddress(ip),
	})

	if diff := cmp.Diff("[Error] "+ip, logger.value); diff != "" {
		t.Error(diff)
	}
}

```

# `common/mux/client.go`

这段代码是一个名为 "mux" 的包，它提供了从 v2ray 服务器接收并传递数据的能力。下面是这个包的一些关键部分，以及它们的作用：

1. 导入了一些必要的库和常量，包括 "io" 和 "time"，用于输入和测量时间，以及 "common" 和 "signal" 包，这些库与 v2ray 客户端的交互式会话相关。

2. 通过 "v2ray.com/core/common/net" 包，创建一个网络连接。

3. 通过 "v2ray.com/core/common/session" 和 "v2ray.com/core/common/signal/done" 包，创建一个会话和一个 "done" 信号，用于通知已完成的传输。

4. 通过 "v2ray.com/core/common/task" 和 "v2ray.com/core/transport/internet" 包，创建一个任务和互联网传输协议。

5. 通过 "v2ray.com/core/transport/pipe" 包，将多个传输管道组合成一个。

6. 通过 "mux/transport" 包，定义了一组常用的 transport。

7. 通过 "mux/task" 和 "mux/transport" 包，创建了一组实现了 "v2ray.com/core/task" 和 "v2ray.com/core/transport/internet" 包的接口。

8. 通过 "mux/filter" 包，实现了一个管道筛选器，可以用于限制数据的进入。

9. 通过 "mux/勘测" 包，实现了一个数据源的勘测，用于从特定的 URL 接收数据。

10. 通过 "mux/业务" 包，实现了与 v2ray 客户端的交互，以完成更多的业务逻辑。


```go
package mux

import (
	"context"
	"io"
	"sync"
	"time"

	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	"v2ray.com/core/common/errors"
	"v2ray.com/core/common/net"
	"v2ray.com/core/common/protocol"
	"v2ray.com/core/common/session"
	"v2ray.com/core/common/signal/done"
	"v2ray.com/core/common/task"
	"v2ray.com/core/proxy"
	"v2ray.com/core/transport"
	"v2ray.com/core/transport/internet"
	"v2ray.com/core/transport/pipe"
)

```

该代码定义了一个名为ClientManager的 struct类型，其中包含一个名为Enabled的布尔类型和一个名为Picker的WorkerPicker类型。

该代码还定义了一个名为Dispatch的函数，该函数接收一个名为ctx的context.Context和一个名为link的transport.Link参数。该函数遍历一个名为worker的mux客户端，尝试从mux客户端中选择一个可用的工作器，并递归地调用该工作器的工作函数，直到找到可用的工作器并返回。如果选择的工作器不能工作或者找到的工作器不可用，则返回一个新错误。

最后，该函数将新错误信息添加到警告级别，以便开发人员知道选择的工作器不可用。


```go
type ClientManager struct {
	Enabled bool // wheather mux is enabled from user config
	Picker  WorkerPicker
}

func (m *ClientManager) Dispatch(ctx context.Context, link *transport.Link) error {
	for i := 0; i < 16; i++ {
		worker, err := m.Picker.PickAvailable()
		if err != nil {
			return err
		}
		if worker.Dispatch(ctx, link) {
			return nil
		}
	}

	return newError("unable to find an available mux client").AtWarning()
}

```

这是一个 Go 语言的代码，定义了一个名为 `IncrementalWorkerPicker` 的接口 `type WorkerPicker`，以及一个实现了该接口的名为 `WorkerPicker` 的类型 `type IncrementalWorkerPicker`。

`WorkerPicker` 类型包含了一个名为 `PickAvailable` 的函数 `type PickAvailable`，该函数接收两个参数，一个是客户端工作者 `ClientWorker`，另一个是错误 `error` 类型。

`IncrementalWorkerPicker` 类型内部包含了一个名为 `Factory` 的字段，该字段是一个 `ClientWorkerFactory` 类型的变量，用于创建客户端工作者实例。该类型还包含一个名为 `access` 的字段，该字段是一个 `sync.Mutex` 类型的变量，用于在多个客户端工作者之间同步操作。该类型还包含一个名为 `workers` 的字段，该字段是一个切片类型，用于存储客户端工作者实例。另外，该类型还包含一个名为 `cleanupTask` 的字段，该字段是一个 `task.Periodic` 类型的变量，用于定期执行清理任务。

`PickAvailable` 函数接收两个参数，第一个参数是一个指针类型，表示客户端工作者，第二个参数是一个 `error` 类型。该函数首先尝试从 `workers` 切片中选择一个可用的客户端工作者，如果选择失败，则返回一个错误。如果选择了客户端工作者，则返回该客户端工作者的 `ClientWorker` 实例。

`IncrementalWorkerPicker` 的 `cleanupFunc` 函数负责执行定期清理任务。该函数首先获取 `access` 锁，确保在多个客户端工作者之间只有一个实例被创建。然后，该函数执行 `cleanupTask` 中的清理操作，并检查是否所有的客户端工作者都已经结束工作。如果所有的客户端工作者都已经结束工作，则返回 ` nil`，表示操作成功。否则，该函数会抛出一个错误，指定发生错误的原因。


```go
type WorkerPicker interface {
	PickAvailable() (*ClientWorker, error)
}

type IncrementalWorkerPicker struct {
	Factory ClientWorkerFactory

	access      sync.Mutex
	workers     []*ClientWorker
	cleanupTask *task.Periodic
}

func (p *IncrementalWorkerPicker) cleanupFunc() error {
	p.access.Lock()
	defer p.access.Unlock()

	if len(p.workers) == 0 {
		return newError("no worker")
	}

	p.cleanup()
	return nil
}

```

这两函数是用于管理一个 IncrementalWorkerPicker 类型的对象。

函数 `func (p *IncrementalWorkerPicker) cleanup()` 是一个保护函数，用于在将其 `*IncrementalWorkerPicker` 类型的参数 `p` 被调用后对其进行清理操作。在这个函数中，首先创建一个名为 `activeWorkers` 的新切片，用于存储当前正在工作的工人对象。然后，遍历 `p.workers` 切片，对于每个尚未关闭的工人对象，将其添加到 `activeWorkers` 切片中。最后，将 `p.workers` 切片中的所有工人对象更新为 `activeWorkers` 切片中的所有工人对象。

函数 `func (p *IncrementalWorkerPicker) findAvailable() int` 会在 `p.workers` 切片中的所有工人对象中查找一个可用工人对象，并返回其索引。如果 `p.workers` 切片中的所有工人对象都处于关闭状态，则返回 -1。

这两个函数的作用是确保在需要时可以找到可用的工人对象，并在所有工人对象都处于关闭状态时返回-1，从而避免出现死锁的情况。


```go
func (p *IncrementalWorkerPicker) cleanup() {
	var activeWorkers []*ClientWorker
	for _, w := range p.workers {
		if !w.Closed() {
			activeWorkers = append(activeWorkers, w)
		}
	}
	p.workers = activeWorkers
}

func (p *IncrementalWorkerPicker) findAvailable() int {
	for idx, w := range p.workers {
		if !w.IsFull() {
			return idx
		}
	}

	return -1
}

```

该函数名为 `func (p *IncrementalWorkerPicker) pickInternal() (*ClientWorker, bool, error)`，它接收一个名为 `p` 的指针变量，该变量表示一个 `IncrementalWorkerPicker` 类型的对象。

该函数首先对 `p` 的访问权限进行锁定，然后进行一些操作，最后释放访问权限并返回结果。以下是函数的步骤：

1. 判断 `p` 是否找到了可用的工人，如果是，则执行以下操作：
   a. 从 `p.workers` 数组中删除比 `p.findAvailable()` 返回的索引小的元素，并将其存储到 `p.workers` 数组的末尾。
   b. 返回 `p.workers` 数组的最后一个元素，如果是 `n-1` 则表示找到了可用工人，否则表示没有找到可用工人。
2. 如果 `p` 没有找到可用工人，则执行以下操作：
   a. 使用 `p.Factory.Create()` 方法创建一个新的工人并将其添加到 `p.workers` 数组中。
   b. 如果 `p.cleanupTask` 为 `nil`，则执行以下操作：
       1. 创建一个定期任务，设置其间隔为 `time.Second * 30` 秒，并且每次执行 `p.cleanupFunc`。
       2. 将创建的定期任务设置为执行 `p.cleanupFunc`。
   c. 返回 `p.workers` 数组的最后一个元素，如果是 `n-1` 则表示创建了可用工人，否则表示没有创建可用工人。
3. 如果 `p.cleanupTask` 不是 `nil`，则设置 `p.cleanupTask` 定期任务为执行 `p.cleanupFunc`，并返回 `true` 和 `nil` 作为结果。


```go
func (p *IncrementalWorkerPicker) pickInternal() (*ClientWorker, bool, error) {
	p.access.Lock()
	defer p.access.Unlock()

	idx := p.findAvailable()
	if idx >= 0 {
		n := len(p.workers)
		if n > 1 && idx != n-1 {
			p.workers[n-1], p.workers[idx] = p.workers[idx], p.workers[n-1]
		}
		return p.workers[idx], false, nil
	}

	p.cleanup()

	worker, err := p.Factory.Create()
	if err != nil {
		return nil, false, err
	}
	p.workers = append(p.workers, worker)

	if p.cleanupTask == nil {
		p.cleanupTask = &task.Periodic{
			Interval: time.Second * 30,
			Execute:  p.cleanupFunc,
		}
	}

	return worker, true, nil
}

```

此代码定义了一个名为"func"的函数，它接受一个名为"p"的指针变量和一个名为"IncrementalWorkerPicker"的接口类型参数。函数的作用是选择一个名为"Available"的客户端 worker，并返回客户端 worker 和调用该 worker 的错误。

函数内部首先调用名为"p.pickInternal"的函数，该函数的作用是选择一个内部客户端 worker。然后，函数检查选择器是否已经初始化。如果是，函数将调用名为"p.cleanupTask.Start"的函数，该函数将开始一个清理任务。最后，函数创建客户端 worker，如果选择器没有初始化，则返回一个名为"empty"的客户端 worker。

函数还定义了一个名为"DialingWorkerFactory"的接口类型，该接口定义了一个名为"Create"的函数，该函数接受一个名为"proxy"的接口类型参数，并返回一个名为"ClientWorker"的客户端 worker 和一个名为"error"的错误。然后，定义了一个名为"DialingWorkerFactory"的接口类型，该接口定义了一个名为"Create"的函数，该函数接受一个名为"proxy"的接口类型参数，并返回一个名为"ClientWorker"的客户端 worker 和一个名为"error"的错误。最后，定义了一个名为"IncrementalWorkerPicker"的接口类型，该接口定义了一个名为"pickInternal"的函数，该函数用于选择一个内部客户端 worker。


```go
func (p *IncrementalWorkerPicker) PickAvailable() (*ClientWorker, error) {
	worker, start, err := p.pickInternal()
	if start {
		common.Must(p.cleanupTask.Start())
	}

	return worker, err
}

type ClientWorkerFactory interface {
	Create() (*ClientWorker, error)
}

type DialingWorkerFactory struct {
	Proxy    proxy.Outbound
	Dialer   internet.Dialer
	Strategy ClientStrategy
}

```

该函数创建了一个名为DialingWorkerFactory的管道客户端，通过调用其Create函数可以创建一个新的ClientWorker实例，该实例可以选择通过给定的网络代理连接到远程服务器。

具体来说，该函数实现了以下功能：

1. 通过配置选项，限制客户端工作者的大小，以防止因内存泄漏等错误导致的系统崩溃。

2. 创建两个套接字（uplinkReader和downlinkWriter）并将其连接到客户端工作者（ClientWorker）上。这些套接字用于从服务器端接收和发送数据。

3. 使用ClientWorker从远程服务器连接客户端，并创建一个处理套接字关闭的函数。当客户端连接成功后，该函数将开始处理连接。

4. 如果通过处理套接字关闭时出现错误，函数将记录错误并输出错误日志。

5. 返回客户端工作者实例和创建错误。


```go
func (f *DialingWorkerFactory) Create() (*ClientWorker, error) {
	opts := []pipe.Option{pipe.WithSizeLimit(64 * 1024)}
	uplinkReader, upLinkWriter := pipe.New(opts...)
	downlinkReader, downlinkWriter := pipe.New(opts...)

	c, err := NewClientWorker(transport.Link{
		Reader: downlinkReader,
		Writer: upLinkWriter,
	}, f.Strategy)

	if err != nil {
		return nil, err
	}

	go func(p proxy.Outbound, d internet.Dialer, c common.Closable) {
		ctx := session.ContextWithOutbound(context.Background(), &session.Outbound{
			Target: net.TCPDestination(muxCoolAddress, muxCoolPort),
		})
		ctx, cancel := context.WithCancel(ctx)

		if err := p.Process(ctx, &transport.Link{Reader: uplinkReader, Writer: downlinkWriter}, d); err != nil {
			errors.New("failed to handler mux client connection").Base(err).WriteToLog()
		}
		common.Must(c.Close())
		cancel()
	}(f.Proxy, f.Dialer, c.done)

	return c, nil
}

```

该代码定义了一个名为 ClientStrategy 的结构体，它定义了客户端的最大并发连接数和最大连接数。

该代码定义了一个名为 ClientWorker 的结构体，它定义了一个客户端工作者类，它使用一个名为 SessionManager 的实例来管理客户端会话，使用一个名为 Transport 的链式调用断言类型来管理客户端和服务器之间的连接，使用一个名为 Done 的实例来处理客户端请求后的结果，并使用一个名为 ClientStrategy 的类型来存储客户端策略。

该代码定义了一个名为 muxCoolAddress 和 muxCoolPort 的变量，用于存储客户端连接的 Ax 和 PAT。

该代码还定义了一个名为 NetDialer 的函数，用于设置客户端连接的 Ax 和 PAT，并返回一个 Transport.Ptr 类型的结果。

该代码还定义了一个名为net "go-grpc"的函数，用于创建一个与服务器建立连接的 Transport.Ptr 实例，并返回一个与客户端连接的 Transport.Ptr 实例。

该代码还定义了一个名为main的函数，用于创建一个名为 "test" 的字符串并输出客户端连接到服务器的 URI。


```go
type ClientStrategy struct {
	MaxConcurrency uint32
	MaxConnection  uint32
}

type ClientWorker struct {
	sessionManager *SessionManager
	link           transport.Link
	done           *done.Instance
	strategy       ClientStrategy
}

var muxCoolAddress = net.DomainAddress("v1.mux.cool")
var muxCoolPort = net.Port(9527)

```

这段代码定义了一个名为NewClientWorker的函数，用于创建一个新的mux.Client。

函数接受两个参数：

- stream: 这是一个传输.Link类型的变量，表示要创建的流。
- s: 这是一个ClientStrategy类型的变量，用于指定客户端策略。

函数内部创建了一个ClientWorker实例，该实例实现了mux.Client的接口。

- c := &ClientWorker{
	sessionManager: NewSessionManager(),
	link:           stream,
	done:           done.New(),
	strategy:       s,
}

- go c.fetchOutput()函数用于异步从客户端获取数据，并将其存储在c的sessionManager中。

- go c.monitor()函数用于在客户端连接时进行监控，c会定期检查是否有数据可用，如果有数据可用，则将其存储在c的sessionManager中。


```go
// NewClientWorker creates a new mux.Client.
func NewClientWorker(stream transport.Link, s ClientStrategy) (*ClientWorker, error) {
	c := &ClientWorker{
		sessionManager: NewSessionManager(),
		link:           stream,
		done:           done.New(),
		strategy:       s,
	}

	go c.fetchOutput()
	go c.monitor()

	return c, nil
}

```

该代码定义了三个函数分别表示客户端工人是否有连接、连接状态和是否已经关闭。

第一个函数 `TotalConnections()` 返回客户端工人的会话管理器中正在连接的客户端数量。

第二个函数 `ActiveConnections()` 返回客户端工人的会话管理器中正在活动的连接数量。

第三个函数 `Closed()` 返回客户端工人是否关闭，如果客户端已经完成关闭并且调用 `Done()` 函数，则返回 `true`，否则返回 `false`。函数会在客户端关闭时调用。

第四个函数 `monitor()` 用一个定时器来定期检查客户端是否还在运行。如果定时器时间到了或者客户端关闭了，函数会尝试关闭客户端并中断读写操作。函数会循环等待 up to 16 毫秒。


```go
func (m *ClientWorker) TotalConnections() uint32 {
	return uint32(m.sessionManager.Count())
}

func (m *ClientWorker) ActiveConnections() uint32 {
	return uint32(m.sessionManager.Size())
}

// Closed returns true if this Client is closed.
func (m *ClientWorker) Closed() bool {
	return m.done.Done()
}

func (m *ClientWorker) monitor() {
	timer := time.NewTicker(time.Second * 16)
	defer timer.Stop()

	for {
		select {
		case <-m.done.Wait():
			m.sessionManager.Close()
			common.Close(m.link.Writer)     // nolint: errcheck
			common.Interrupt(m.link.Reader) // nolint: errcheck
			return
		case <-timer.C:
			size := m.sessionManager.Size()
			if size == 0 && m.sessionManager.CloseIfNoSession() {
				common.Must(m.done.Close())
			}
		}
	}
}

```

此代码定义了两个函数，分别是`writeFirstPayload`和`fetchInput`。

1. `writeFirstPayload`函数的作用是：从Reader缓冲区中复制的数据首先进行缓冲区复制，然后将其传递给Writer。如果复制过程超时，则会返回一个错误。如果未发生错误，则返回零。

2. `fetchInput`函数的作用是：从给定的Session中读取输入数据，并将其写入指定的Writer缓冲区。在这个过程中，使用了一个名为`writeFirstPayload`的函数来确保数据按顺序写入。如果调用此函数时出现错误，则会将错误信息记录下来，并返回一个错误。

这两个函数都是使用Go语言编写的，并遵循了Go语言官方库（Go SDK）中的一些规范。


```go
func writeFirstPayload(reader buf.Reader, writer *Writer) error {
	err := buf.CopyOnceTimeout(reader, writer, time.Millisecond*100)
	if err == buf.ErrNotTimeoutReader || err == buf.ErrReadTimeout {
		return writer.WriteMultiBuffer(buf.MultiBuffer{})
	}

	if err != nil {
		return err
	}

	return nil
}

func fetchInput(ctx context.Context, s *Session, output buf.Writer) {
	dest := session.OutboundFromContext(ctx).Target
	transferType := protocol.TransferTypeStream
	if dest.Network == net.Network_UDP {
		transferType = protocol.TransferTypePacket
	}
	s.transferType = transferType
	writer := NewWriter(s.ID, dest, output, transferType)
	defer s.Close()      // nolint: errcheck
	defer writer.Close() // nolint: errcheck

	newError("dispatching request to ", dest).WriteToLog(session.ExportIDToError(ctx))
	if err := writeFirstPayload(s.input, writer); err != nil {
		newError("failed to write first payload").Base(err).WriteToLog(session.ExportIDToError(ctx))
		writer.hasError = true
		common.Interrupt(s.input)
		return
	}

	if err := buf.Copy(s.input, writer); err != nil {
		newError("failed to fetch all input").Base(err).WriteToLog(session.ExportIDToError(ctx))
		writer.hasError = true
		common.Interrupt(s.input)
		return
	}
}

```

这两函数接收一个客户端工作员实例类型的参数 `m`，并对其中的 `ClientWorker` 字段进行操作。

第一个函数 `IsClosing()` 返回一个布尔值，表示客户端工作员是否正在关闭。函数首先获取客户端工作员会话管理器 `sm`，并检查客户端工作员中的 `strategy` 字段中的 `MaxConnection` 是否大于 0，如果是，那么客户端工作员会话管理器中已创建连接数是否已达到客户端工作员中的 `strategy.MaxConnection`。如果是，那么客户端工作员已创建连接并且 `sm.Count()` 中已有的连接数已达到 `strategy.MaxConnection`，因此函数返回 `true`。否则，函数返回 `false`。

第二个函数 `IsFull()` 返回一个布尔值，表示客户端工作员是否已经达到客户端工作的最大容量。函数首先检查客户端工作员是否正在关闭，如果是，那么函数返回 `true`。然后，函数获取客户端工作员会话管理器 `sm`，并检查客户端工作员中的 `strategy` 字段中的 `MaxConcurrency` 是否大于 0，如果是，那么客户端工作员中的 `sm.Size()` 中的连接数是否已达到 `strategy.MaxConcurrency`，如果是，那么函数返回 `true`。否则，函数返回 `false`。


```go
func (m *ClientWorker) IsClosing() bool {
	sm := m.sessionManager
	if m.strategy.MaxConnection > 0 && sm.Count() >= int(m.strategy.MaxConnection) {
		return true
	}
	return false
}

func (m *ClientWorker) IsFull() bool {
	if m.IsClosing() || m.Closed() {
		return true
	}

	sm := m.sessionManager
	if m.strategy.MaxConcurrency > 0 && sm.Size() >= int(m.strategy.MaxConcurrency) {
		return true
	}
	return false
}

```

此代码定义了一个名为`func`的函数，接收一个名为`m`的指针和一个名为`link`的传输链的指针作为参数。函数返回一个布尔值，表示是否成功将数据从传输链中发送出去。

函数首先检查`m`是否为空或是否为`ClientWorker`类型的实例。如果是，则直接返回`false`。否则，函数将调用一个名为`sm`的会话管理器函数，并将`link.Reader`作为参数传递给`sm.Allocate()`函数。如果`sm.Allocate()`返回`nil`，则返回`false`。否则，函数将调用一个名为`fetchInput`的函数，将`ctx`上下文、`s`上下文和`m.link.Writer`作为参数传递给该函数。最后，函数返回`true`，表示成功将数据发送出去。


```go
func (m *ClientWorker) Dispatch(ctx context.Context, link *transport.Link) bool {
	if m.IsFull() || m.Closed() {
		return false
	}

	sm := m.sessionManager
	s := sm.Allocate()
	if s == nil {
		return false
	}
	s.input = link.Reader
	s.output = link.Writer
	go fetchInput(ctx, s, m.link.Writer)
	return true
}

```

这段代码定义了三个函数分别处理框架中连接的状态变化和关闭。

第一个函数 `handleStatueKeepAlive` 接收一个 `FrameMetadata` 类型的参数 `meta` 和一个 `BufferedReader` 类型的参数 `reader`，并返回一个错误。如果 `meta.Option.Has(OptionData)` 为真，则使用 `buf.Copy` 方法将数据复制到新的 `BufferedReader` 中，并返回。

第二个函数 `handleStatusNew` 与 `handleStatusKeepAlive` 类似，但用于处理 `OptionData` 字段。它接收 `FrameMetadata` 类型的参数 `meta` 和一个 `BufferedReader` 类型的参数 `reader`，并返回一个错误。如果 `meta.Option.Has(OptionData)` 为真，则使用 `buf.Copy` 方法将数据复制到新的 `BufferedReader` 中，并返回。

第三个函数 `handleStatusKeep` 也与 `handleStatusNew` 类似，但用于处理 `OptionData` 字段。它接收一个 `FrameMetadata` 类型的参数 `meta` 和一个 `BufferedReader` 类型的参数 `reader`，并返回一个错误。如果 `meta.Option.Has(OptionData)` 为真，则判断远程会话是否处于关闭状态。如果是，则关闭当前连接并返回。否则，使用远程会话的 `NewReader` 方法将数据复制到 `BufferedReader` 中，并返回。


```go
func (m *ClientWorker) handleStatueKeepAlive(meta *FrameMetadata, reader *buf.BufferedReader) error {
	if meta.Option.Has(OptionData) {
		return buf.Copy(NewStreamReader(reader), buf.Discard)
	}
	return nil
}

func (m *ClientWorker) handleStatusNew(meta *FrameMetadata, reader *buf.BufferedReader) error {
	if meta.Option.Has(OptionData) {
		return buf.Copy(NewStreamReader(reader), buf.Discard)
	}
	return nil
}

func (m *ClientWorker) handleStatusKeep(meta *FrameMetadata, reader *buf.BufferedReader) error {
	if !meta.Option.Has(OptionData) {
		return nil
	}

	s, found := m.sessionManager.Get(meta.SessionID)
	if !found {
		// Notify remote peer to close this session.
		closingWriter := NewResponseWriter(meta.SessionID, m.link.Writer, protocol.TransferTypeStream)
		closingWriter.Close()

		return buf.Copy(NewStreamReader(reader), buf.Discard)
	}

	rr := s.NewReader(reader)
	err := buf.Copy(rr, s.output)
	if err != nil && buf.IsWriteError(err) {
		newError("failed to write to downstream. closing session ", s.ID).Base(err).WriteToLog()

		// Notify remote peer to close this session.
		closingWriter := NewResponseWriter(meta.SessionID, m.link.Writer, protocol.TransferTypeStream)
		closingWriter.Close()

		drainErr := buf.Copy(rr, buf.Discard)
		common.Interrupt(s.input)
		s.Close()
		return drainErr
	}

	return err
}

```

这段代码的作用是实现了一个名为`ClientWorker`的客户端 workers，用于处理与服务器交互过程中的状态数据。

具体来说，代码实现了以下功能：

1. `handleStatusEnd`函数：当客户端 workers 接收到服务器发送的状态数据时，调用该函数处理状态数据。该函数会根据客户端 workers 的状态决定如何处理状态数据。如果客户端 workers 当前处于连接状态(即 `SessionStatusKeepAlive` 或 `SessionStatusNew`)，则会调用 `handleStatusKeep` 或 `handleStatusNew` 函数处理状态数据。如果客户端 workers 当前处于断开连接状态(即 `SessionStatusEnd` 或 `SessionStatusKeep`)，则会调用 `handleStatusEnd` 函数处理状态数据。在处理过程中，如果遇到错误，则会记录错误并输出错误信息。

2. `fetchOutput`函数：该函数用于从客户端 workers 的链接中读取输出数据，并将其返回。在函数中，客户端 workers 会不断地读取服务器发送的状态数据，直到客户端 workers 连接到服务器并获取到输出数据。在函数中，如果客户端 workers 连接到服务器后，发生了错误或者读取到了异常数据，则会记录错误并输出错误信息。

3. `ClientWorker` 类的构造函数：该构造函数没有执行任何特殊操作，用于初始化客户端 workers 所需要的一些变量和函数。

4. `ClientWorker` 类的析构函数：该析构函数在 `ClientWorker` 类的实例销毁时执行，用于关闭与服务器的连接、释放资源和关闭状态信息等。


```go
func (m *ClientWorker) handleStatusEnd(meta *FrameMetadata, reader *buf.BufferedReader) error {
	if s, found := m.sessionManager.Get(meta.SessionID); found {
		if meta.Option.Has(OptionError) {
			common.Interrupt(s.input)
			common.Interrupt(s.output)
		}
		s.Close()
	}
	if meta.Option.Has(OptionData) {
		return buf.Copy(NewStreamReader(reader), buf.Discard)
	}
	return nil
}

func (m *ClientWorker) fetchOutput() {
	defer func() {
		common.Must(m.done.Close())
	}()

	reader := &buf.BufferedReader{Reader: m.link.Reader}

	var meta FrameMetadata
	for {
		err := meta.Unmarshal(reader)
		if err != nil {
			if errors.Cause(err) != io.EOF {
				newError("failed to read metadata").Base(err).WriteToLog()
			}
			break
		}

		switch meta.SessionStatus {
		case SessionStatusKeepAlive:
			err = m.handleStatueKeepAlive(&meta, reader)
		case SessionStatusEnd:
			err = m.handleStatusEnd(&meta, reader)
		case SessionStatusNew:
			err = m.handleStatusNew(&meta, reader)
		case SessionStatusKeep:
			err = m.handleStatusKeep(&meta, reader)
		default:
			status := meta.SessionStatus
			newError("unknown status: ", status).AtError().WriteToLog()
			return
		}

		if err != nil {
			newError("failed to process data").Base(err).WriteToLog()
			return
		}
	}
}

```

# `common/mux/client_test.go`

这段代码是一个 Go 语言编写的测试框架，用于测试 mux 包的功能。具体来说，它包括以下几个部分：

1. 导入必要的库：mux_test.go 导入 mux.proto，mux_test.go.ip.毕节测试协议，github.com/golang/mock/gomock，v2ray.com/core/common/errors，v2ray.com/core/common/mux，v2ray.com/core/common/net，v2ray.com/core/common/session，v2ray.com/core/testing/mocks，transport.io，transport.io/pipelines，transport.io/pipelines/testing。

2. 创建一个名为 mock 的 Mock 上下文：通过调用 New Mock 函数创建一个 mock 上下文，该上下文用于在测试中模拟各种与 mux 相关的功能。

3. 注册到测试继承上下文：通过调用 Add传人上下文 函数，将 mock 上下文注册到测试的继承上下文中。

4. 启动测试：通过调用 Test开始执行测试，测试会在控制台输出 mux 的一系列功能测试。


```go
package mux_test

import (
	"context"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"v2ray.com/core/common"
	"v2ray.com/core/common/errors"
	"v2ray.com/core/common/mux"
	"v2ray.com/core/common/net"
	"v2ray.com/core/common/session"
	"v2ray.com/core/testing/mocks"
	"v2ray.com/core/transport"
	"v2ray.com/core/transport/pipe"
)

```

这段代码是用于测试一个名为"IncrementalPickerFailure"的函数。它使用Go的Mocks库创建了一个模拟控制器，通过使用gomock.NewController和defer来管理模拟对象的行为。

具体来说，这段代码以下几个步骤实现了模拟作用：

1. 创建一个名为"mockCtl"的Go模拟控制器，使用gomock.NewController和defer来管理模拟对象的行为。
2. 创建一个名为"mockWorkerFactory"的Go模拟对象，实现了mocks.NewMuxClientWorkerFactory接口，用于创建一个模拟工作器。
3. 创建一个名为"picker"的Go模拟对象，实现了mux.IncrementalWorkerPicker接口，负责模拟选择一个可用的商品。
4. 使用模拟对象调用其PickAvailable()方法，模拟选择一个可用的商品，并记录下结果。
5. 比较实际结果和期望结果，如果期望结果没有达到，就输出错误信息。

这段代码的作用是模拟测试一个名为"IncrementalPickerFailure"的函数，它接收一个测试框架的参数，通过模拟对象的操作来测试选择商品是否能够成功。


```go
func TestIncrementalPickerFailure(t *testing.T) {
	mockCtl := gomock.NewController(t)
	defer mockCtl.Finish()

	mockWorkerFactory := mocks.NewMuxClientWorkerFactory(mockCtl)
	mockWorkerFactory.EXPECT().Create().Return(nil, errors.New("test"))

	picker := mux.IncrementalWorkerPicker{
		Factory: mockWorkerFactory,
	}

	_, err := picker.PickAvailable()
	if err == nil {
		t.Error("expected error, but nil")
	}
}

```

这段代码使用了Go标准库中的`testing`包来测试一个名为`TestClientWorkerEOF`的函数。

该函数的作用是测试一个名为`mux.NewClientWorker`的函数，该函数接受一个传输协议的`transport.Link`结构体作为参数，该结构体指定了读取器和写入器的比例，以及客户端策略。

在该函数中，首先通过调用`pipe.New`函数创建了一个带大小限制的读写管道。然后，通过调用`mux.NewClientWorker`函数创建了一个名为`worker`的客户端工作者实例，并确保所有依赖的API都关闭了。

接下来，代码中的一个`time.Sleep`函数暂停了执行一段时间（例如500毫秒），以确保所有依赖的API都处理完了自己的任务。

最后，代码创建了一个名为`f`的函数，使用客户端工作者实例中的`Dispatch`函数，并传递一个空白的`ctx`（通常是调用者 context 的当前上下文）。

根据函数的行为，如果客户端工作者能够成功完成所有预期的工作，那么它将不会输出任何错误信息。否则，该函数将输出一个错误，并返回一个非零状态的`f`函数值。


```go
func TestClientWorkerEOF(t *testing.T) {
	reader, writer := pipe.New(pipe.WithoutSizeLimit())
	common.Must(writer.Close())

	worker, err := mux.NewClientWorker(transport.Link{Reader: reader, Writer: writer}, mux.ClientStrategy{})
	common.Must(err)

	time.Sleep(time.Millisecond * 500)

	f := worker.Dispatch(context.Background(), nil)
	if f {
		t.Error("expected failed dispatching, but actually not")
	}
}

```

This is a gRPC struct that defines the connection parameters for a v2ray server. It includes a reader and a writer for the transport connection, which is established using the v2ray.io transport library.

The struct has the following fields:

* `Reader`: a connection that reads data from the transport connection.
* `Writer`: a connection that writes data to the transport connection.
* `MaxConcurrency`: the maximum number of connections that can be open at the same time.
* `MaxConnection`: the maximum number of active connections that can be had by the server.

The `mux.ClientStrategy` field is used to configure the connection strategy for the reader and writer. It includes the maximum concurrency and the maximum number of active connections.

The `Create` method returns a writer and a reader instance, which are used in the `mux.IncrementalWorkerPicker` and `mux.ClientManager` fields.

The `Expect` method is used to specify the expected behavior for the methods of the `mux.ClientStrategy` and `mux.ClientManager`.

The `With` method is used to specify a context with a specified timeout for the closure of the connection.


```go
func TestClientWorkerClose(t *testing.T) {
	mockCtl := gomock.NewController(t)
	defer mockCtl.Finish()

	r1, w1 := pipe.New(pipe.WithoutSizeLimit())
	worker1, err := mux.NewClientWorker(transport.Link{
		Reader: r1,
		Writer: w1,
	}, mux.ClientStrategy{
		MaxConcurrency: 4,
		MaxConnection:  4,
	})
	common.Must(err)

	r2, w2 := pipe.New(pipe.WithoutSizeLimit())
	worker2, err := mux.NewClientWorker(transport.Link{
		Reader: r2,
		Writer: w2,
	}, mux.ClientStrategy{
		MaxConcurrency: 4,
		MaxConnection:  4,
	})
	common.Must(err)

	factory := mocks.NewMuxClientWorkerFactory(mockCtl)
	gomock.InOrder(
		factory.EXPECT().Create().Return(worker1, nil),
		factory.EXPECT().Create().Return(worker2, nil),
	)

	picker := &mux.IncrementalWorkerPicker{
		Factory: factory,
	}
	manager := &mux.ClientManager{
		Picker: picker,
	}

	tr1, tw1 := pipe.New(pipe.WithoutSizeLimit())
	ctx1 := session.ContextWithOutbound(context.Background(), &session.Outbound{
		Target: net.TCPDestination(net.DomainAddress("www.v2ray.com"), 80),
	})
	common.Must(manager.Dispatch(ctx1, &transport.Link{
		Reader: tr1,
		Writer: tw1,
	}))
	defer tw1.Close()

	common.Must(w1.Close())

	time.Sleep(time.Millisecond * 500)
	if !worker1.Closed() {
		t.Error("worker1 is not finished")
	}

	tr2, tw2 := pipe.New(pipe.WithoutSizeLimit())
	ctx2 := session.ContextWithOutbound(context.Background(), &session.Outbound{
		Target: net.TCPDestination(net.DomainAddress("www.v2ray.com"), 80),
	})
	common.Must(manager.Dispatch(ctx2, &transport.Link{
		Reader: tr2,
		Writer: tw2,
	}))
	defer tw2.Close()

	common.Must(w2.Close())
}

```