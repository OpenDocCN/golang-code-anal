# v2ray-core源码解析 15

# `app/router/command/command_grpc.pb.go`

这段代码是一个Go语言中的命令行工具，名为“command”。它使用了Go标准库中的“context”和“grpc”包，用于创建一个与远程服务器进行交互的GRPC连接。

具体来说，这段代码的作用是定义了一个名为“command”的包，其中包含了用于创建和执行远程GRPC命令的方法。这些方法使用了Go标准库中的“context”和“grpc”包来处理连接、消息传递和错误处理。通过使用这些包，用户可以编写独立的Go应用程序，使其能够通过GRPC协议与远程服务器进行交互。


```go
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package command

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

```

该代码定义了一个名为RoutingServiceClient的客户端API，用于调用RoutingService服务。

该API采用Go标准库中的grpc包来实现。在代码中，定义了一个名为RoutingServiceClient的接口，用于定义客户端的行为。该接口包括两个方法：SubscribeRoutingStats和TestRoute。

函数声明中，定义了一个名为routingServiceClient的结构体，该结构体包含一个grpc.ClientConnInterface类型的成员变量cc，该变量代表客户端与RoutingService服务之间的连接。

另外，还定义了一个名为NewRoutingServiceClient的函数，该函数接收一个grpc.ClientConnInterface类型的参数cc，并返回一个RoutingServiceClient类型的实例，该实例实现了上面定义的接口。

该代码的作用是定义一个RoutingServiceClient客户端API，用于与RoutingService服务进行交互，并实现了一系列接口，如SubscribeRoutingStats和TestRoute。


```go
// RoutingServiceClient is the client API for RoutingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoutingServiceClient interface {
	SubscribeRoutingStats(ctx context.Context, in *SubscribeRoutingStatsRequest, opts ...grpc.CallOption) (RoutingService_SubscribeRoutingStatsClient, error)
	TestRoute(ctx context.Context, in *TestRouteRequest, opts ...grpc.CallOption) (*RoutingContext, error)
}

type routingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoutingServiceClient(cc grpc.ClientConnInterface) RoutingServiceClient {
	return &routingServiceClient{cc}
}

```

此函数名为 `func (c *RoutingServiceClient) SubscribeRoutingStats(ctx context.Context, in *SubscribeRoutingStatsRequest, opts ...grpc.CallOption) (RoutingService_SubscribeRoutingStatsClient, error)`，它接收一个 `*SubscribeRoutingStatsRequest` 类型的输入参数，通过 `/v2ray.core.app.router.command.RoutingService/SubscribeRoutingStats` 路由请求将数据传递给该函数。函数实现如下：

1. 创建一个新的 `RoutingService_SubscribeRoutingStatsClient` 实例，该实例通过连接到服务器并从路由器获取统计数据。
2. 将获得的客户端 `stream` 用于从路由器接收数据。
3. 如果尝试发送 `in` 请求时出现错误，函数返回一个非空错误。
4. 如果关闭客户端 `stream` 时出现错误，函数返回一个非空错误。
5. 返回 `x` 和错误，其中 `x` 是客户端 `RoutingService_SubscribeRoutingStatsClient` 实例。


```go
func (c *routingServiceClient) SubscribeRoutingStats(ctx context.Context, in *SubscribeRoutingStatsRequest, opts ...grpc.CallOption) (RoutingService_SubscribeRoutingStatsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RoutingService_serviceDesc.Streams[0], "/v2ray.core.app.router.command.RoutingService/SubscribeRoutingStats", opts...)
	if err != nil {
		return nil, err
	}
	x := &routingServiceSubscribeRoutingStatsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

```

此代码定义了一个名为 "RoutingService_SubscribeRoutingStatsClient" 的接口类型，以及一个实现了该接口的 "routingServiceSubscribeRoutingStatsClient"  struct。

接口 "RoutingService_SubscribeRoutingStatsClient" 包含一个名为 "Recv" 的方法，该方法接收一个 "RoutingContext" 类型的参数，并返回一个 "RoutingContext" 类型和一个 "error" 类型的参数。

结构体 "routingServiceSubscribeRoutingStatsClient" 实现了 "RoutingService_SubscribeRoutingStatsClient" 接口，包含一个 "grpc.ClientStream" 类型的字段，该字段通过 "Recv" 方法获取客户端连接的流。

如果 "routingServiceSubscribeRoutingStatsClient" 的 "Recv" 方法成功接收了一个 "RoutingContext" 类型的数据，该数据将被存储在 "x" 变量中，并将 "nil" 类型返回给 "Recv" 方法，表示操作成功。否则，错误将存储在 "err" 变量中，并将 "nil" 类型返回给 "Recv" 方法，表示操作失败。


```go
type RoutingService_SubscribeRoutingStatsClient interface {
	Recv() (*RoutingContext, error)
	grpc.ClientStream
}

type routingServiceSubscribeRoutingStatsClient struct {
	grpc.ClientStream
}

func (x *routingServiceSubscribeRoutingStatsClient) Recv() (*RoutingContext, error) {
	m := new(RoutingContext)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

```

此代码定义了一个名为"func"的函数，接收一个名为"c"的引用和一个名为"routingServiceClient"的接收者参数。该函数使用一个名为"ctx"的上下文对象和一个名为"in"的 TestRoute 请求对象，然后调用一个名为"/v2ray.core.app.router.command.RoutingService/TestRoute"的 Endpoint 方法，将 TestRoute 请求对象传递给 Endpoint 方法，然后返回一个指向 RoutingContext 对象的引用和一个空错误对象。

如果此函数在传递参数时出现错误，则会返回一个空错误对象，否则它将返回指向 RoutingContext 对象的引用和一个空错误对象。

函数体中创建了一个名为 "out" 的新的 "RoutingContext" 对象，通过调用 "cc.Invoke" 方法将 TestRoute 请求对象发送到 "RoutingService" 的 Endpoint，然后处理返回的结果。

如果此函数在执行时出现错误，则会返回一个非空错误对象，否则它将返回一个空错误对象。


```go
func (c *routingServiceClient) TestRoute(ctx context.Context, in *TestRouteRequest, opts ...grpc.CallOption) (*RoutingContext, error) {
	out := new(RoutingContext)
	err := c.cc.Invoke(ctx, "/v2ray.core.app.router.command.RoutingService/TestRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutingServiceServer is the server API for RoutingService service.
// All implementations must embed UnimplementedRoutingServiceServer
// for forward compatibility
type RoutingServiceServer interface {
	SubscribeRoutingStats(*SubscribeRoutingStatsRequest, RoutingService_SubscribeRoutingStatsServer) error
	TestRoute(context.Context, *TestRouteRequest) (*RoutingContext, error)
	mustEmbedUnimplementedRoutingServiceServer()
}

```

这段代码定义了一个名为 `UnimplementedRoutingServiceServer` 的 struct 类型，它表示一个未实现的路由服务服务器。这个 struct 类型有一个名为 `SubscribeRoutingStats` 的方法和一个名为 `TestRoute` 的方法。

`SubscribeRoutingStats` 方法接受一个名为 `*SubscribeRoutingStatsRequest` 的输入参数，它是一个指向 `RoutingService_SubscribeRoutingStatsServer` 类型接口的指针。这个方法返回一个指向 `RoutingServiceServer` 类型的错误的错误对象，若错误，则返回 `status.Errorf(codes.Unimplemented, "method SubscribeRoutingStats not implemented")`。若成功，则返回 `nil`。

`TestRoute` 方法接受一个名为 `*TestRouteRequest` 的输入参数，它是一个指向 `RoutingService_TestRoute` 类型接口的指针。这个方法返回一个指向 `RoutingContext` 类型的错误的错误对象，若错误，则返回 `status.Errorf(codes.Unimplemented, "method TestRoute not implemented")`。若成功，则返回 `nil`。

最后，有一个名为 `mustEmbedUnimplementedRoutingServiceServer` 的方法，它是一个不输出任何内容的无参构造函数。


```go
// UnimplementedRoutingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRoutingServiceServer struct {
}

func (UnimplementedRoutingServiceServer) SubscribeRoutingStats(*SubscribeRoutingStatsRequest, RoutingService_SubscribeRoutingStatsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeRoutingStats not implemented")
}
func (UnimplementedRoutingServiceServer) TestRoute(context.Context, *TestRouteRequest) (*RoutingContext, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestRoute not implemented")
}
func (UnimplementedRoutingServiceServer) mustEmbedUnimplementedRoutingServiceServer() {}

// UnsafeRoutingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoutingServiceServer will
// result in compilation errors.
```

这段代码定义了一个名为 `UnsafeRoutingServiceServer` 的接口，该接口要求实现 `mustEmbedUnimplementedRoutingServiceServer()` 函数。

接着，定义了一个名为 `RegisterRoutingServiceServer` 的函数，该函数接收一个 `grpc.Server` 和一个 `RoutingServiceServer` 作为参数，并将它们注册到一个服务器上。

在 `RegisterRoutingServiceServer` 函数内部，注册了一个名为 `_RoutingService_serviceDesc` 的服务描述符，它是 `RoutingServiceServer` 接口的一个服务描述符，用于注册和服务器之间的交互。

接着，定义了一个名为 `_RoutingService_SubscribeRoutingStats_Handler` 的函数，该函数接收一个 `grpc.ServerStream` 和一个 `SubscribeRoutingStatsRequest` 作为参数，返回一个 `error`。

该函数内部创建了一个名为 `m` 的新对象，它是一个 `SubscribeRoutingStatsRequest` 类型的变量。如果尝试从服务器流中接收消息时出现错误，将返回该错误。否则，将 `m` 传递给 `srv.(RoutingServiceServer).SubscribeRoutingStats` 函数，它将接收并返回一个指向 `RoutingServiceSubscribeRoutingStatsServer` 类型的对象，该对象将使用 `m` 发送新的 `SubscribeRoutingStatsRequest` 给服务器。


```go
type UnsafeRoutingServiceServer interface {
	mustEmbedUnimplementedRoutingServiceServer()
}

func RegisterRoutingServiceServer(s *grpc.Server, srv RoutingServiceServer) {
	s.RegisterService(&_RoutingService_serviceDesc, srv)
}

func _RoutingService_SubscribeRoutingStats_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRoutingStatsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RoutingServiceServer).SubscribeRoutingStats(m, &routingServiceSubscribeRoutingStatsServer{stream})
}

```

这段代码定义了一个名为 `RoutingService_SubscribeRoutingStatsServer` 的接口 `RoutingServiceServer`，该接口实现了 `grpc.ServerStream`。

再定义了一个名为 `routingServiceSubscribeRoutingStatsServer` 的 struct，该 struct 实现了 `grpc.ServerStream`。

该 `routingService_SubscribeRoutingStatsServer` 结构体有一个名为 `Send` 的方法，其接收一个名为 `RoutingContext` 的类型为 `TestRouteRequest` 的参数，并返回一个类型为 `error` 的类型的参数。

该 `RoutingService_TestRoute_Handler` 函数接收一个名为 `TestRouteRequest` 的类型为 `TestRouteRequest` 的参数，然后返回一个名为 `TestRoute` 的函数，该函数接收一个名为 `RoutingContext` 的类型为 `TestRouteRequest` 的参数，并执行 `RoutingService` 实现的 `TestRoute` 方法，将返回的结果返回给调用方。

如果该 `RoutingService_TestRoute_Handler` 函数接收 `TestRouteRequest` 时出现错误，则返回一个类型为 `error` 的类型的参数。如果该 `RoutingService_TestRoute_Handler` 函数的 `RoutingService` 对象实现了 `RoutingServiceServer` 接口，则使用该接口的 `TestRoute` 方法代替调用 `RoutingService_TestRoute_Handler` 函数的方式。


```go
type RoutingService_SubscribeRoutingStatsServer interface {
	Send(*RoutingContext) error
	grpc.ServerStream
}

type routingServiceSubscribeRoutingStatsServer struct {
	grpc.ServerStream
}

func (x *routingServiceSubscribeRoutingStatsServer) Send(m *RoutingContext) error {
	return x.ServerStream.SendMsg(m)
}

func _RoutingService_TestRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).TestRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2ray.core.app.router.command.RoutingService/TestRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).TestRoute(ctx, req.(*TestRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

```

这段代码定义了一个名为 "v2ray.core.app.router.command.RoutingService" 的 Google Cloud Router 服务，它提供了注册和获取路由信息的服务。下面是代码中定义的一些关键部分：


// This service provides a high-level interface for registering and retrieving routing information.
var _RoutingService_serviceDesc = grpc.ServiceDesc{
   ServiceName: "v2ray.core.app.router.command.RoutingService",
   HandlerType: (*RoutingServiceServer)(nil),
   Methods: []grpc.MethodDesc{
       {
           MethodName: "TestRoute",
           Handler:    _RoutingService_TestRoute_Handler,
       },
   },
   Streams: []grpc.StreamDesc{
       {
           StreamName:    "SubscribeRoutingStats",
           Handler:       _RoutingService_SubscribeRoutingStats_Handler,
           ServerStreams: true,
       },
   },
   Metadata: "app/router/command/command.proto",
}


这段代码首先定义了服务描述符 `_RoutingService_serviceDesc`，其中包含了服务的名称、服务器实现类型和定义的方法列表。

接着，定义了一系列方法，包括 `TestRoute` 和 `SubscribeRoutingStats` 方法，它们的实现分别通过 `_RoutingService_TestRoute_Handler` 和 `_RoutingService_SubscribeRoutingStats_Handler` 函数实现。

定义了一个包含服务注册中心的 stream，这个 stream 将会输出一些 metrics，比如 number of routes、routing statistics、 etc.

最后定义了服务的元数据信息，以及相关的 proto 文件信息。


```go
var _RoutingService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v2ray.core.app.router.command.RoutingService",
	HandlerType: (*RoutingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TestRoute",
			Handler:    _RoutingService_TestRoute_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeRoutingStats",
			Handler:       _RoutingService_SubscribeRoutingStats_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "app/router/command/command.proto",
}

```

# `app/router/command/command_test.go`

这段代码是一个 Go 语言编写的测试套件，用于测试命令行工具（Command）的客户端和服务端。

1. 导入必要的库：
python
import (
	"context"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmpopts"
	"google.golang.org/grpc"
	"google.golang.org/grpc/test/bufconv"
	"v2ray.com/core/app/router"
	"v2ray.com/core/app/router/command"
	"v2ray.com/core/app/stats"
	"v2ray.com/core/common"
	"v2ray.com/core/common/net"
	"v2ray.com/core/features/routing"
	"v2ray.com/core/testing/mocks"
)


2. 导入用于模拟 Google Cloud 云服务的 go-cloud-grpc 库。
python
import (
	"context"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmpopts"
	"google.golang.org/grpc"
	"google.golang.org/grpc/test/bufconv"
	"v2ray.com/core/app/router"
	"v2ray.com/core/app/router/command"
	"v2ray.com/core/app/stats"
	"v2ray.com/core/common"
	"v2ray.com/core/common/net"
	"v2ray.com/core/features/routing"
	"v2ray.com/core/testing/mocks"
)

3. 定义用于模拟 Google Cloud 云服务的 go-cloud-grpc.即使用去模拟 Google Cloud 网络服务，因为我们不支持它。
go
package command_test

4. 导入所需的 mocks。




```go
package command_test

import (
	"context"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"google.golang.org/grpc"
	"google.golang.org/grpc/test/bufconn"
	"v2ray.com/core/app/router"
	. "v2ray.com/core/app/router/command"
	"v2ray.com/core/app/stats"
	"v2ray.com/core/common"
	"v2ray.com/core/common/net"
	"v2ray.com/core/features/routing"
	"v2ray.com/core/testing/mocks"
)

```

This is a Go program that tests the`, a
bytest中介件 which receives incoming requests, such as HTTP/1.1 `/publish`, and returns metrics about them.
It uses the `testing`


```go
func TestServiceSubscribeRoutingStats(t *testing.T) {
	c := stats.NewChannel(&stats.ChannelConfig{
		SubscriberLimit: 1,
		BufferSize:      0,
		Blocking:        true,
	})
	common.Must(c.Start())
	defer c.Close()

	lis := bufconn.Listen(1024 * 1024)
	bufDialer := func(context.Context, string) (net.Conn, error) {
		return lis.Dial()
	}

	testCases := []*RoutingContext{
		{InboundTag: "in", OutboundTag: "out"},
		{TargetIPs: [][]byte{{1, 2, 3, 4}}, TargetPort: 8080, OutboundTag: "out"},
		{TargetDomain: "example.com", TargetPort: 443, OutboundTag: "out"},
		{SourcePort: 9999, TargetPort: 9999, OutboundTag: "out"},
		{Network: net.Network_UDP, OutboundGroupTags: []string{"outergroup", "innergroup"}, OutboundTag: "out"},
		{Protocol: "bittorrent", OutboundTag: "blocked"},
		{User: "example@v2fly.org", OutboundTag: "out"},
		{SourceIPs: [][]byte{{127, 0, 0, 1}}, Attributes: map[string]string{"attr": "value"}, OutboundTag: "out"},
	}
	errCh := make(chan error)
	nextPub := make(chan struct{})

	// Server goroutine
	go func() {
		server := grpc.NewServer()
		RegisterRoutingServiceServer(server, NewRoutingServer(nil, c))
		errCh <- server.Serve(lis)
	}()

	// Publisher goroutine
	go func() {
		publishTestCases := func() error {
			ctx, cancel := context.WithTimeout(context.Background(), time.Second)
			defer cancel()
			for { // Wait until there's one subscriber in routing stats channel
				if len(c.Subscribers()) > 0 {
					break
				}
				if ctx.Err() != nil {
					return ctx.Err()
				}
			}
			for _, tc := range testCases {
				c.Publish(context.Background(), AsRoutingRoute(tc))
				time.Sleep(time.Millisecond)
			}
			return nil
		}

		if err := publishTestCases(); err != nil {
			errCh <- err
		}

		// Wait for next round of publishing
		<-nextPub

		if err := publishTestCases(); err != nil {
			errCh <- err
		}
	}()

	// Client goroutine
	go func() {
		defer lis.Close()
		conn, err := grpc.DialContext(context.Background(), "bufnet", grpc.WithContextDialer(bufDialer), grpc.WithInsecure())
		if err != nil {
			errCh <- err
			return
		}
		defer conn.Close()
		client := NewRoutingServiceClient(conn)

		// Test retrieving all fields
		testRetrievingAllFields := func() error {
			streamCtx, streamClose := context.WithCancel(context.Background())

			// Test the unsubscription of stream works well
			defer func() {
				streamClose()
				timeOutCtx, timeout := context.WithTimeout(context.Background(), time.Second)
				defer timeout()
				for { // Wait until there's no subscriber in routing stats channel
					if len(c.Subscribers()) == 0 {
						break
					}
					if timeOutCtx.Err() != nil {
						t.Error("unexpected subscribers not decreased in channel", timeOutCtx.Err())
					}
				}
			}()

			stream, err := client.SubscribeRoutingStats(streamCtx, &SubscribeRoutingStatsRequest{})
			if err != nil {
				return err
			}

			for _, tc := range testCases {
				msg, err := stream.Recv()
				if err != nil {
					return err
				}
				if r := cmp.Diff(msg, tc, cmpopts.IgnoreUnexported(RoutingContext{})); r != "" {
					t.Error(r)
				}
			}

			// Test that double subscription will fail
			errStream, err := client.SubscribeRoutingStats(context.Background(), &SubscribeRoutingStatsRequest{
				FieldSelectors: []string{"ip", "port", "domain", "outbound"},
			})
			if err != nil {
				return err
			}
			if _, err := errStream.Recv(); err == nil {
				t.Error("unexpected successful subscription")
			}

			return nil
		}

		// Test retrieving only a subset of fields
		testRetrievingSubsetOfFields := func() error {
			streamCtx, streamClose := context.WithCancel(context.Background())
			defer streamClose()
			stream, err := client.SubscribeRoutingStats(streamCtx, &SubscribeRoutingStatsRequest{
				FieldSelectors: []string{"ip", "port", "domain", "outbound"},
			})
			if err != nil {
				return err
			}

			// Send nextPub signal to start next round of publishing
			close(nextPub)

			for _, tc := range testCases {
				msg, err := stream.Recv()
				if err != nil {
					return err
				}
				stat := &RoutingContext{ // Only a subset of stats is retrieved
					SourceIPs:         tc.SourceIPs,
					TargetIPs:         tc.TargetIPs,
					SourcePort:        tc.SourcePort,
					TargetPort:        tc.TargetPort,
					TargetDomain:      tc.TargetDomain,
					OutboundGroupTags: tc.OutboundGroupTags,
					OutboundTag:       tc.OutboundTag,
				}
				if r := cmp.Diff(msg, stat, cmpopts.IgnoreUnexported(RoutingContext{})); r != "" {
					t.Error(r)
				}
			}

			return nil
		}

		if err := testRetrievingAllFields(); err != nil {
			errCh <- err
		}
		if err := testRetrievingSubsetOfFields(); err != nil {
			errCh <- err
		}
		errCh <- nil // Client passed all tests successfully
	}()

	// Wait for goroutines to complete
	select {
	case <-time.After(2 * time.Second):
		t.Fatal("Test timeout after 2s")
	case err := <-errCh:
		if err != nil {
			t.Fatal(err)
		}
	}
}

```

This is a Go test case for the `testRoutes` function. It compares the output of a routing test with the expected output. If the test fails, it will print an error and stop the test.


```go
func TestSerivceTestRoute(t *testing.T) {
	c := stats.NewChannel(&stats.ChannelConfig{
		SubscriberLimit: 1,
		BufferSize:      16,
		Blocking:        true,
	})
	common.Must(c.Start())
	defer c.Close()

	r := new(router.Router)
	mockCtl := gomock.NewController(t)
	defer mockCtl.Finish()
	common.Must(r.Init(&router.Config{
		Rule: []*router.RoutingRule{
			{
				InboundTag: []string{"in"},
				TargetTag:  &router.RoutingRule_Tag{Tag: "out"},
			},
			{
				Protocol:  []string{"bittorrent"},
				TargetTag: &router.RoutingRule_Tag{Tag: "blocked"},
			},
			{
				PortList:  &net.PortList{Range: []*net.PortRange{{From: 8080, To: 8080}}},
				TargetTag: &router.RoutingRule_Tag{Tag: "out"},
			},
			{
				SourcePortList: &net.PortList{Range: []*net.PortRange{{From: 9999, To: 9999}}},
				TargetTag:      &router.RoutingRule_Tag{Tag: "out"},
			},
			{
				Domain:    []*router.Domain{{Type: router.Domain_Domain, Value: "com"}},
				TargetTag: &router.RoutingRule_Tag{Tag: "out"},
			},
			{
				SourceGeoip: []*router.GeoIP{{CountryCode: "private", Cidr: []*router.CIDR{{Ip: []byte{127, 0, 0, 0}, Prefix: 8}}}},
				TargetTag:   &router.RoutingRule_Tag{Tag: "out"},
			},
			{
				UserEmail: []string{"example@v2fly.org"},
				TargetTag: &router.RoutingRule_Tag{Tag: "out"},
			},
			{
				Networks:  []net.Network{net.Network_UDP, net.Network_TCP},
				TargetTag: &router.RoutingRule_Tag{Tag: "out"},
			},
		},
	}, mocks.NewDNSClient(mockCtl), mocks.NewOutboundManager(mockCtl)))

	lis := bufconn.Listen(1024 * 1024)
	bufDialer := func(context.Context, string) (net.Conn, error) {
		return lis.Dial()
	}

	errCh := make(chan error)

	// Server goroutine
	go func() {
		server := grpc.NewServer()
		RegisterRoutingServiceServer(server, NewRoutingServer(r, c))
		errCh <- server.Serve(lis)
	}()

	// Client goroutine
	go func() {
		defer lis.Close()
		conn, err := grpc.DialContext(context.Background(), "bufnet", grpc.WithContextDialer(bufDialer), grpc.WithInsecure())
		if err != nil {
			errCh <- err
		}
		defer conn.Close()
		client := NewRoutingServiceClient(conn)

		testCases := []*RoutingContext{
			{InboundTag: "in", OutboundTag: "out"},
			{TargetIPs: [][]byte{{1, 2, 3, 4}}, TargetPort: 8080, OutboundTag: "out"},
			{TargetDomain: "example.com", TargetPort: 443, OutboundTag: "out"},
			{SourcePort: 9999, TargetPort: 9999, OutboundTag: "out"},
			{Network: net.Network_UDP, Protocol: "bittorrent", OutboundTag: "blocked"},
			{User: "example@v2fly.org", OutboundTag: "out"},
			{SourceIPs: [][]byte{{127, 0, 0, 1}}, Attributes: map[string]string{"attr": "value"}, OutboundTag: "out"},
		}

		// Test simple TestRoute
		testSimple := func() error {
			for _, tc := range testCases {
				route, err := client.TestRoute(context.Background(), &TestRouteRequest{RoutingContext: tc})
				if err != nil {
					return err
				}
				if r := cmp.Diff(route, tc, cmpopts.IgnoreUnexported(RoutingContext{})); r != "" {
					t.Error(r)
				}
			}
			return nil
		}

		// Test TestRoute with special options
		testOptions := func() error {
			sub, err := c.Subscribe()
			if err != nil {
				return err
			}
			for _, tc := range testCases {
				route, err := client.TestRoute(context.Background(), &TestRouteRequest{
					RoutingContext: tc,
					FieldSelectors: []string{"ip", "port", "domain", "outbound"},
					PublishResult:  true,
				})
				if err != nil {
					return err
				}
				stat := &RoutingContext{ // Only a subset of stats is retrieved
					SourceIPs:         tc.SourceIPs,
					TargetIPs:         tc.TargetIPs,
					SourcePort:        tc.SourcePort,
					TargetPort:        tc.TargetPort,
					TargetDomain:      tc.TargetDomain,
					OutboundGroupTags: tc.OutboundGroupTags,
					OutboundTag:       tc.OutboundTag,
				}
				if r := cmp.Diff(route, stat, cmpopts.IgnoreUnexported(RoutingContext{})); r != "" {
					t.Error(r)
				}
				select { // Check that routing result has been published to statistics channel
				case msg, received := <-sub:
					if route, ok := msg.(routing.Route); received && ok {
						if r := cmp.Diff(AsProtobufMessage(nil)(route), tc, cmpopts.IgnoreUnexported(RoutingContext{})); r != "" {
							t.Error(r)
						}
					} else {
						t.Error("unexpected failure in receiving published routing result for testcase", tc)
					}
				case <-time.After(100 * time.Millisecond):
					t.Error("unexpected failure in receiving published routing result", tc)
				}
			}
			return nil
		}

		if err := testSimple(); err != nil {
			errCh <- err
		}
		if err := testOptions(); err != nil {
			errCh <- err
		}
		errCh <- nil // Client passed all tests successfully
	}()

	// Wait for goroutines to complete
	select {
	case <-time.After(2 * time.Second):
		t.Fatal("Test timeout after 2s")
	case err := <-errCh:
		if err != nil {
			t.Fatal(err)
		}
	}
}

```

# `app/router/command/config.go`

这段代码定义了一个名为 "command" 的包，其中包含了一个名为 "routingContext" 的结构体，该结构体实现了 "routing.Context" 和 "routing.Route" 的接口。

具体来说，该结构体包含了一个 "*RoutingContext" 类型的成员变量 "RoutingContext"，以及一个名为 "GetSourceIPs" 的方法，该方法返回了 "RoutingContext" 类型的成员变量 "RoutingContext.GetSourceIPs" 的返回值，即获取源IP的切片。

此外，该代码还导入了一个名为 "strings" 的包，以及一个名为 "v2ray.com/core/common/net" 的包，该包可能用于从网络中获取数据。


```go
package command

import (
	"strings"

	"v2ray.com/core/common/net"
	"v2ray.com/core/features/routing"
)

// routingContext is an wrapper of protobuf RoutingContext as implementation of routing.Context and routing.Route.
type routingContext struct {
	*RoutingContext
}

func (c routingContext) GetSourceIPs() []net.IP {
	return mapBytesToIPs(c.RoutingContext.GetSourceIPs())
}

```

这段代码定义了三个函数，名为 `func`，根据输入参数 `c` 的类型为 `net.RoutingContext` 和 `net.IP`。

第一个函数 `GetSourcePort` 接收一个 `RoutingContext` 类型的参数，返回该 `RoutingContext` 的 `GetSourcePort` 字段的值，即 `c.RoutingContext.GetSourcePort()`，然后将其转换为 `net.Port` 类型。

第二个函数 `GetTargetIPs` 接收一个 `RoutingContext` 类型的参数，返回该 `RoutingContext` 的 `GetTargetIPs` 字段的值，即 `c.RoutingContext.GetTargetIPs()`，然后将其转换为 `net.IP` 类型的一维切片，返回。

第三个函数 `GetTargetPort` 接收一个 `RoutingContext` 类型的参数，返回该 `RoutingContext` 的 `GetTargetPort` 字段的值，即 `c.RoutingContext.GetTargetPort()`，然后将其转换为 `net.Port` 类型。

第四个函数 `AsRoutingContext` 接收一个 `RoutingContext` 类型的参数，返回一个实现了 `routing.Context` 接口的 `AsRoutingContext` 函数，将输入参数传递给该函数的 `r` 字段，然后返回其实现的 `AsRoutingContext` 函数的值，即 `AsRoutingContext(r)`。


```go
func (c routingContext) GetSourcePort() net.Port {
	return net.Port(c.RoutingContext.GetSourcePort())
}

func (c routingContext) GetTargetIPs() []net.IP {
	return mapBytesToIPs(c.RoutingContext.GetTargetIPs())
}

func (c routingContext) GetTargetPort() net.Port {
	return net.Port(c.RoutingContext.GetTargetPort())
}

// AsRoutingContext converts a protobuf RoutingContext into an implementation of routing.Context.
func AsRoutingContext(r *RoutingContext) routing.Context {
	return routingContext{r}
}

```

这段代码定义了一个名为“AsRoutingRoute”的函数，它接收一个名为“r”的“RoutingContext”参数，并将其转换为一个名为“routing.Route”的实现。函数返回的“routing.Route”实现了“routing.Route”接口，具有各种路由相关的属性和方法。

接下来，定义了一个名为“fieldMap”的 map，它包含了一系列函数，接收两个参数，一个是“RoutingContext”另一个是“routing.Route”类型。这些函数在“routing.Route”中进行作用，根据“r”参数的不同类型，执行不同的操作。比如，“inbound”函数接收一个“RoutingContext”和一个“routing.Route”参数，根据“r”的类型，将“RoutingContext”中的“InboundTag”字段存储到“s.InboundTag”中。


```go
// AsRoutingRoute converts a protobuf RoutingContext into an implementation of routing.Route.
func AsRoutingRoute(r *RoutingContext) routing.Route {
	return routingContext{r}
}

var fieldMap = map[string]func(*RoutingContext, routing.Route){
	"inbound":        func(s *RoutingContext, r routing.Route) { s.InboundTag = r.GetInboundTag() },
	"network":        func(s *RoutingContext, r routing.Route) { s.Network = r.GetNetwork() },
	"ip_source":      func(s *RoutingContext, r routing.Route) { s.SourceIPs = mapIPsToBytes(r.GetSourceIPs()) },
	"ip_target":      func(s *RoutingContext, r routing.Route) { s.TargetIPs = mapIPsToBytes(r.GetTargetIPs()) },
	"port_source":    func(s *RoutingContext, r routing.Route) { s.SourcePort = uint32(r.GetSourcePort()) },
	"port_target":    func(s *RoutingContext, r routing.Route) { s.TargetPort = uint32(r.GetTargetPort()) },
	"domain":         func(s *RoutingContext, r routing.Route) { s.TargetDomain = r.GetTargetDomain() },
	"protocol":       func(s *RoutingContext, r routing.Route) { s.Protocol = r.GetProtocol() },
	"user":           func(s *RoutingContext, r routing.Route) { s.User = r.GetUser() },
	"attributes":     func(s *RoutingContext, r routing.Route) { s.Attributes = r.GetAttributes() },
	"outbound_group": func(s *RoutingContext, r routing.Route) { s.OutboundGroupTags = r.GetOutboundGroupTags() },
	"outbound":       func(s *RoutingContext, r routing.Route) { s.OutboundTag = r.GetOutboundTag() },
}

```

此代码定义了一个名为`AsProtobufMessage`的函数，它接受一个字符串数组`fieldSelectors`作为参数，并返回一个名为`RoutingContext`的函数指针。

函数内部首先定义了一个`initializers`字符数组，用于存储各个字段的初始化函数。接着，遍历`fieldMap`，这是一个未定义的变量，但从代码中可以看出它是存储了各个字段名称映射的。

接下来，对于传入的`fieldSelectors`字符数组，定义了一个`for`循环，用于遍历各个字段选择器。在循环中，定义了一个`if`语句，用于判断当前字段是否与选择器字符串起始位置前缀相同。如果是，则将该字段选择器添加到`initializers`字符数组中。

最后，定义了一个`return`语句，返回一个`RoutingContext`类型的`message`实例，该实例包含所有字段名称选择器和初始化器设置，可以作为参数传递给`AsProtobufMessage`函数。


```go
// AsProtobufMessage takes selectors of fields and returns a function to convert routing.Route to protobuf RoutingContext.
func AsProtobufMessage(fieldSelectors []string) func(routing.Route) *RoutingContext {
	initializers := []func(*RoutingContext, routing.Route){}
	for field, init := range fieldMap {
		if len(fieldSelectors) == 0 { // If selectors not set, retrieve all fields
			initializers = append(initializers, init)
			continue
		}
		for _, selector := range fieldSelectors {
			if strings.HasPrefix(field, selector) {
				initializers = append(initializers, init)
				break
			}
		}
	}
	return func(ctx routing.Route) *RoutingContext {
		message := new(RoutingContext)
		for _, init := range initializers {
			init(message, ctx)
		}
		return message
	}
}

```

这两段代码定义了两个函数：`mapBytesToIPs` 和 `mapIPsToBytes`。这两个函数的主要目的是将给定的字节数组转换为相应的 IP 地址数组，或者将 IP 地址数组转换为给定的字节数组。

`mapBytesToIPs`函数接收一个字节数组，然后遍历该数组并将每个 IP 地址添加到结果数组中。函数的实现非常简单，主要依赖于网络 IP 类型和数组切片。

`mapIPsToBytes`函数接收一个 IP 地址数组，然后遍历该数组并将每个字节添加到结果数组中。函数的实现同样简单，主要依赖于 IP 地址类型和数组切片。

这两个函数的使用可以满足许多用IP地址表示的数据传输场景，例如在网络编程中处理UDP包，或者在数据存储系统中进行数据的读写等。


```go
func mapBytesToIPs(bytes [][]byte) []net.IP {
	var ips []net.IP
	for _, rawIP := range bytes {
		ips = append(ips, net.IP(rawIP))
	}
	return ips
}

func mapIPsToBytes(ips []net.IP) [][]byte {
	var bytes [][]byte
	for _, ip := range ips {
		bytes = append(bytes, []byte(ip))
	}
	return bytes
}

```

# `app/router/command/errors.generated.go`

这段代码定义了一个名为“command”的包，该包包含一个名为“errPathObjHolder”的结构体。

该结构体包含一个名为“errPathObjHolder”的空壳结构体，其中包含一个空字符串“”。

该代码还定义了一个名为“newError”的函数，该函数接收多个参数，并将它们存储在“values”切片中的一个或多个元素中。然后，该函数创建一个新的“errors.Error”类型对象，并使用它来抛出一个新的错误。

最后一个函数参数是一个空字符串，使用该参数作为新错误对象的“pathObj”字段。通过设置这个字段，新错误对象将包含与调用者提供给该函数的参数相关的错误路径对象。


```go
package command

import "v2ray.com/core/common/errors"

type errPathObjHolder struct{}

func newError(values ...interface{}) *errors.Error {
	return errors.New(values...).WithPathObj(errPathObjHolder{})
}

```

# `app/stats/channel.go`

这段代码定义了一个名为 `stats.Channel` 的实现了 `stats.Channel.` 协议的 `Channel` 类型。该 `Channel` 类型有两个主要的方法：`channel` 和 `subscribers`。

`channel` 方法接收一个 `chan channelMessage` 类型的参数，代表一个通道，用于发送和接收数据到和从 `subscribers` 中的 `interface{}` 类型的订阅者。

`subscribers` 方法接收一个 `[]chan interface{}` 类型的参数，代表订阅 `Channel` 类型实例的订阅者。

另外，该代码中还有一段注释 `// +build !confonly`，表示在 `go build` 命令执行前不要输出该文件，同时还设置了 `confonly` 参数，即只在此处设置，不会输出之后的文件。


```go
// +build !confonly

package stats

import (
	"context"
	"sync"

	"v2ray.com/core/common"
)

// Channel is an implementation of stats.Channel.
type Channel struct {
	channel     chan channelMessage
	subscribers []chan interface{}

	// Synchronization components
	access sync.RWMutex
	closed chan struct{}

	// Channel options
	blocking   bool // Set blocking state if channel buffer reaches limit
	bufferSize int  // Set to 0 as no buffering
	subsLimit  int  // Set to 0 as no subscriber limit
}

```

该代码定义了一个名为 "NewChannel" 的函数，该函数接收一个名为 "config" 的 "ChannelConfig" 类型的参数。函数创建了一个名为 "Channel" 的实例，该实例包含一个缓冲区、订阅者限制和缓冲区大小等配置。

函数返回一个指向 "Channel" 实例的引用，该实例可以用来调用 "Channel.Subscribers()" 方法来获取订阅者列表。

函数中的 "Subscribers()" 方法使用 "RLock()" 函数获取 "Channel" 实例的订阅者列表的锁，并在获取锁解码后返回。


```go
// NewChannel creates an instance of Statistics Channel.
func NewChannel(config *ChannelConfig) *Channel {
	return &Channel{
		channel:    make(chan channelMessage, config.BufferSize),
		subsLimit:  int(config.SubscriberLimit),
		bufferSize: int(config.BufferSize),
		blocking:   config.Blocking,
	}
}

// Subscribers implements stats.Channel.
func (c *Channel) Subscribers() []chan interface{} {
	c.access.RLock()
	defer c.access.RUnlock()
	return c.subscribers
}

```

这是一段 Go 语言中的接口链，定义了两个名为 `Subscribe` 和 `Unsubscribe` 的函数，它们实现了 `stats.Channel` 接口。

`Subscribe` 函数接收一个 `Channel` 对象作为参数，然后执行以下操作：

1. 获取 `Channel` 对象的当前访问权限，并将其锁定。
2. 检查 `Channel` 对象已经设置的订阅者数量是否达到了其最大限制 `c.subsLimit`。
3. 如果订阅者数量已经达到了限制，则返回一个错误并输出 "Number of subscribers has reached limit"。
4. 如果 `c.subsLimit` 未设置或订阅者数量未达到限制，则执行以下操作：
  1. 将 `Channel` 对象的当前订阅者数量 `len(c.subscribers)` 存储在一个新通道中，并创建一个新的订阅者信道。
  2. 将新的订阅者信道添加到订阅者队列中。
  3. 返回新的订阅者信道和订阅者数量。

`Unsubscribe` 函数接收一个 `Channel` 对象和一个订阅者 `subscriber` 作为参数，然后执行以下操作：

1. 获取 `Channel` 对象的当前访问权限，并将其锁定。
2. 如果订阅者 `subscriber` 是当前订阅者信道中的内容，则执行以下操作：
  1. 将订阅者信道的内容复制到一个新的订阅者信道中，以避免修改原始数据。
  2. 去掉当前订阅者信道中所有已有的元素。
  3. 返回一个错误并输出 "Number of subscribers has reached limit"。
  4. 如果 `subscriber` 不是当前订阅者信道中的内容，则不做任何操作，直接返回 `nil`。


```go
// Subscribe implements stats.Channel.
func (c *Channel) Subscribe() (chan interface{}, error) {
	c.access.Lock()
	defer c.access.Unlock()
	if c.subsLimit > 0 && len(c.subscribers) >= c.subsLimit {
		return nil, newError("Number of subscribers has reached limit")
	}
	subscriber := make(chan interface{}, c.bufferSize)
	c.subscribers = append(c.subscribers, subscriber)
	return subscriber, nil
}

// Unsubscribe implements stats.Channel.
func (c *Channel) Unsubscribe(subscriber chan interface{}) error {
	c.access.Lock()
	defer c.access.Unlock()
	for i, s := range c.subscribers {
		if s == subscriber {
			// Copy to new memory block to prevent modifying original data
			subscribers := make([]chan interface{}, len(c.subscribers)-1)
			copy(subscribers[:i], c.subscribers[:i])
			copy(subscribers[i:], c.subscribers[i+1:])
			c.subscribers = subscribers
		}
	}
	return nil
}

```

这段代码定义了一个名为 `Publish` 的接口，它实现了 `stats.Channel` 统计信息通道的发布功能。

具体来说，当 `c` 是一个 `Channel` 实例时，它实现了 `Publish` 函数，会在 `ctx` 上下文中发布 `msg` 类型的消息。

如果 `c` 是一个关闭的 `Channel`, `Publish` 函数会在调用后立即返回，因为此时 `c` 已经不再接收新的消息。

如果 `c` 还处于 blocking 状态，那么它将发布消息到当前 `Channel` 实例上，否则它将发布消息到 `channelMessage` 类型的结构体中，然后传递给 `channelMessage.Publish` 函数。这个函数会在阻塞结束后调用，因此如果 `c` 在 blocking 状态中， `Publish` 函数不会发布消息，直到它被调用并处于空闲状态。

如果 `c` 仍然接收新的消息，那么 `publish` 函数将使用非阻塞方式发布消息，此时 `publishNonBlocking` 函数也会被调用。


```go
// Publish implements stats.Channel.
func (c *Channel) Publish(ctx context.Context, msg interface{}) {
	select { // Early exit if channel closed
	case <-c.closed:
		return
	default:
		pub := channelMessage{context: ctx, message: msg}
		if c.blocking {
			pub.publish(c.channel)
		} else {
			pub.publishNonBlocking(c.channel)
		}
	}
}

```

该代码定义了一个名为 "Channel" 的双向链表数据结构体，并在其中实现了 common.Runnable 的 common.Must 函数。

具体来说，该代码创建了一个 "Channel"，其中包含了所有已 subscribing 的 "subscriber" 到该 "Channel" 的 "publisher" 消息。通过一个名为 "Running" 的函数，可以决定该 "Channel" 是否正在运行，如果当前已经接收到了至少一个 "publisher" 消息，则认为该 "Channel" 处于运行状态，否则认为该 "Channel" 还没有被初始化，需要手动初始化。

另外，该代码还实现了一个名为 "Start" 的函数，用于启动一个 "Channel"。在该函数中，首先确保 "Channel" 已经处于运行状态，如果没有，则使用 make(chan struct{}) 创建一个 "channel" 并作为 "publisher" 发送一个闭包函数，该函数会在 "Channel" 初始化时执行。如果 "Channel" 已经处于运行状态，则执行一个异步函数，该函数会等待并接收来自 "Channel" 的 "publisher" 消息，并在收到消息时执行一系列操作，包括发送消息、移除订阅者、关闭 "Channel" 等。

该代码中定义了一个名为 "closed" 的 "channel" 变量，该变量记录 "Channel" 是否处于关闭状态，如果当前关闭，则该 "Channel" 不再接收任何消息，如果当前没有关闭，则说明 "Channel" 处于运行状态，可以接收消息。


```go
// Running returns whether the channel is running.
func (c *Channel) Running() bool {
	select {
	case <-c.closed: // Channel closed
	default: // Channel running or not initialized
		if c.closed != nil { // Channel initialized
			return true
		}
	}
	return false
}

// Start implements common.Runnable.
func (c *Channel) Start() error {
	c.access.Lock()
	defer c.access.Unlock()
	if !c.Running() {
		c.closed = make(chan struct{}) // Reset close signal
		go func() {
			for {
				select {
				case pub := <-c.channel: // Published message received
					for _, sub := range c.Subscribers() { // Concurrency-safe subscribers retrievement
						if c.blocking {
							pub.broadcast(sub)
						} else {
							pub.broadcastNonBlocking(sub)
						}
					}
				case <-c.closed: // Channel closed
					for _, sub := range c.Subscribers() { // Remove all subscribers
						common.Must(c.Unsubscribe(sub))
						close(sub)
					}
					return
				}
			}
		}()
	}
	return nil
}

```

该代码定义了一个名为 "Close" 的接口 "Closable"。这个接口有一个名为 "channelMessage" 的结构体，其中包含一个 "context" 字段和一个 "message" 字段。"channelMessage" 类型有一个 "message" 字段，它可以是一个实现了 " common.Closable" 协议的通道对象("Channel")。

该代码实现了一个 "Close" 函数，接收一个 "Channel" 类型的参数 "c"。这个函数先获取 "c"  channel 的访问锁，然后等待 "c" channel 结束运行，最后关闭 "c" channel 并返回一个 "nil" 表示成功。

具体来说，函数实现如下：

1. 获取 "c" channel 的访问锁，防止其他 goroutine 访问 "c" channel，保证只有一个 goroutine 在运行 "c" channel。

2. 关闭 "c" channel，并发送一个 "closed" 信号给 "c" channel，通知所有已经发送到 "c" channel 的数据都已丢失。

3. 如果 "c" channel 正在运行，则关闭 "c" channel，并返回一个 "nil" 表示成功。

4. 如果 "c" channel 已经关闭，则发送一个 "closed" 信号给 "c" channel，并返回一个非 "nil" 值，表示 "c" channel 已经关闭。


```go
// Close implements common.Closable.
func (c *Channel) Close() error {
	c.access.Lock()
	defer c.access.Unlock()
	if c.Running() {
		close(c.closed) // Send closed signal
	}
	return nil
}

// channelMessage is the published message with guaranteed delivery.
// message is discarded only when the context is early cancelled.
type channelMessage struct {
	context context.Context
	message interface{}
}

```

这两段代码都是基于一个名为 "channelMessage" 的通道类型的函数，它们的目的是让发布者（publisher）在接收者（channelMessage）上发送消息。

函数签名中，第一个函数 "func (c channelMessage) publish(publisher chan channelMessage)" 的作用是：当 "c" 通道中的数据 -> "publisher" 通道中的消息时，执行一次 "publish" 函数，并把 "publisher" 通道中的消息发送出去。

第二个函数 "func (c channelMessage) publishNonBlocking(publisher chan channelMessage)" 的作用是：在 "c" 通道中的数据 -> "publisher" 通道中的消息时，执行一次 "publishNonBlocking" 函数。这个函数与 "publish" 函数不同之处在于，它使用了 "select" 语句来等待 "publisher" 通道中的消息，而不是使用 "publish" 函数。如果 "publisher" 通道中没有消息，那么这个函数会自动创建一个 "goroutine" 来继续发送消息。


```go
func (c channelMessage) publish(publisher chan channelMessage) {
	select {
	case publisher <- c:
	case <-c.context.Done():
	}
}

func (c channelMessage) publishNonBlocking(publisher chan channelMessage) {
	select {
	case publisher <- c:
	default: // Create another goroutine to keep sending message
		go c.publish(publisher)
	}
}

```

这两段代码都是用于在给定通道（channel）上发送消息的功能。但它们之间存在一些关键的区别。

第一段代码（func (c channelMessage) broadcast(subscriber chan<interface{}>)）使用了通道（channel）的 `<-` 操作符。这个 `<-` 操作符的作用是在通道的 `<-` 操作中接收数据。这里的 `c.message` 是从通道的接收端（subscriber）获取的数据。如果订阅者（subscriber）提供了数据，则将其发送到 `c.channelMessage`。否则，如果 `c.context.Done()`，则表示所有发送操作已完成，可以停止发送，并从 `c.channelMessage` 获取之前未完成的发送数据。

第二段代码（func (c channelMessage) broadcastNonBlocking(subscriber chan<interface{}>)）在第一段代码的基础上，添加了一个名为 `c.broadcast` 的函数。这个函数与 `func (c channelMessage) broadcast` 类似，但使用了 `channelMessage` 而不是 `c.message`。`channelMessage` 是 `c` 通道的输入参数，而不是 `channel` 的输入参数。

综合来说，这两段代码都在尝试实现异步、非阻塞的消息传输。第一段代码将订阅者（subscriber）与通道（channel）的交互过程封装为异步函数，并在函数中执行了发送数据、等待数据完成等操作。第二段代码则提供了一种异步的方式，通过 `channelMessage` 函数将数据发送到 `c` 通道。


```go
func (c channelMessage) broadcast(subscriber chan interface{}) {
	select {
	case subscriber <- c.message:
	case <-c.context.Done():
	}
}

func (c channelMessage) broadcastNonBlocking(subscriber chan interface{}) {
	select {
	case subscriber <- c.message:
	default: // Create another goroutine to keep sending message
		go c.broadcast(subscriber)
	}
}

```

# `app/stats/channel_test.go`

This is a Go test that checks if a simple receiver function correctly receives messages from a given sender. The sender is selected from a list of channels, and the messages received from the sender are checked against a known expected output.

The function being tested is called `testReceiveMessage`, and it receives messages from the sender and checks if they match the expected output. If any of the messages received from the sender do not match the expected output, the test panics and reports an error.

The timeout for the test is set to 2 seconds, and if the test does not receive any messages within that time, it panics and reports a timeout error.

The expected output for the sender is `1 2 3`. This is because the sender is expected to produce messages with the same order as the numbers 1, 2, and 3.


```go
package stats_test

import (
	"context"
	"fmt"
	"testing"
	"time"

	. "v2ray.com/core/app/stats"
	"v2ray.com/core/common"
	"v2ray.com/core/features/stats"
)

func TestStatsChannel(t *testing.T) {
	// At most 2 subscribers could be registered
	c := NewChannel(&ChannelConfig{SubscriberLimit: 2, Blocking: true})

	a, err := stats.SubscribeRunnableChannel(c)
	common.Must(err)
	if !c.Running() {
		t.Fatal("unexpected failure in running channel after first subscription")
	}

	b, err := c.Subscribe()
	common.Must(err)

	// Test that third subscriber is forbidden
	_, err = c.Subscribe()
	if err == nil {
		t.Fatal("unexpected successful subscription")
	}
	t.Log("expected error: ", err)

	stopCh := make(chan struct{})
	errCh := make(chan string)

	go func() {
		c.Publish(context.Background(), 1)
		c.Publish(context.Background(), 2)
		c.Publish(context.Background(), "3")
		c.Publish(context.Background(), []int{4})
		stopCh <- struct{}{}
	}()

	go func() {
		if v, ok := (<-a).(int); !ok || v != 1 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", 1)
		}
		if v, ok := (<-a).(int); !ok || v != 2 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", 2)
		}
		if v, ok := (<-a).(string); !ok || v != "3" {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", "3")
		}
		if v, ok := (<-a).([]int); !ok || v[0] != 4 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", []int{4})
		}
		stopCh <- struct{}{}
	}()

	go func() {
		if v, ok := (<-b).(int); !ok || v != 1 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", 1)
		}
		if v, ok := (<-b).(int); !ok || v != 2 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", 2)
		}
		if v, ok := (<-b).(string); !ok || v != "3" {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", "3")
		}
		if v, ok := (<-b).([]int); !ok || v[0] != 4 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", []int{4})
		}
		stopCh <- struct{}{}
	}()

	timeout := time.After(2 * time.Second)
	for i := 0; i < 3; i++ {
		select {
		case <-timeout:
			t.Fatal("Test timeout after 2s")
		case e := <-errCh:
			t.Fatal(e)
		case <-stopCh:
		}
	}

	// Test the unsubscription of channel
	common.Must(c.Unsubscribe(b))

	// Test the last subscriber will close channel with `UnsubscribeClosableChannel`
	common.Must(stats.UnsubscribeClosableChannel(c, a))
	if c.Running() {
		t.Fatal("unexpected running channel after unsubscribing the last subscriber")
	}
}

```

This is a Go test that tests the receiving of data from a published channel. The `fmt.Println()` function is used to print error messages to the Sto了大量 if the expected value is not received.

The test has several steps:

1. The receive channel is sent a value.
2. A receive channel is sent a value.
3. The receive channel is sent a value.
4. The receive channel is sent a value.
5. The receive channel is sent a value.
6. The receive channel is sent a value.
7. The receive channel is sent a value.
8. The receive channel is sent a value.
9. The receive channel is sent a value.
10. The receive channel is sent a value.
11. The receive channel is sent a value.
12. The receive channel is sent a value.
13. The receive channel is sent a value.
14. The receive channel is sent a value.
15. The receive channel is sent a value.

The test checks if the receive channel receives the expected value in each step. If a value is not received within the given time, an error is printed to the Sto and the test ends. If a value is received within the given time, the test continues with the next step.


```go
func TestStatsChannelUnsubcribe(t *testing.T) {
	c := NewChannel(&ChannelConfig{Blocking: true})
	common.Must(c.Start())
	defer c.Close()

	a, err := c.Subscribe()
	common.Must(err)
	defer c.Unsubscribe(a)

	b, err := c.Subscribe()
	common.Must(err)

	pauseCh := make(chan struct{})
	stopCh := make(chan struct{})
	errCh := make(chan string)

	{
		var aSet, bSet bool
		for _, s := range c.Subscribers() {
			if s == a {
				aSet = true
			}
			if s == b {
				bSet = true
			}
		}
		if !(aSet && bSet) {
			t.Fatal("unexpected subscribers: ", c.Subscribers())
		}
	}

	go func() { // Blocking publish
		c.Publish(context.Background(), 1)
		<-pauseCh // Wait for `b` goroutine to resume sending message
		c.Publish(context.Background(), 2)
	}()

	go func() {
		if v, ok := (<-a).(int); !ok || v != 1 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", 1)
		}
		if v, ok := (<-a).(int); !ok || v != 2 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", 2)
		}
	}()

	go func() {
		if v, ok := (<-b).(int); !ok || v != 1 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", 1)
		}
		// Unsubscribe `b` while publishing is paused
		c.Unsubscribe(b)
		{ // Test `b` is not in subscribers
			var aSet, bSet bool
			for _, s := range c.Subscribers() {
				if s == a {
					aSet = true
				}
				if s == b {
					bSet = true
				}
			}
			if !(aSet && !bSet) {
				errCh <- fmt.Sprint("unexpected subscribers: ", c.Subscribers())
			}
		}
		// Resume publishing progress
		close(pauseCh)
		// Test `b` is neither closed nor able to receive any data
		select {
		case v, ok := <-b:
			if ok {
				errCh <- fmt.Sprint("unexpected data received: ", v)
			} else {
				errCh <- fmt.Sprint("unexpected closed channel: ", b)
			}
		default:
		}
		close(stopCh)
	}()

	select {
	case <-time.After(2 * time.Second):
		t.Fatal("Test timeout after 2s")
	case e := <-errCh:
		t.Fatal(e)
	case <-stopCh:
	}
}

```

This is a Go test that tests the behavior of a goroutine that publishes a message to a智造框 channel, and then stops the goroutine. The code uses the stopping-sort-test driver.

The goroutine that publishes the message using the `Publish` method from the `信使`Must

This is middleware，有一个停止按钮，还有两个错误字符串，当停止按钮被点击时，会将错误消息发送到该链


```go
func TestStatsChannelBlocking(t *testing.T) {
	// Do not use buffer so as to create blocking scenario
	c := NewChannel(&ChannelConfig{BufferSize: 0, Blocking: true})
	common.Must(c.Start())
	defer c.Close()

	a, err := c.Subscribe()
	common.Must(err)
	defer c.Unsubscribe(a)

	pauseCh := make(chan struct{})
	stopCh := make(chan struct{})
	errCh := make(chan string)

	ctx, cancel := context.WithCancel(context.Background())

	// Test blocking channel publishing
	go func() {
		// Dummy messsage with no subscriber receiving, will block broadcasting goroutine
		c.Publish(context.Background(), nil)

		<-pauseCh

		// Publishing should be blocked here, for last message was not cleared and buffer was full
		c.Publish(context.Background(), nil)

		pauseCh <- struct{}{}

		// Publishing should still be blocked here
		c.Publish(ctx, nil)

		// Check publishing is done because context is canceled
		select {
		case <-ctx.Done():
			if ctx.Err() != context.Canceled {
				errCh <- fmt.Sprint("unexpected error: ", ctx.Err())
			}
		default:
			errCh <- "unexpected non-blocked publishing"
		}
		close(stopCh)
	}()

	go func() {
		pauseCh <- struct{}{}

		select {
		case <-pauseCh:
			errCh <- "unexpected non-blocked publishing"
		case <-time.After(100 * time.Millisecond):
		}

		// Receive first published message
		<-a

		select {
		case <-pauseCh:
		case <-time.After(100 * time.Millisecond):
			errCh <- "unexpected blocking publishing"
		}

		// Manually cancel the context to end publishing
		cancel()
	}()

	select {
	case <-time.After(2 * time.Second):
		t.Fatal("Test timeout after 2s")
	case e := <-errCh:
		t.Fatal(e)
	case <-stopCh:
	}
}

```

This is a Go test that tests the functionality of a publish-subscribe implementation. The `PubSub` struct has a method `Publish(context.Context, message)` that sends a message to the given context and returns a channel `<-ch` indicating whether the publish operation was successful. The `Publish` method can also be cancelled using the `Cancel` method.

The `test` function uses a `go` block to run the `PubSub` implementation and a `select` statement to wait for events to occur. If the context is canceled, it will raise an error and the `select` statement will return an error channel `<-errCh`. If the operation takes longer than expected, it will raise an error and the `select` statement will return an error channel `<-stopCh`.

The `test` function also checks for certain errors that may occur. If the first published message is not received within a certain time, it raises an error and the `select` statement will return an error channel `<-errCh`. If the published messages are blocked and cannot be received, it raises an error and the `select` statement will return an error channel `<-stopCh`.

Overall, the `test` function is used to verify that the `PubSub` implementation works correctly and handles errors and timeouts as expected.


```go
func TestStatsChannelNonBlocking(t *testing.T) {
	// Do not use buffer so as to create blocking scenario
	c := NewChannel(&ChannelConfig{BufferSize: 0, Blocking: false})
	common.Must(c.Start())
	defer c.Close()

	a, err := c.Subscribe()
	common.Must(err)
	defer c.Unsubscribe(a)

	pauseCh := make(chan struct{})
	stopCh := make(chan struct{})
	errCh := make(chan string)

	ctx, cancel := context.WithCancel(context.Background())

	// Test blocking channel publishing
	go func() {
		c.Publish(context.Background(), nil)
		c.Publish(context.Background(), nil)
		pauseCh <- struct{}{}
		<-pauseCh
		c.Publish(ctx, nil)
		c.Publish(ctx, nil)
		// Check publishing is done because context is canceled
		select {
		case <-ctx.Done():
			if ctx.Err() != context.Canceled {
				errCh <- fmt.Sprint("unexpected error: ", ctx.Err())
			}
		case <-time.After(100 * time.Millisecond):
			errCh <- "unexpected non-cancelled publishing"
		}
	}()

	go func() {
		// Check publishing won't block even if there is no subscriber receiving message
		select {
		case <-pauseCh:
		case <-time.After(100 * time.Millisecond):
			errCh <- "unexpected blocking publishing"
		}

		// Receive first and second published message
		<-a
		<-a

		pauseCh <- struct{}{}

		// Manually cancel the context to end publishing
		cancel()

		// Check third and forth published message is cancelled and cannot receive
		<-time.After(100 * time.Millisecond)
		select {
		case <-a:
			errCh <- "unexpected non-cancelled publishing"
		default:
		}
		select {
		case <-a:
			errCh <- "unexpected non-cancelled publishing"
		default:
		}
		close(stopCh)
	}()

	select {
	case <-time.After(2 * time.Second):
		t.Fatal("Test timeout after 2s")
	case e := <-errCh:
		t.Fatal(e)
	case <-stopCh:
	}
}

```

This is a Go test that checks if a `select` statement inside a `for` loop behaves correctly.

The `select` statement checks if the value of a variable `v` is either `nil` or `int` as specified. If `v` is `nil`, the loop will continue with the next line, while if `v` is an `int`, the loop will exit.

The loop continuously reads the value of `a` and sends a message `<-a`. It then checks if the value of `v` is equal to `2`. If `v` is `int` and `v` is `2`, the loop will exit and a message will be sent to the channel `b`. If `v` is `nil` or `int` but `v` is not equal to `2`, the loop will continue and a message will be sent to the channel `b`.

If the loop completes without any errors, the test will end and the failure message will be printed to the channel `errCh`.


```go
func TestStatsChannelConcurrency(t *testing.T) {
	// Do not use buffer so as to create blocking scenario
	c := NewChannel(&ChannelConfig{BufferSize: 0, Blocking: true})
	common.Must(c.Start())
	defer c.Close()

	a, err := c.Subscribe()
	common.Must(err)
	defer c.Unsubscribe(a)

	b, err := c.Subscribe()
	common.Must(err)
	defer c.Unsubscribe(b)

	stopCh := make(chan struct{})
	errCh := make(chan string)

	go func() { // Blocking publish
		c.Publish(context.Background(), 1)
		c.Publish(context.Background(), 2)
	}()

	go func() {
		if v, ok := (<-a).(int); !ok || v != 1 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", 1)
		}
		if v, ok := (<-a).(int); !ok || v != 2 {
			errCh <- fmt.Sprint("unexpected receiving: ", v, ", wanted ", 2)
		}
	}()

	go func() {
		// Block `b` for a time so as to ensure source channel is trying to send message to `b`.
		<-time.After(25 * time.Millisecond)
		// This causes concurrency scenario: unsubscribe `b` while trying to send message to it
		c.Unsubscribe(b)
		// Test `b` is not closed and can still receive data 1:
		// Because unsubscribe won't affect the ongoing process of sending message.
		select {
		case v, ok := <-b:
			if v1, ok1 := v.(int); !(ok && ok1 && v1 == 1) {
				errCh <- fmt.Sprint("unexpected failure in receiving data: ", 1)
			}
		default:
			errCh <- fmt.Sprint("unexpected block from receiving data: ", 1)
		}
		// Test `b` is not closed but cannot receive data 2:
		// Because in a new round of messaging, `b` has been unsubscribed.
		select {
		case v, ok := <-b:
			if ok {
				errCh <- fmt.Sprint("unexpected receiving: ", v)
			} else {
				errCh <- fmt.Sprint("unexpected closing of channel")
			}
		default:
		}
		close(stopCh)
	}()

	select {
	case <-time.After(2 * time.Second):
		t.Fatal("Test timeout after 2s")
	case e := <-errCh:
		t.Fatal(e)
	case <-stopCh:
	}
}

```