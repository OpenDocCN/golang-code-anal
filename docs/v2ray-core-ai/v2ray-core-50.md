# v2ray-core源码解析 50

# `proxy/vless/inbound/config.go`

这段代码是一个 Go 语言中的管道模式（Pipe）结构体，它将两个已经存在的 Go 语言结构体 "短信推送平台推送流水信息" 和 "短信推送平台推送流水信息" 进行组合。通过执行以下操作：

1. 将两个结构体之间的 "推送流水信息" 字段设置为 true，使得第二个结构体中的所有元素都能够接收推送流水信息。
2. 通过 `+build` 选项，将整个包构建为字节码。
3. 通过 `!confonly` 选项，保证仅在 `build` 目录下输出文件，避免在当前工作目录下产生不必要的文件。
4. 使用 `package inbound` 来为组合的包指定一个名称，以便在需要时可以方便地引用。


```go
// +build !confonly

package inbound

```

# `proxy/vless/inbound/config.pb.go`

这段代码定义了一个名为`inbound`的包，其作用是处理`v2ray.com/core/common/protocol`协议中的消息。

具体来说，这段代码实现了以下功能：

1. 导入了`protoc-gen-go`和`protoc`两个依赖库，用于生成Go语言源代码的规范和定义。

2. 定义了一个名为`config.proto`的文件，该文件用于定义`inbound`包中使用的协议和消息类型。

3. 在`inbound`包的接口中，使用了`reflect`和`protocol`两个依赖库，分别用于在Go语言中反射`v2ray.com/core/common/protocol`协议和生成Go语言风格的`protoc`定义。

4. 在`inbound`包中实现了一个名为`Send`的函数，该函数接收一个`Message`参数，使用`protoc`定义的`config.proto`文件中定义的`Message`类型，将其转换为Go语言风格的`Message`对象，并调用`protocol.send`函数发送该消息。

5. 在`inbound`包中实现了一个名为`Listen`的函数，该函数接收一个`Message`参数，使用`protoc`定义的`config.proto`文件中定义的`Message`类型，将其转换为Go语言风格的`Message`对象，并调用`protocol.send`函数发送该消息，但不会输出任何确认信息。

6. 在`inbound`包中定义了一个名为`Config`的接口，该接口用于定义`inbound`包中使用的配置项。

7. 在`inbound`包中定义了一个名为`Header`的接口，该接口用于定义`inbound`包中使用的消息头。

8. 在`inbound`包中定义了一个名为`Credentials`的接口，该接口用于定义`inbound`包中使用的认证信息。

9. 在`inbound`包中定义了一个名为`Message`的类型，该类型包含一个`MessageType`字段和一个`MessageData`字段，其中`MessageType`字段用于指定消息类型，`MessageData`字段用于携带消息数据。

10. 在`inbound`包中定义了一个名为`SendOptions`的类型，该类型包含一个`Credentials`字段和一个`MessageOptions`字段，其中`Credentials`字段用于指定发送消息所需的认证信息，`MessageOptions`字段用于设置发送消息的选项。

11. 在`inbound`包中定义了一个名为`ListenOptions`的类型，该类型包含一个`MessageOptions`字段，用于指定`Listen`函数的选项。

12. 在`inbound`包中定义了一个名为`ClientConfig`的类型，该类型包含一个`Header`字段和一个`Credentials`字段，用于在客户端配置中设置`v2ray.com/core/common/protocol`协议的头部信息和认证信息。


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: proxy/vless/inbound/config.proto

package inbound

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	protocol "v2ray.com/core/common/protocol"
)

```

这段代码是一个包含两个const类型的声明，它们都使用了protobuf中的遗传算法来确保它们所引用的legacy proto包是一个足够古老和最新的版本。第一个const类型声明了该包的版本为20减去当前protobuf版本的最小版本，并要求在编译时检查该版本是否足够更新。第二个const类型声明了该包的版本为当前protobuf版本减去20的最大版本，并要求在编译时检查该版本是否足够更新。

此外，
该代码还包含一个Fallback结构体，其包含一个自定义的opt类型字段，用于定义该Fallback实例的输入和输出路径。


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Fallback struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Alpn string `protobuf:"bytes,1,opt,name=alpn,proto3" json:"alpn,omitempty"`
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Dest string `protobuf:"bytes,4,opt,name=dest,proto3" json:"dest,omitempty"`
	Xver uint64 `protobuf:"varint,5,opt,name=xver,proto3" json:"xver,omitempty"`
}

```

该代码定义了两个函数：

1. `func (x *Fallback) Reset()` 函数重置了 `x` 的值，并检查了 `protoimpl.UnsafeEnabled` 是否为真，如果是，则执行以下操作：

  - 创建一个 `Fallback` 类型的 `x` 变量 `x` 并将其设置为 `x = Fallback{}`。
  - 如果 `protoimpl.UnsafeEnabled` 为真，则执行以下操作：

    - 获取 `file_proxy_vless_inbound_config_proto_msgTypes` 类型的大括号 `{}` 中的第一个元素，它是一个指向 `file_proxy_vless_inbound_config_proto_msgTypes` 类型的指针。
    - 创建一个指向 `Fallback` 类型`*Fallback` 的指针 `x`。
    - 将 `x` 赋值为 `x = Fallback{}`。
    - 如果 `protoimpl.UnsafeEnabled` 为真，则执行以下操作：

      - 创建一个空的 `MessageInfo` 类型的 `ms`。
      - 将 `ms` 的值设置为 `ms = protoimpl.X.MessageStateOf(protoimpl.Pointer(x))`。
      - 将 `ms` 的 `MessageInfo` 字段设置为 `ms.StoreMessageInfo(mi)`。
      - 创建一个指向 `file_proxy_vless_inbound_config_proto_msgTypes` 类型的 `mi` 指针。
      - 将 `mi` 的值设置为 `mi = &file_proxy_vless_inbound_config_proto_msgTypes[0]`。
      - 将 `ms` 的 `MessageInfo` 字段设置为 `ms.StoreMessageInfo(mi)`。

2. `func (x *Fallback) String()` 函数返回了一个 `String` 类型，它使用 `protoimpl.X.MessageStringOf(x)` 将 `x` 转换为字符串，并将其返回。

3. `func (*Fallback) ProtoMessage()` 函数返回了一个 `Fallback` 类型的 `*Fallback` 指针，该指针使用 `protoimpl.X.MessageProxy` 类型定义了 `Fallback` 类型，从而使该指针可以被 `ProtoMessage` 函数接受。


```go
func (x *Fallback) Reset() {
	*x = Fallback{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proxy_vless_inbound_config_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Fallback) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Fallback) ProtoMessage() {}

```

此代码定义了一个名为"func"的函数，它接收一个名为"x"的参数，并返回一个名为"protoreflect.Message"的接口类型。

函数的作用是：

1. 如果传入的参数"x"不等于 nil，则执行以下操作：
a. 获取名为"file_proxy_vless_inbound_config_proto_msgTypes"的类型指的针。
b. 如果定义了"file_proxy_vless_inbound_config_proto_msgTypes"的函数，并且传入的参数"x"和"file_proxy_vless_inbound_config_proto_msgTypes"都对应于该类型，则执行以下操作：
i. 获取名为"mi"的类型指的针，它指向了"file_proxy_vless_inbound_config_proto_msgTypes"类型中的一种类型。
ii. 如果"file_proxy_vless_inbound_config_proto_msgTypes"定义了一个名为"msgTypes"的函数，并且"file_proxy_vless_inbound_config_proto_msgTypes"和"msgTypes"都对应于同一种类型，则执行以下操作：
ii. 从"x"中获取消息类型信息，并将其存储到"mi"中。
iii. 返回"mi"。
c. 如果未执行a或b操作，则执行以下操作：
i. 从"file_proxy_vless_inbound_config_proto_msgTypes"中获取一个未定义的类型，并将其存储到"mi"中。
ii. 从"x"中获取消息类型信息，并将其存储到"mi"中。
iii. 返回"mi"。
2. 如果传入的参数"x"为 nil，则返回一个名为"file_proxy_vless_inbound_config_proto_rawDescGZIP"的值，以及一个名为"0"的整数数组，表示该函数不需要返回任何信息。


```go
func (x *Fallback) ProtoReflect() protoreflect.Message {
	mi := &file_proxy_vless_inbound_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Fallback.ProtoReflect.Descriptor instead.
func (*Fallback) Descriptor() ([]byte, []int) {
	return file_proxy_vless_inbound_config_proto_rawDescGZIP(), []int{0}
}

```

这段代码定义了三个名为"func"的函数，它们的参数都接受一个名为"Fallback"的类型参数，并且返回字符串类型的值。

具体来说，这段代码实现了以下操作：

1. 对于传入的"Fallback"对象，如果该对象包含有效的Alpn、Path或Type，则分别返回这些值，否则返回一个空字符串。
2. 对于传入的"Fallback"对象，如果该对象包含有效的Alpn，则返回该Alpn，否则返回一个空字符串。
3. 对于传入的"Fallback"对象，如果该对象包含有效的Path，则返回该Path，否则返回一个空字符串。
4. 对于传入的"Fallback"对象，如果该对象包含有效的Type，则返回该Type，否则返回一个空字符串。

这段代码的具体实现可能是在处理"Fallback"类型的对象时，为了方便起见而定义的。


```go
func (x *Fallback) GetAlpn() string {
	if x != nil {
		return x.Alpn
	}
	return ""
}

func (x *Fallback) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *Fallback) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

```

此代码定义了一个名为 Config 的结构体类型，用于配置服务器的安全性选项，如客户端列表、加密设置和备用方案。

此代码定义了两个函数，分别名为 func 和 func。

func 函数接收一个名为 x 的指针参数，该参数是一个实现了 Config 类型的对象。函数首先检查 x 是否为空，如果是，则返回 x 的 Dest 字段，否则返回一个空字符串。

func 函数接收一个名为 x 的指针参数，该参数是一个实现了 Config 类型的对象。函数首先检查 x 是否为空，如果是，则返回 x 的 Xver 字段，否则返回 0。

此代码还定义了一个名为 Config 的结构体类型，用于定义服务器的安全性选项。此类型包含一个名为 clients 的字段，类型为 protocol.User，表示客户端列表，以及一个名为 decryption 的字段，类型为 string，表示加密设置，默认为 none。此类型还包含一个名为 fallbacks 的字段，类型为 Fallback，表示备用方案。

最后，此代码定义了一个代表 Config 的变量，并初始化了它的 clients、decryption 和 fallbacks 字段。


```go
func (x *Fallback) GetDest() string {
	if x != nil {
		return x.Dest
	}
	return ""
}

func (x *Fallback) GetXver() uint64 {
	if x != nil {
		return x.Xver
	}
	return 0
}

type Config struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Clients []*protocol.User `protobuf:"bytes,1,rep,name=clients,proto3" json:"clients,omitempty"`
	// Decryption settings. Only applies to server side, and only accepts "none"
	// for now.
	Decryption string      `protobuf:"bytes,2,opt,name=decryption,proto3" json:"decryption,omitempty"`
	Fallbacks  []*Fallback `protobuf:"bytes,3,rep,name=fallbacks,proto3" json:"fallbacks,omitempty"`
}

```

这段代码定义了两个函数：一个是`Reset`，另一个是`String`。这两个函数的行为是通过重置`Config`类型的实例变量`x`并返回其`*Config`类型的值，另一个是将`Config`类型实例的`*String`类型字段设置为`"undefined"`。

这里使用了`protoimpl`的类型定义，以便在函数中使用来自`file_proxy_vless_inbound_config_proto`的接口类型。`protoimpl.UnsafeEnabled`是一个布尔值，表示是否启用`file_proxy_vless_inbound_config_proto`类型中的`UnsafeEnabled`选项。如果启用，那么接下来的代码会创建一个`file_proxy_vless_inbound_config_proto.Config`实例，并将其赋值给`x`。

如果`protoimpl.UnsafeEnabled`为`true`，那么在函数内部，将创建一个新的`file_proxy_vless_inbound_config_proto.Config`实例，并将其设置为`x`的`*Config`类型的值。

函数`Reset`将`x`的值设置为`Config{}`类型，即一个空的`Config`实例。然后，如果`protoimpl.UnsafeEnabled`为`true`，将在`Reset`函数内部创建一个新的`file_proxy_vless_inbound_config_proto.Config`实例，并将其设置为`x`的`*Config`类型的值。

函数`String`返回`Config`类型实例的`*String`类型字段的值，即一个`string`类型的值。如果`protoimpl.UnsafeEnabled`为`true`，那么函数内部将创建一个新的`file_proxy_vless_inbound_config_proto.Config`实例，并将其设置为`x`的`*Config`类型的值。如果`protoimpl.UnsafeEnabled`为`false`，那么将返回一个特殊的`Config`类型，其值为`undefined`。


```go
func (x *Config) Reset() {
	*x = Config{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proxy_vless_inbound_config_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

```

此代码定义了两个函数，函数一是将传入的`Config`对象反射到`protoreflect.Message`类型上，函数二是返回`file_proxy_vless_inbound_config_proto_vless_inbound_config_proto`类型所需的字节数组和该类型的索引数组。

具体来说，函数一通过创建一个指向`file_proxy_vless_inbound_config_proto_msgTypes`类型对象的`mi`变量，并判断`protoimpl.UnsafeEnabled`的值是否为`true`，如果为`true`，则创建一个包含`x`对象的`messageStateOf`方法，并尝试从该方法中获取与`x`相关的`messageInfo`元数据。如果这个`messageInfo`元数据存在，则将其存储为与`mi`指向的`message_info`相同的位置，并返回。如果这个`messageInfo`元数据不存在，则创建一个新的`message_info`对象，其中包含`x`对象的`file_proxy_vless_inbound_config_proto_vless_inbound_config_proto`类型字段，并将其存储为与`mi`指向的`message_info`相同的位置。最后，函数一返回`mi`指向的`message_info`类型对象的`messageOf`方法返回的值。

函数二是使用`file_proxy_vless_inbound_config_proto_vless_inbound_config_proto`类型所需的字节数组和索引数组，其中`file_proxy_vless_inbound_config_proto_vless_inbound_config_proto`类型字段包含一个固定长度的字节数组，用于表示`file_proxy_vless_inbound_config_proto_vless_inbound_config_proto`类型对象的`descriptor`字段。函数二返回这个字节数组和索引数组。


```go
func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_proxy_vless_inbound_config_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_proxy_vless_inbound_config_proto_rawDescGZIP(), []int{1}
}

```

这首代码定义了三个函数，分别接收一个名为Config的*Config类型的参数。

函数1：`func (x *Config) GetClients() []*protocol.User {
	if x != nil {
		return x.Clients
	}
	return nil
}`
此函数接收一个Config类型的指针变量x，并在x不等于 nil的情况下返回x.Clients的数组。

函数2：`func (x *Config) GetDecryption() string {
	if x != nil {
		return x.Decryption
	}
	return ""
}`
此函数同样接收一个Config类型的指针变量x，并在x不等于 nil的情况下返回x.Decryption。

函数3：`func (x *Config) GetFallbacks() []*Fallback {
	if x != nil {
		return x.Fallbacks
	}
	return nil
}`
此函数同样接收一个Config类型的指针变量x，并在x不等于 nil的情况下返回x.Fallbacks的数组。


```go
func (x *Config) GetClients() []*protocol.User {
	if x != nil {
		return x.Clients
	}
	return nil
}

func (x *Config) GetDecryption() string {
	if x != nil {
		return x.Decryption
	}
	return ""
}

func (x *Config) GetFallbacks() []*Fallback {
	if x != nil {
		return x.Fallbacks
	}
	return nil
}

```

I'm sorry, I am not sure what you are asking. Could you please provide more context or clarify your question?



```go
var File_proxy_vless_inbound_config_proto protoreflect.FileDescriptor

var file_proxy_vless_inbound_config_proto_rawDesc = []byte{
	0x0a, 0x20, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2f, 0x76, 0x6c, 0x65, 0x73, 0x73, 0x2f, 0x69, 0x6e,
	0x62, 0x6f, 0x75, 0x6e, 0x64, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x12, 0x1e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x6c, 0x65, 0x73, 0x73, 0x2e, 0x69, 0x6e, 0x62, 0x6f, 0x75,
	0x6e, 0x64, 0x1a, 0x1a, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x6e,
	0x0a, 0x08, 0x46, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x6c,
	0x70, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x61, 0x6c, 0x70, 0x6e, 0x12, 0x12,
	0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x70, 0x61,
	0x74, 0x68, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x65, 0x73, 0x74, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x64, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x78, 0x76,
	0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x04, 0x78, 0x76, 0x65, 0x72, 0x22, 0xac,
	0x01, 0x0a, 0x06, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x3a, 0x0a, 0x07, 0x63, 0x6c, 0x69,
	0x65, 0x6e, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x76, 0x32, 0x72,
	0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x07, 0x63, 0x6c,
	0x69, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x64, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x64, 0x65, 0x63, 0x72, 0x79,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x46, 0x0a, 0x09, 0x66, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63,
	0x6b, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79,
	0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x6c, 0x65, 0x73,
	0x73, 0x2e, 0x69, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x2e, 0x46, 0x61, 0x6c, 0x6c, 0x62, 0x61,
	0x63, 0x6b, 0x52, 0x09, 0x66, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x73, 0x42, 0x6b, 0x0a,
	0x22, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x6c, 0x65, 0x73, 0x73, 0x2e, 0x69, 0x6e, 0x62, 0x6f,
	0x75, 0x6e, 0x64, 0x50, 0x01, 0x5a, 0x22, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2f, 0x76, 0x6c, 0x65, 0x73,
	0x73, 0x2f, 0x69, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0xaa, 0x02, 0x1e, 0x56, 0x32, 0x52, 0x61,
	0x79, 0x2e, 0x43, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x56, 0x6c, 0x65,
	0x73, 0x73, 0x2e, 0x49, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x33,
}

```

这段代码定义了一个名为file_proxy_vless_inbound_config_proto_rawDescOnce的变量，该变量是一个 sync.Once 类型的局部变量，作用于一个名为file_proxy_vless_inbound_config_proto_rawDescData的变量上。

函数file_proxy_vless_inbound_config_proto_rawDescGZIP()返回一个字节切片，其中包含经过GZIP压缩的file_proxy_vless_inbound_config_proto_rawDescData。

函数file_proxy_vless_inbound_config_proto_rawDescCompact()返回一个字节切片，其中包含没有经过GZIP压缩的file_proxy_vless_inbound_config_proto_rawDescData。

函数file_proxy_vless_inbound_config_proto_getRawDescOnce()返回一个Fallback类型的局部变量，该变量使用file_proxy_vless_inbound_config_proto_rawDescOnce.Do()函数来设置。

函数file_proxy_vless_inbound_config_proto_getConfigOnce()返回一个Config类型的局部变量，该变量使用file_proxy_vless_inbound_config_proto_rawDescOnce.Do()函数来设置。

函数file_proxy_vless_inbound_config_proto_getUserOnce()返回一个User类型的局部变量，该变量使用file_proxy_vless_inbound_config_proto_rawDescOnce.Do()函数来设置。


```go
var (
	file_proxy_vless_inbound_config_proto_rawDescOnce sync.Once
	file_proxy_vless_inbound_config_proto_rawDescData = file_proxy_vless_inbound_config_proto_rawDesc
)

func file_proxy_vless_inbound_config_proto_rawDescGZIP() []byte {
	file_proxy_vless_inbound_config_proto_rawDescOnce.Do(func() {
		file_proxy_vless_inbound_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_proxy_vless_inbound_config_proto_rawDescData)
	})
	return file_proxy_vless_inbound_config_proto_rawDescData
}

var file_proxy_vless_inbound_config_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_proxy_vless_inbound_config_proto_goTypes = []interface{}{
	(*Fallback)(nil),      // 0: v2ray.core.proxy.vless.inbound.Fallback
	(*Config)(nil),        // 1: v2ray.core.proxy.vless.inbound.Config
	(*protocol.User)(nil), // 2: v2ray.core.common.protocol.User
}
```

This is a Go-based implementation of the file "file\_proxy\_vless\_inbound\_config.proto". It defines the structure of the internal representation of the configuration message for the代理.

The message type for the configuration message is defined as follows:


type Config struct {
	State    *ConfigState 
	SizeCache int64   
	Unknown  []byte   `unknown field"`
}

type ConfigState struct {
	// Internal field for some data.
}

type int64        `int64"`
type x           `xml:logic`


The `Config` message type has a single field, `State`, which is of type `ConfigState`. The `ConfigState` message type is defined as follows:


type ConfigState struct {
	// Data for the state field.
}


The `x` field is used to indicate the actual value that should be added to the `ConfigState` message type.

The `SizeCache` field is of type `int64` and represents the size of the cache associated with the configuration.

The `Unknown` field is a byte array of unknown size.

The `Exporter` field is defined as a function that returns an interface{} of the `Config` message type. This allows for the implementation of the ProtoBuf listener to report the contents of the `Config` message to the external systems.


func (v, i) ConfigExporter(v interface{}, i int) interface{} {
	// The exporter for the Config message type.
}


The `ConfigCompiler` function is defined as follows:


func ConfigCompiler(f *proto.F, r *proto.R) error {
	// The compiler for the Config message type.
}


The `ConfigDecoder` function is defined as follows:


func ConfigDecoder(在读消费特性的实现中...



```go
var file_proxy_vless_inbound_config_proto_depIdxs = []int32{
	2, // 0: v2ray.core.proxy.vless.inbound.Config.clients:type_name -> v2ray.core.common.protocol.User
	0, // 1: v2ray.core.proxy.vless.inbound.Config.fallbacks:type_name -> v2ray.core.proxy.vless.inbound.Fallback
	2, // [2:2] is the sub-list for method output_type
	2, // [2:2] is the sub-list for method input_type
	2, // [2:2] is the sub-list for extension type_name
	2, // [2:2] is the sub-list for extension extendee
	0, // [0:2] is the sub-list for field type_name
}

func init() { file_proxy_vless_inbound_config_proto_init() }
func file_proxy_vless_inbound_config_proto_init() {
	if File_proxy_vless_inbound_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proxy_vless_inbound_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Fallback); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proxy_vless_inbound_config_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proxy_vless_inbound_config_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proxy_vless_inbound_config_proto_goTypes,
		DependencyIndexes: file_proxy_vless_inbound_config_proto_depIdxs,
		MessageInfos:      file_proxy_vless_inbound_config_proto_msgTypes,
	}.Build()
	File_proxy_vless_inbound_config_proto = out.File
	file_proxy_vless_inbound_config_proto_rawDesc = nil
	file_proxy_vless_inbound_config_proto_goTypes = nil
	file_proxy_vless_inbound_config_proto_depIdxs = nil
}

```

# `proxy/vless/inbound/errors.generated.go`

这段代码定义了一个名为"inbound"的包，其中包含一个名为"errPathObjHolder"的结构体。

在该结构体中，使用了单例模式来创建一个名为"errPathObjHolder"的实例，这个实例的初始值为一个空字符串 ""。

该代码还定义了一个名为"newError"的函数，该函数接收多个参数，这些参数可以是任何类型的实际值（包括接口类型）。

该函数返回一个带有错误对象和错误路径对象的错误对象，同时使用了错误路径对象（errPathObjHolder）来设置错误路径对象。

最后，该代码还导入了"v2ray.com/core/common/errors"包，以便在函数中可以安全地使用其错误处理函数。


```go
package inbound

import "v2ray.com/core/common/errors"

type errPathObjHolder struct{}

func newError(values ...interface{}) *errors.Error {
	return errors.New(values...).WithPathObj(errPathObjHolder{})
}

```

# `proxy/vless/inbound/inbound.go`

这段代码是一个 Go 语言编写的程序，旨在实现 V2Ray 代理服务器的一个功能，即让代理服务器可以通过 HTTP 或 TCP 协议代理外网请求，并将请求转发给代理客户端。下面是解释该程序的一些关键部分：

1. `// +build !confonly`：这是一个构建模式，表示在构建代码时会生成 ` incompatible_additions.txt` 文件，该文件记录了当前目录下不支持构建的依赖关系，从而禁止构建。
2. `package inbound`：定义了名为 "inbound" 的包，该包包含了与代理服务器相关的功能。
3. `//go:generate go run v2ray.com/core/common/errors/errorgen`：这是一个 Go 语言生成的脚本，用于生成包含 `v2ray.com/core/common/errors` 包中错误处理程序的代码。
4. `import (`：导入了一些需要使用的包，包括：`v2ray.com/core`、`v2ray.com/core/common`、`v2ray.com/core/errors`、`v2ray.com/core/net`、`v2ray.com/core/platform`、`v2ray.com/core/protocol`、`v2ray.com/core/features/dns`、`v2ray.com/core/features/policy`、`v2ray.com/core/features/routing`、`v2ray.com/core/proxy/vless`、`v2ray.com/core/proxy/vless/encoding`、`v2ray.com/core/transport/internet`、`v2ray.com/core/transport/internet/tls` 和 `v2ray.com/core/transport/internet/xtls`。
5. `const (`：定义了一些常量，包括：`INBOUND_CLIENT_CONNECT_PORT`、`INBOUND_CLIENT_PORT`、`INBOUND_SERVER_ADDRESS` 和 `INBOUND_TCP_PORT`，这些常量用于配置代理服务器监听的外网接口。
6. `package net`：导入了一个名为 "net" 的包，该包包含了与网络相关的功能。
7. `import (`：导入了一个名为 "encoding" 的包，该包包含了与编码相关的功能。
8. `import (`：导入了一个名为 "errors" 的包，该包包含了与错误相关的功能。
9. `import (`：导入了一个名为 "log" 的包，该包包含了与日志相关的功能。
10. `import (`：导入了一个名为 "net" 的包，该包包含了与网络相关的功能。
11. `import (`：导入了一个名为 "platform" 的包，该包包含了与平台相关的功能。
12. `import (`：导入了一个名为 "protocol" 的包，该包包含了与协议相关的功能。
13. `import (`：导入了一个名为 "task" 的包，该包包含了与任务相关的功能。
14. `import (`：导入了一个名为 "dns" 的包，该包包含了与 DNS 相关的功能。
15. `import "v2ray.com/core/features/inbound"`：导入了一个名为 "v2ray.com/core/features/inbound" 的包，该包包含了与传入代理服务器相关的功能。
16. `import "v2ray.com/core/features/policy"`：导入了一个名为 "v2ray.com/core/features/policy" 的包，该包包含了与代理服务器策略相关的功能。
17. `import "v2ray.com/core/features/routing"`：导入了一个名为 "v2ray.com/core/features/routing" 的包，该包包含了与路由相关的功能。
18. `import "v2ray.com/core/features/proxy/vless"`：导入了一个名为 "v2ray.com/core/features/proxy/vless" 的包，该包包含了与 Lambda 代理客户端相关的功能。
19. `import "v2ray.com/core/features/proxy/vless/encoding"`：导入了一个名为 "v2ray.com/core/features/proxy/vless/encoding" 的包，该包包含了与 Lambda 代理客户端相关的编码功能。
20. `import "v2ray.com/core/features/internet"`：导入了一个名为 "v2ray.com/core/features/internet" 的包，该包包含了与互联网相关的功能。
21. `import "v2ray.com/core/features/transport/internet"`：导入了一个名为 "v2ray.com/core/features/transport/internet" 的包，该包包含了与互联网相关的功能。
22. `import "v2ray.com/core/features/transport/internet/tls"`：导入了一个名为 "v2ray.com/core/features/transport/internet/tls" 的包，该包包含了与 TLS 相关的功能。
23. `import "v2ray.com/core/features/transport/internet/xtls"`：导入了一个名为 "v2ray.com/core/features/transport/internet/xtls" 的包，该包包含了与 XTLS 相关的功能。
24. `package v2ray.com/core`：导入了 `v2ray.com/core` 包中的所有功能，从而让该代理服务器具有了发送、接收 HTTP/HTTPS 请求的功能。
25. `const INBOUND_CLIENT_CONNECT_PORT = 5000`：定义了 `INBOUND_CLIENT_CONNECT_PORT`，该常量表示了该代理服务器监听的外网客户端连接端口。
26. `const INBOUND_SERVER_ADDRESS = "0.0.0.0"`：定义了 `INBOUND_SERVER_ADDRESS`，该常量表示了该代理服务器监听的外网服务器地址，此处为所有对外暴露的 IP 地址。
27. `const INBOUND_TCP_PORT = 12345`：定义了 `INBOUND_TCP_PORT`，该常量表示了该代理服务器监听的外网 TCP 端口。
28. `const OUTBOUND_CLIENT_CONNECT_PORT = 5000`：定义了 `OUTBOUND_CLIENT_CONNECT_PORT`，该常量表示了该代理服务器监听的外网客户端连接端口。
29. `const OUTBOUND_SERVER_ADDRESS = "0.0.0.0"`：定义了 `OUTBOUND_SERVER_ADDRESS`，该常量表示了该代理服务器监听的外网服务器地址，此处为所有对外暴露的 IP 地址。
30. `const OUTBOUND_TCP_PORT = 12345`：


```go
// +build !confonly

package inbound

//go:generate go run v2ray.com/core/common/errors/errorgen

import (
	"context"
	"io"
	"strconv"
	"time"

	"v2ray.com/core"
	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	"v2ray.com/core/common/errors"
	"v2ray.com/core/common/log"
	"v2ray.com/core/common/net"
	"v2ray.com/core/common/platform"
	"v2ray.com/core/common/protocol"
	"v2ray.com/core/common/retry"
	"v2ray.com/core/common/session"
	"v2ray.com/core/common/signal"
	"v2ray.com/core/common/task"
	"v2ray.com/core/features/dns"
	feature_inbound "v2ray.com/core/features/inbound"
	"v2ray.com/core/features/policy"
	"v2ray.com/core/features/routing"
	"v2ray.com/core/proxy/vless"
	"v2ray.com/core/proxy/vless/encoding"
	"v2ray.com/core/transport/internet"
	"v2ray.com/core/transport/internet/tls"
	"v2ray.com/core/transport/internet/xtls"
)

```

这段代码定义了一个名为“xtls_show”的变量，其初始值为false。接着定义了一个名为“init”的函数，函数内部创建了一个名为“dc”的dns.Client实例，通过调用“registerConfig”函数来设置dns.Client为“nil”时，函数不会产生任何错误。然后使用“New”函数创建一个新的“xtls”实例，将“dc”设置为“dc”实例的地址，然后将“defaultFlagValue”作为参数传递给“New”函数。

然后定义了一个名为“xtlsShow”的变量，通过调用“GetValue”函数获取“v2ray.vless.xtls.show”环境变量的默认值，如果当前环境变量存在，则返回它的值，否则将“NOT_DEFINED_AT_ALL”作为值返回。最后，通过判断“xtlsShow”的值是否为“true”来控制是否显示v2ray的xtls功能。


```go
var (
	xtls_show = false
)

func init() {
	common.Must(common.RegisterConfig((*Config)(nil), func(ctx context.Context, config interface{}) (interface{}, error) {
		var dc dns.Client
		if err := core.RequireFeatures(ctx, func(d dns.Client) error {
			dc = d
			return nil
		}); err != nil {
			return nil, err
		}
		return New(ctx, config.(*Config), dc)
	}))

	const defaultFlagValue = "NOT_DEFINED_AT_ALL"

	xtlsShow := platform.NewEnvFlag("v2ray.vless.xtls.show").GetValue(func() string { return defaultFlagValue })
	if xtlsShow == "true" {
		xtls_show = true
	}
}

```

This is a Go function that creates a VLESS user if specified by config.VLESSUser and adds the user to the specified handler. It uses the regexp.Regexp and Fallback map configurations defined in the config.

MemoryUser() function:

* It checks if there's an error initializing the user by config.
* If there's an error, it creates a new error and returns it with a message.
* If the initialization is successful, it adds the user to the handler and returns the handler.

If config.Fallbacks is not empty, it adds the fallbacks to the handler and initializes it with the map.

If the handler is initialized with a fallback that doesn't exist, it creates a new fallback map.

It finally, it checks if the handler has a fallback for an empty fallback map and, if it does, it loops through all the paths and adds the corresponding fallback to the handler's fallbacks map.

It also, if the handler's fallback maps have a fallback with a path that's a regexp, it compiles the regexp and stores it in the regexp map.


```go
// Handler is an inbound connection handler that handles messages in VLess protocol.
type Handler struct {
	inboundHandlerManager feature_inbound.Manager
	policyManager         policy.Manager
	validator             *vless.Validator
	dns                   dns.Client
	fallbacks             map[string]map[string]*Fallback // or nil
	//regexps               map[string]*regexp.Regexp       // or nil
}

// New creates a new VLess inbound handler.
func New(ctx context.Context, config *Config, dc dns.Client) (*Handler, error) {

	v := core.MustFromContext(ctx)
	handler := &Handler{
		inboundHandlerManager: v.GetFeature(feature_inbound.ManagerType()).(feature_inbound.Manager),
		policyManager:         v.GetFeature(policy.ManagerType()).(policy.Manager),
		validator:             new(vless.Validator),
		dns:                   dc,
	}

	for _, user := range config.Clients {
		u, err := user.ToMemoryUser()
		if err != nil {
			return nil, newError("failed to get VLESS user").Base(err).AtError()
		}
		if err := handler.AddUser(ctx, u); err != nil {
			return nil, newError("failed to initiate user").Base(err).AtError()
		}
	}

	if config.Fallbacks != nil {
		handler.fallbacks = make(map[string]map[string]*Fallback)
		//handler.regexps = make(map[string]*regexp.Regexp)
		for _, fb := range config.Fallbacks {
			if handler.fallbacks[fb.Alpn] == nil {
				handler.fallbacks[fb.Alpn] = make(map[string]*Fallback)
			}
			handler.fallbacks[fb.Alpn][fb.Path] = fb
			/*
				if fb.Path != "" {
					if r, err := regexp.Compile(fb.Path); err != nil {
						return nil, newError("invalid path regexp").Base(err).AtError()
					} else {
						handler.regexps[fb.Path] = r
					}
				}
			*/
		}
		if handler.fallbacks[""] != nil {
			for alpn, pfb := range handler.fallbacks {
				if alpn != "" { // && alpn != "h2" {
					for path, fb := range handler.fallbacks[""] {
						if pfb[path] == nil {
							pfb[path] = fb
						}
					}
				}
			}
		}
	}

	return handler, nil
}

```

这段代码定义了两个函数，分别是 `Close` 和 `AddUser` 和 `RemoveUser`，它们都属于一个名为 `Handler` 的链式调用接口。

具体来说，这段代码实现了一个链式处理程序，当接收到一个 `Close` 请求时，会执行该程序内部的一个名为 `Close` 的函数，并且将该函数的输入参数 `h` 作为参数传递。而 `Close` 函数的实现则实现了 `common.Closable.Close()`，根据输入参数 `h` 的验证结果返回一个 `error`。

另外，`AddUser` 和 `RemoveUser` 函数的实现则实现了 `proxy.UserManager.AddUser()` 和 `proxy.UserManager.RemoveUser()`，它们的具体实现方法则根据输入参数的不同而有所不同。


```go
// Close implements common.Closable.Close().
func (h *Handler) Close() error {
	return errors.Combine(common.Close(h.validator))
}

// AddUser implements proxy.UserManager.AddUser().
func (h *Handler) AddUser(ctx context.Context, u *protocol.MemoryUser) error {
	return h.validator.Add(u)
}

// RemoveUser implements proxy.UserManager.RemoveUser().
func (h *Handler) RemoveUser(ctx context.Context, e string) error {
	return h.validator.Del(e)
}

```

This is a Go function called `getResponse` that retrieves the response from a server based on a given request and optionally a response payload. It returns the response or an error if an error occurs or the server is unavailable.

The function takes a connection object `conn` and a request object `req` as


```go
// Network implements proxy.Inbound.Network().
func (*Handler) Network() []net.Network {
	return []net.Network{net.Network_TCP}
}

// Process implements proxy.Inbound.Process().
func (h *Handler) Process(ctx context.Context, network net.Network, connection internet.Connection, dispatcher routing.Dispatcher) error {

	sid := session.ExportIDToError(ctx)

	iConn := connection
	if statConn, ok := iConn.(*internet.StatCouterConnection); ok {
		iConn = statConn.Connection
	}

	sessionPolicy := h.policyManager.ForLevel(0)
	if err := connection.SetReadDeadline(time.Now().Add(sessionPolicy.Timeouts.Handshake)); err != nil {
		return newError("unable to set read deadline").Base(err).AtWarning()
	}

	first := buf.New()
	defer first.Release()

	firstLen, _ := first.ReadFrom(connection)
	newError("firstLen = ", firstLen).AtInfo().WriteToLog(sid)

	reader := &buf.BufferedReader{
		Reader: buf.NewReader(connection),
		Buffer: buf.MultiBuffer{first},
	}

	var request *protocol.RequestHeader
	var requestAddons *encoding.Addons
	var err error

	apfb := h.fallbacks
	isfb := apfb != nil

	if isfb && firstLen < 18 {
		err = newError("fallback directly")
	} else {
		request, requestAddons, err, isfb = encoding.DecodeRequestHeader(isfb, first, reader, h.validator)
	}

	if err != nil {

		if isfb {
			if err := connection.SetReadDeadline(time.Time{}); err != nil {
				newError("unable to set back read deadline").Base(err).AtWarning().WriteToLog(sid)
			}
			newError("fallback starts").Base(err).AtInfo().WriteToLog(sid)

			alpn := ""
			if len(apfb) > 1 || apfb[""] == nil {
				if tlsConn, ok := iConn.(*tls.Conn); ok {
					alpn = tlsConn.ConnectionState().NegotiatedProtocol
					newError("realAlpn = " + alpn).AtInfo().WriteToLog(sid)
				} else if xtlsConn, ok := iConn.(*xtls.Conn); ok {
					alpn = xtlsConn.ConnectionState().NegotiatedProtocol
					newError("realAlpn = " + alpn).AtInfo().WriteToLog(sid)
				}
				if apfb[alpn] == nil {
					alpn = ""
				}
			}
			pfb := apfb[alpn]
			if pfb == nil {
				return newError(`failed to find the default "alpn" config`).AtWarning()
			}

			path := ""
			if len(pfb) > 1 || pfb[""] == nil {
				/*
					if lines := bytes.Split(firstBytes, []byte{'\r', '\n'}); len(lines) > 1 {
						if s := bytes.Split(lines[0], []byte{' '}); len(s) == 3 {
							if len(s[0]) < 8 && len(s[1]) > 0 && len(s[2]) == 8 {
								newError("realPath = " + string(s[1])).AtInfo().WriteToLog(sid)
								for _, fb := range pfb {
									if fb.Path != "" && h.regexps[fb.Path].Match(s[1]) {
										path = fb.Path
										break
									}
								}
							}
						}
					}
				*/
				if firstLen >= 18 && first.Byte(4) != '*' { // not h2c
					firstBytes := first.Bytes()
					for i := 4; i <= 8; i++ { // 5 -> 9
						if firstBytes[i] == '/' && firstBytes[i-1] == ' ' {
							search := len(firstBytes)
							if search > 64 {
								search = 64 // up to about 60
							}
							for j := i + 1; j < search; j++ {
								k := firstBytes[j]
								if k == '\r' || k == '\n' { // avoid logging \r or \n
									break
								}
								if k == ' ' {
									path = string(firstBytes[i:j])
									newError("realPath = " + path).AtInfo().WriteToLog(sid)
									if pfb[path] == nil {
										path = ""
									}
									break
								}
							}
							break
						}
					}
				}
			}
			fb := pfb[path]
			if fb == nil {
				return newError(`failed to find the default "path" config`).AtWarning()
			}

			ctx, cancel := context.WithCancel(ctx)
			timer := signal.CancelAfterInactivity(ctx, cancel, sessionPolicy.Timeouts.ConnectionIdle)
			ctx = policy.ContextWithBufferPolicy(ctx, sessionPolicy.Buffer)

			var conn net.Conn
			if err := retry.ExponentialBackoff(5, 100).On(func() error {
				var dialer net.Dialer
				conn, err = dialer.DialContext(ctx, fb.Type, fb.Dest)
				if err != nil {
					return err
				}
				return nil
			}); err != nil {
				return newError("failed to dial to " + fb.Dest).Base(err).AtWarning()
			}
			defer conn.Close() // nolint: errcheck

			serverReader := buf.NewReader(conn)
			serverWriter := buf.NewWriter(conn)

			postRequest := func() error {
				defer timer.SetTimeout(sessionPolicy.Timeouts.DownlinkOnly)
				if fb.Xver != 0 {
					remoteAddr, remotePort, err := net.SplitHostPort(connection.RemoteAddr().String())
					if err != nil {
						return err
					}
					localAddr, localPort, err := net.SplitHostPort(connection.LocalAddr().String())
					if err != nil {
						return err
					}
					ipv4 := true
					for i := 0; i < len(remoteAddr); i++ {
						if remoteAddr[i] == ':' {
							ipv4 = false
							break
						}
					}
					pro := buf.New()
					defer pro.Release()
					switch fb.Xver {
					case 1:
						if ipv4 {
							pro.Write([]byte("PROXY TCP4 " + remoteAddr + " " + localAddr + " " + remotePort + " " + localPort + "\r\n"))
						} else {
							pro.Write([]byte("PROXY TCP6 " + remoteAddr + " " + localAddr + " " + remotePort + " " + localPort + "\r\n"))
						}
					case 2:
						pro.Write([]byte("\x0D\x0A\x0D\x0A\x00\x0D\x0A\x51\x55\x49\x54\x0A\x21")) // signature + v2 + PROXY
						if ipv4 {
							pro.Write([]byte("\x11\x00\x0C")) // AF_INET + STREAM + 12 bytes
							pro.Write(net.ParseIP(remoteAddr).To4())
							pro.Write(net.ParseIP(localAddr).To4())
						} else {
							pro.Write([]byte("\x21\x00\x24")) // AF_INET6 + STREAM + 36 bytes
							pro.Write(net.ParseIP(remoteAddr).To16())
							pro.Write(net.ParseIP(localAddr).To16())
						}
						p1, _ := strconv.ParseUint(remotePort, 10, 16)
						p2, _ := strconv.ParseUint(localPort, 10, 16)
						pro.Write([]byte{byte(p1 >> 8), byte(p1), byte(p2 >> 8), byte(p2)})
					}
					if err := serverWriter.WriteMultiBuffer(buf.MultiBuffer{pro}); err != nil {
						return newError("failed to set PROXY protocol v", fb.Xver).Base(err).AtWarning()
					}
				}
				if err := buf.Copy(reader, serverWriter, buf.UpdateActivity(timer)); err != nil {
					return newError("failed to fallback request payload").Base(err).AtInfo()
				}
				return nil
			}

			writer := buf.NewWriter(connection)

			getResponse := func() error {
				defer timer.SetTimeout(sessionPolicy.Timeouts.UplinkOnly)
				if err := buf.Copy(serverReader, writer, buf.UpdateActivity(timer)); err != nil {
					return newError("failed to deliver response payload").Base(err).AtInfo()
				}
				return nil
			}

			if err := task.Run(ctx, task.OnSuccess(postRequest, task.Close(serverWriter)), task.OnSuccess(getResponse, task.Close(writer))); err != nil {
				common.Interrupt(serverReader)
				common.Interrupt(serverWriter)
				return newError("fallback ends").Base(err).AtInfo()
			}
			return nil
		}

		if errors.Cause(err) != io.EOF {
			log.Record(&log.AccessMessage{
				From:   connection.RemoteAddr(),
				To:     "",
				Status: log.AccessRejected,
				Reason: err,
			})
			err = newError("invalid request from ", connection.RemoteAddr()).Base(err).AtWarning()
		}
		return err
	}

	if err := connection.SetReadDeadline(time.Time{}); err != nil {
		newError("unable to set back read deadline").Base(err).AtWarning().WriteToLog(sid)
	}
	newError("received request for ", request.Destination()).AtInfo().WriteToLog(sid)

	inbound := session.InboundFromContext(ctx)
	if inbound == nil {
		panic("no inbound metadata")
	}
	inbound.User = request.User

	account := request.User.Account.(*vless.MemoryAccount)

	responseAddons := &encoding.Addons{
		//Flow: requestAddons.Flow,
	}

	switch requestAddons.Flow {
	case vless.XRO, vless.XRD:
		if account.Flow == requestAddons.Flow {
			switch request.Command {
			case protocol.RequestCommandMux:
				return newError(requestAddons.Flow + " doesn't support Mux").AtWarning()
			case protocol.RequestCommandUDP:
				return newError(requestAddons.Flow + " doesn't support UDP").AtWarning()
			case protocol.RequestCommandTCP:
				if xtlsConn, ok := iConn.(*xtls.Conn); ok {
					xtlsConn.RPRX = true
					xtlsConn.SHOW = xtls_show
					xtlsConn.MARK = "XTLS"
					if requestAddons.Flow == vless.XRD {
						xtlsConn.DirectMode = true
					}
				} else {
					return newError(`failed to use ` + requestAddons.Flow + `, maybe "security" is not "xtls"`).AtWarning()
				}
			}
		} else {
			return newError(account.ID.String() + " is not able to use " + requestAddons.Flow).AtWarning()
		}
	case "":
	default:
		return newError("unknown request flow " + requestAddons.Flow).AtWarning()
	}

	if request.Command != protocol.RequestCommandMux {
		ctx = log.ContextWithAccessMessage(ctx, &log.AccessMessage{
			From:   connection.RemoteAddr(),
			To:     request.Destination(),
			Status: log.AccessAccepted,
			Reason: "",
			Email:  request.User.Email,
		})
	}

	sessionPolicy = h.policyManager.ForLevel(request.User.Level)
	ctx, cancel := context.WithCancel(ctx)
	timer := signal.CancelAfterInactivity(ctx, cancel, sessionPolicy.Timeouts.ConnectionIdle)
	ctx = policy.ContextWithBufferPolicy(ctx, sessionPolicy.Buffer)

	link, err := dispatcher.Dispatch(ctx, request.Destination())
	if err != nil {
		return newError("failed to dispatch request to ", request.Destination()).Base(err).AtWarning()
	}

	serverReader := link.Reader // .(*pipe.Reader)
	serverWriter := link.Writer // .(*pipe.Writer)

	postRequest := func() error {
		defer timer.SetTimeout(sessionPolicy.Timeouts.DownlinkOnly)

		// default: clientReader := reader
		clientReader := encoding.DecodeBodyAddons(reader, request, requestAddons)

		// from clientReader.ReadMultiBuffer to serverWriter.WriteMultiBufer
		if err := buf.Copy(clientReader, serverWriter, buf.UpdateActivity(timer)); err != nil {
			return newError("failed to transfer request payload").Base(err).AtInfo()
		}

		return nil
	}

	getResponse := func() error {
		defer timer.SetTimeout(sessionPolicy.Timeouts.UplinkOnly)

		bufferWriter := buf.NewBufferedWriter(buf.NewWriter(connection))
		if err := encoding.EncodeResponseHeader(bufferWriter, request, responseAddons); err != nil {
			return newError("failed to encode response header").Base(err).AtWarning()
		}

		// default: clientWriter := bufferWriter
		clientWriter := encoding.EncodeBodyAddons(bufferWriter, request, responseAddons)
		{
			multiBuffer, err := serverReader.ReadMultiBuffer()
			if err != nil {
				return err // ...
			}
			if err := clientWriter.WriteMultiBuffer(multiBuffer); err != nil {
				return err // ...
			}
		}

		// Flush; bufferWriter.WriteMultiBufer now is bufferWriter.writer.WriteMultiBuffer
		if err := bufferWriter.SetBuffered(false); err != nil {
			return newError("failed to write A response payload").Base(err).AtWarning()
		}

		// from serverReader.ReadMultiBuffer to clientWriter.WriteMultiBufer
		if err := buf.Copy(serverReader, clientWriter, buf.UpdateActivity(timer)); err != nil {
			return newError("failed to transfer response payload").Base(err).AtInfo()
		}

		// Indicates the end of response payload.
		switch responseAddons.Flow {
		default:

		}

		return nil
	}

	if err := task.Run(ctx, task.OnSuccess(postRequest, task.Close(serverWriter)), getResponse); err != nil {
		common.Interrupt(serverReader)
		common.Interrupt(serverWriter)
		return newError("connection ends").Base(err).AtInfo()
	}

	return nil
}

```

# `proxy/vless/outbound/config.go`

这段代码是一个 Go 语言中的包定义，包含了一个名为 "outbound" 的包。下面会逐步解释该包的作用以及它包含的一些常见的函数和变量。

"// +build !confonly" 是一个注释，表示该包仅在构建时编译，不会在运行时链接 "outbound" 包。这意味着如果你编辑了该包的源代码，只有在构建时才会生成可执行文件，而在运行时不会加载该包。

下面是 "outbound" 包的一些常见函数和变量：


func main() {
   // 该函数作为 "outbound" 包的入口函数，会在编译时生成。
   // 在运行时不会执行该函数。

   // 输出 "hello, world!"
   fmt.Println("hello, world!")

   // 该函数会将一个 HTTP 请求发送到该包的默认 URL。
   // 该函数作为 "outbound.http" 包的入口函数，会在构建时生成。
   // 在运行时不会执行该函数。

   // 设置 HTTP 请求的请求方法为 GET。
   // 该函数作为 "outbound.http" 包的入口函数，会在构建时生成。
   // 在运行时不会执行该函数。
}

// 该函数作为 "outbound.http" 包的入口函数，会在构建时生成。
// 在运行时不会执行该函数。
func (c *http.Request) SetRequestURI(u string) error {
   // 该函数作为 "outbound.http" 包的入口函数，会在构建时生成。
   // 在运行时不会执行该函数。

   // 设置 HTTP 请求的请求方法为 GET。
   // 该函数作为 "outbound.http" 包的入口函数，会在构建时生成。
   // 在运行时不会执行该函数。
   // 通过调用 c.http.Request.SetUri(u) 来设置 HTTP 请求的请求方法为 GET。
   // 使用 SetRequestUri(u) 函数将请求 URI 设置为 u。
   // 使用 SetRequestUri(u) 函数将请求 URI 设置为 u。
   // 递归调用自身，设置 HTTP 请求的请求方法为 GET。
   // 使用 SetRequestUri(u) 函数将请求 URI 设置为 u。
   // 继续递归调用自身，设置 HTTP 请求的请求方法为 GET。
   // 返回设置 HTTP 请求的请求方法的错误。
   // 使用 SetRequestUri(u) 函数将请求 URI 设置为 u。
   // 使用 SetRequestUri(u) 函数将请求 URI 设置为 u。
   // 递归调用自身，设置 HTTP 请求的请求方法为 GET。
   // 使用 SetRequestUri(u) 函数将请求 URI 设置为 u。
   // 继续递归调用自身，设置 HTTP 请求的请求方法为 GET。
   // 返回设置 HTTP 请求的请求方法的错误。
}

// 该函数作为 "outbound.http" 包的入口函数，会在构建时生成。
// 在运行时不会执行该函数。
func (c *http.Request) SetRequestBody(b []byte) error {
   // 该函数作为 "outbound.http" 包的入口函数，会在构建时生成。
   // 在运行时不会执行该函数。

   // 设置 HTTP 请求的请求体为 b。
   // 使用 SetRequestBody(b) 函数将 HTTP 请求的请求体设置为 b。
   // 递归调用自身，设置 HTTP 请求的请求体为 b。
   // 使用 SetRequestBody(b) 函数将 HTTP 请求的请求体设置为 b。
   // 递归调用自身，设置 HTTP 请求的请求体为 b。
   // 继续递归调用自身，设置 HTTP 请求的请求体为 b。
   // 返回设置 HTTP 请求的请求体的错误。
   // 使用 SetRequestBody(b) 函数将 HTTP 请求的请求体设置为 b。
   // 使用 SetRequestBody(b) 函数将 HTTP 请求的请求体设置为 b。
   // 递归调用自身，设置 HTTP 请求的请求体为 b。
   // 继续递归调用自身，设置 HTTP 请求的请求体为 b。
   // 继续递归调用自身，设置 HTTP 请求的请求体为 b。
   // 返回设置 HTTP 请求的请求体的错误。
}



// 该函数作为 "outbound.http" 包的入口函数，会在构建时生成。
// 在运行时不会执行该函数。
func (c *http.Request) DefaultRequestHandler() *http.Response {
   // 该函数作为 "outbound.http" 包的入口函数，会在构建时生成。
   // 在运行时不会执行该函数。

   // 设置 HTTP 请求的默认请求处理器为该函数。
   // 使用 SetDefaultRequest



```go
// +build !confonly

package outbound

```

# `proxy/vless/outbound/config.pb.go`

这段代码定义了一个名为 "outbound" 的包，该包包含用于定义 Go 语言中 Outbound 协议的接口定义。

首先，定义了一些用于 protoc-gen-go 和 protoc 的版本，以确保可以生成对应的生成的 Go 语言代码。

然后，定义了 "proxy/vless/outbound/config.proto" 的导入依赖，以便可以导入该文件并定义其中的接口。

接着，定义了一些类型，包括 "配置（Config）" 和 "请求体（RequestBody）"，以及 "outbound（Outbound）" 包的类型。

最后，实现了 "配置（Config）” 和 "请求体（RequestBody）” 类型的接口，用于定义 Outbound 协议中的配置和请求数据结构。

同时，实现了一个名为 "outbound\_config\_uploader" 的函数，用于加载并返回 Outbound 配置实例。

另外，实现了一个名为 "create\_channel" 的函数，用于创建与 Outbound 服务器连接的通道。

最后，实现了多个 "outbound" 包的依赖关系，以便可以支持不同的 Outbound 协议。


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: proxy/vless/outbound/config.proto

package outbound

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	protocol "v2ray.com/core/common/protocol"
)

```

这段代码定义了一个名为`Config`的结构体类型，用于配置负载均衡服务器的参数。

首先，它使用两个判断语句来确认所加载的软件包版本足够新，分别比较`protoimpl.MinVersion`和`protoimpl.MaxVersion`，如果它们都大于当前版本，则表示软件包版本足够新。然后，它定义了一个常量`_`，用于在代码中引用这个足够新版本的软件包。

接下来，它定义了一个`_`，用于在代码中引用`protoimpl.IsVersion4`，判断当前使用的软件包版本是否为4。

最后，它定义了一个`Config`结构体，包含以下字段：

* `state`：一个`protoimpl.MessageState`，用于保存`Config`的状态信息。
* `sizeCache`：一个`protoimpl.SizeCache`，用于保存已经下载的大小缓存。
* `unknownFields`：一个`protoimpl.UnknownFields`，用于保存未解析过的字段。
* `Vnext`：一个数组，用于保存服务器端点，其中每个元素都是一个`protocol.ServerEndpoint`，用于配置负载均衡服务器。

此外，它还定义了一个常量`proto.JoinToStringFn`，用于将多个字段合并为一个字符串，用于将`Vnext`字段与`proto.ServerEndpoint`字段进行拼接。


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Config struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vnext []*protocol.ServerEndpoint `protobuf:"bytes,1,rep,name=vnext,proto3" json:"vnext,omitempty"`
}

```

这段代码定义了两个函数：

1. `func (x *Config) Reset()` 函数用于重置 `x` 的值，并检查 `protoimpl.UnsafeEnabled` 是否为 `true`，如果是，则执行以下操作：

  - 创建一个空的 `Config` 类型的值，并将其赋给 `x`。
  - 如果 `protoimpl.UnsafeEnabled` 为 `true`，则执行以下操作：

    - 获取 `file_proxy_vless_outbound_config_proto_msgTypes` 类型的指针变量 `mi`。
    - 获取 `x` 指向的 `Config` 类型的值的时间 `ts`。
    - 将 `mi` 和 `ts` 的指针变量设置为 `nil`。
    - 如果 `x` 所指向的 `Config` 类型实现了 `file_proxy_vless_outbound_config_proto_msgTypes` 类型，则将 `ts` 存储为当前时间。

2. `func (x *Config) String()` 函数用于将 `x` 返回的字符串格式化。

3. `func (*Config) ProtoMessage()` 函数用于将 `x` 返回的 `Config` 类型转换为 `file_proxy_vless_outbound_config_proto_msgTypes` 类型。


```go
func (x *Config) Reset() {
	*x = Config{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proxy_vless_outbound_config_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

```

这段代码定义了两个函数，分别接收一个*Config类型的参数x，并返回其对应的Protoreflect消息类型。以下是这两个函数的作用：

func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_proxy_vless_outbound_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (*Config) Descriptor() ([]byte, []int) {
	return file_proxy_vless_outbound_config_proto_rawDescGZIP(), []int{0}
}

在函数 ProtoReflect() 中，首先检查 x 是否为空。如果是，则创建一个空的反射消息类型，然后将其存储为 *mi，接着使用 protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) 获取 x 的实际消息类型，并将其存储为 mi。最后，返回 mi 的消息类型。

在函数 Descriptor() 中，返回 x 的描述符。首先使用 file_proxy_vless_outbound_config_proto_rawDescGZIP 函数提取出 x 的描述符。然后返回它。


```go
func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_proxy_vless_outbound_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_proxy_vless_outbound_config_proto_rawDescGZIP(), []int{0}
}

```

It looks like the output data is a sequence of hexadecimal values. Each value is formatted as two 4-byte values separated by a delimiter, with each 4-byte value consisting of a high byte and a low byte.

The first value in each 4-byte value represents a 2's complement byte value, and the second value represents a 16-bit value.

Based on this format, it seems likely that the output data is a valid Unicode character, specifically a character in the "Basic" Unicode category. However, without more information about the context in which this data is being used, it's difficult to provide more specific insights.


```go
func (x *Config) GetVnext() []*protocol.ServerEndpoint {
	if x != nil {
		return x.Vnext
	}
	return nil
}

var File_proxy_vless_outbound_config_proto protoreflect.FileDescriptor

var file_proxy_vless_outbound_config_proto_rawDesc = []byte{
	0x0a, 0x21, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2f, 0x76, 0x6c, 0x65, 0x73, 0x73, 0x2f, 0x6f, 0x75,
	0x74, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x12, 0x1f, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x6c, 0x65, 0x73, 0x73, 0x2e, 0x6f, 0x75, 0x74, 0x62,
	0x6f, 0x75, 0x6e, 0x64, 0x1a, 0x21, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x73, 0x70, 0x65,
	0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x4a, 0x0a, 0x06, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x12, 0x40, 0x0a, 0x05, 0x76, 0x6e, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x2a, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x53, 0x65,
	0x72, 0x76, 0x65, 0x72, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x52, 0x05, 0x76, 0x6e,
	0x65, 0x78, 0x74, 0x42, 0x6e, 0x0a, 0x23, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79,
	0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x76, 0x6c, 0x65, 0x73,
	0x73, 0x2e, 0x6f, 0x75, 0x74, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x50, 0x01, 0x5a, 0x23, 0x76, 0x32,
	0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x70, 0x72, 0x6f,
	0x78, 0x79, 0x2f, 0x76, 0x6c, 0x65, 0x73, 0x73, 0x2f, 0x6f, 0x75, 0x74, 0x62, 0x6f, 0x75, 0x6e,
	0x64, 0xaa, 0x02, 0x1f, 0x56, 0x32, 0x52, 0x61, 0x79, 0x2e, 0x43, 0x6f, 0x72, 0x65, 0x2e, 0x50,
	0x72, 0x6f, 0x78, 0x79, 0x2e, 0x56, 0x6c, 0x65, 0x73, 0x73, 0x2e, 0x4f, 0x75, 0x74, 0x62, 0x6f,
	0x75, 0x6e, 0x64, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

```

这段代码定义了一个名为file_proxy_vless_outbound_config_proto_rawDesc的接口类型，以及一个名为file_proxy_vless_outbound_config_proto_rawDescData的动态生成的局部变量。

接着，定义了一个名为file_proxy_vless_outbound_config_proto_rawDescGZIP的函数，该函数接收file_proxy_vless_outbound_config_proto_rawDescOnce类型的实例作为第一个参数，然后使用protoimpl.X.CompressGZIP函数对传入的value进行压缩，再返回压缩后的value。

接着，定义了一个名为file_proxy_vless_outbound_config_proto_msgTypes的变量，该变量是一个包含1个消息类型的切片，其对应的消息类型为file_proxy_vless_outbound_config_proto_goTypes，表示go语言中的相应类型。

最后，定义了file_proxy_vless_outbound_config_proto_rawDesc、file_proxy_vless_outbound_config_proto_rawDescData、file_proxy_vless_outbound_config_proto_rawDescGZIP这三个变量，分别表示接口类型、原始数据和压缩后的数据。


```go
var (
	file_proxy_vless_outbound_config_proto_rawDescOnce sync.Once
	file_proxy_vless_outbound_config_proto_rawDescData = file_proxy_vless_outbound_config_proto_rawDesc
)

func file_proxy_vless_outbound_config_proto_rawDescGZIP() []byte {
	file_proxy_vless_outbound_config_proto_rawDescOnce.Do(func() {
		file_proxy_vless_outbound_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_proxy_vless_outbound_config_proto_rawDescData)
	})
	return file_proxy_vless_outbound_config_proto_rawDescData
}

var file_proxy_vless_outbound_config_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_proxy_vless_outbound_config_proto_goTypes = []interface{}{
	(*Config)(nil),                  // 0: v2ray.core.proxy.vless.outbound.Config
	(*protocol.ServerEndpoint)(nil), // 1: v2ray.core.common.protocol.ServerEndpoint
}
```

This is a function definition for the `file_proxy_vless_outbound_config_proto_init()` function. It is used to initialize the `file_proxy_vless_outbound_config_proto` message in the Go-protobuf programming language.

The function signature for this function is:

file_proxy_vless_outbound_config_proto_init() returns nothing

This function initializes the `file_proxy_vless_outbound_config_proto` message by setting its default exporter, sizeCache, and unknownFields.

If the `File_proxy_vless_outbound_config_proto` message is not `nil` before this function is called, it will be returned instead.

If the function has any dependencies, it is passed to the `File_proxy_vless_outbound_config_proto_init()` function of the `File_proxy_vless_outbound_config_proto` message.


```go
var file_proxy_vless_outbound_config_proto_depIdxs = []int32{
	1, // 0: v2ray.core.proxy.vless.outbound.Config.vnext:type_name -> v2ray.core.common.protocol.ServerEndpoint
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_proxy_vless_outbound_config_proto_init() }
func file_proxy_vless_outbound_config_proto_init() {
	if File_proxy_vless_outbound_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proxy_vless_outbound_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proxy_vless_outbound_config_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proxy_vless_outbound_config_proto_goTypes,
		DependencyIndexes: file_proxy_vless_outbound_config_proto_depIdxs,
		MessageInfos:      file_proxy_vless_outbound_config_proto_msgTypes,
	}.Build()
	File_proxy_vless_outbound_config_proto = out.File
	file_proxy_vless_outbound_config_proto_rawDesc = nil
	file_proxy_vless_outbound_config_proto_goTypes = nil
	file_proxy_vless_outbound_config_proto_depIdxs = nil
}

```