# v2ray-core源码解析 74

# `transport/internet/xtls/config.pb.go`

这段代码定义了一个名为 "xtls" 的包，其作用是实现 Go 语言对 protobuf 协议的自动生成。它通过使用 protoc-gen-go 和 protoc 两个工具，来自动生成与 "transport/internet/xtls/config" 相关的接口、定义和声明，从而减少手动编写代码的工作量，同时保持代码的整洁和易于维护。

具体来说，这段代码可以执行以下操作：

1. 定义了 "xtls" 包的功能，即自动生成与 "transport/internet/xtls/config" 相关的接口、定义和声明。

2. 引入了需要使用的 protobuf 协议和相关的反射、同步和类型定义。

3. 通过 protoc-gen-go 和 protoc 工具，自动生成与 "transport/internet/xtls/config" 相关的接口、定义和声明，其中包括了方法、字段、构造函数、断言等，使得开发者可以更轻松地使用这些接口来实现自动化的数据序列化和反序列化等功能。


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: transport/internet/xtls/config.proto

package xtls

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

```

这段代码是一个TypeScript定义，它定义了一个名为Certificate_Usage的枚举类型，以及一个名为Certificate_Package的接口。

首先，它使用const关键字定义了两个内部变量，分别为_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)和_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)。

然后，它定义了一个名为_的常量，使用protoimpl.EnforceVersion()函数来确保proto包的版本符合要求。

接下来，它定义了一个名为Certificate_Usage的枚举类型，使用case来定义每种可能的情况。第一个case定义了Certificate_AUTHORITY_VERIFY，第二个case定义了Certificate_AUTHORITY_ISSUE，第三个case定义了Certificate_AUTHORITY_VERIFY。

最后，它使用typedef定义了一个名为Certificate_Package的接口，使用内部变量_来确保该接口的实现与上面定义的Certificate_Package类型相同。

总结一下，这段代码定义了一个名为Certificate_Usage的枚举类型，用于定义证书的使用方式，以及一个名为Certificate_Package的接口，用于定义证书颁发包的实现。同时，它还定义了一个内部变量_来确保propimpl.EnforceVersion()函数能够确保生成的代码足够古老，以及一个名为_的常量来确保运行时/protoimpl足够古老。


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type Certificate_Usage int32

const (
	Certificate_ENCIPHERMENT     Certificate_Usage = 0
	Certificate_AUTHORITY_VERIFY Certificate_Usage = 1
	Certificate_AUTHORITY_ISSUE  Certificate_Usage = 2
)

```

这段代码定义了一个名为Certificate_Usage的枚举类型，包含了三个枚举值：

- 0: "ENCIPHERMENT"
- 1: "AUTHORITY_VERIFY"
- 2: "AUTHORITY_ISSUE"

并且定义了一个对应的枚举值映射：

- Certificate_Usage_name = map[int32]string{
	0: "ENCIPHERMENT",
	1: "AUTHORITY_VERIFY",
	2: "AUTHORITY_ISSUE",
}
- Certificate_Usage_value = map[string]int32{
	"ENCIPHERMENT":     0,
	"AUTHORITY_VERIFY": 1,
	"AUTHORITY_ISSUE":  2,
}

该代码创建了一个名为Certificate_Usage的结构体，该结构体实现了枚举类型所定义的所有枚举值。然后，通过将Certificate_Usage类型变量x强制转换为Certificate_Usage结构体，创建了一个结构体变量p，最后将p返回，使得该变量可以被用来调用函数(x).Enum()。


```go
// Enum value maps for Certificate_Usage.
var (
	Certificate_Usage_name = map[int32]string{
		0: "ENCIPHERMENT",
		1: "AUTHORITY_VERIFY",
		2: "AUTHORITY_ISSUE",
	}
	Certificate_Usage_value = map[string]int32{
		"ENCIPHERMENT":     0,
		"AUTHORITY_VERIFY": 1,
		"AUTHORITY_ISSUE":  2,
	}
)

func (x Certificate_Usage) Enum() *Certificate_Usage {
	p := new(Certificate_Usage)
	*p = x
	return p
}

```

这段代码定义了一个名为 "func" 的函数，它接受一个名为 "x" 的参数，并返回一个字符串类型的函数值。

函数的第一个参数 "x" 被传递给 protoimpl.X.EnumStringOf 函数，这个函数根据 "x" 的描述符（Descriptor）返回一个字符串。然后，函数使用 protoreflect.EnumNumber 将 "x" 转换为一个整数，这个整数就是 "x" 描述符中的数值。最后，函数将这个字符串和整数组合成一个新的字符串，这个新字符串就是 "x" 的作用域。

函数的第二个参数 "Certificate_Usage" 被传递给 file_transport_internet_xtls_config_proto_enumTypes 数组的第一个元素，这个元素被赋值后，在函数内部被用来初始化函数 "func" 的第一个参数 "x"。


```go
func (x Certificate_Usage) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Certificate_Usage) Descriptor() protoreflect.EnumDescriptor {
	return file_transport_internet_xtls_config_proto_enumTypes[0].Descriptor()
}

func (Certificate_Usage) Type() protoreflect.EnumType {
	return &file_transport_internet_xtls_config_proto_enumTypes[0]
}

func (x Certificate_Usage) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

```

这段代码定义了一个名为 Certificate 的结构体，它代表了 protoimpl.MessageType。它同时包含了一个名为 Certificate_Usage 的 Enum 成员，和一个名为 Usage 的变量。

首先，定义了两个 Enum 成员函数，它们通过 file_transport_internet_xtls_config_proto_rawDescGZIP() 函数返回了一个描述 XTLS 配置的编码和两个整数，其中第一个返回的是 0，表示没有在使用该证书，第二个返回的是 0，表示没有对应的 XTLS 证书。

接着，定义了一个名为 Certificate 的结构体，其中包含了一个 CERTIFICATE 类型的 field Certificate，它包含了一个字节数组，使用了 x509 格式，同时还包含了一个名为 Key 字段，也是一个字节数组，使用了 x509 格式，并且该字段存储了一个 XTLS 密钥。此外，还包含一个名为 Usage 的字段，它是一个名为 Certificate_Usage 的 Enum 成员，使用了 v2ray.core.transport.internet.xtls.Certificate_Usage 枚举类型。

最后，使用了 Certificate_Usage.Descriptor() 函数返回了该结构体类型的描述，其中包括了其字段名、数据类型、是否遵循了协议规范以及依赖关系等信息。


```go
// Deprecated: Use Certificate_Usage.Descriptor instead.
func (Certificate_Usage) EnumDescriptor() ([]byte, []int) {
	return file_transport_internet_xtls_config_proto_rawDescGZIP(), []int{0, 0}
}

type Certificate struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// XTLS certificate in x509 format.
	Certificate []byte `protobuf:"bytes,1,opt,name=Certificate,proto3" json:"Certificate,omitempty"`
	// XTLS key in x509 format.
	Key   []byte            `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	Usage Certificate_Usage `protobuf:"varint,3,opt,name=usage,proto3,enum=v2ray.core.transport.internet.xtls.Certificate_Usage" json:"usage,omitempty"`
}

```

这段代码定义了两个函数，一个是`Reset()`，另一个是`String()`。

`Reset()`函数接收一个`*Certificate`类型的参数。函数执行以下操作：

1. 将`*x`复制一份，并将其赋值为一个匿名类型 `Certificate{}`。
2. 检查`protoimpl.UnsafeEnabled`是否为`true`。如果是，那么执行以下操作：

a. 从`file_transport_internet_xtls_config_proto_msgTypes`数组中获取第一个元素（因为只有一个元素，直接将其赋值给`mi`）。

b. 从`protoimpl.X`结构体中获取`MessageStateOf`函数，创建一个包含`x`的`Message`实例，并将其存储为`ms`。

3. 执行完第二步操作后，返回`x`。

`String()`函数接收一个`*Certificate`类型的参数。函数执行以下操作：

1. 调用`protoimpl.X.MessageStringOf`函数，将`*x`存储为`x`的`MessageStringOf`函数返回的结果。
2. 返回`x`。

这两个函数一起组成了一个`Certificate`实例，可以将其作为`Certificate{}`的接收者使用。同时，这两个函数还定义了`Certificate`的`IsCertificate()`和`ToCertificate()`函数，但它们并未在当前定义中使用。


```go
func (x *Certificate) Reset() {
	*x = Certificate{}
	if protoimpl.UnsafeEnabled {
		mi := &file_transport_internet_xtls_config_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Certificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Certificate) ProtoMessage() {}

```

这段代码定义了两个函数，函数一是接收一个 Certificate 类型的参数并返回一个 Protocol Buffers 类型，函数二是获取一个 Certificate 对象的描述信息。

函数一的作用是返回一个 Protocol Buffers 类型的消息，其中构造函数接收一个 Certificate 类型的参数并将其存储在 internal 的 *Certificate 类型的变量 x 中，然后使用 x 指向的对象调用 FileTransportInternetX 中的 MessageOf 函数，如果构造函数启用了 Unsafe 特性并且 x 参数不等于 nil，则使用 x 指向的对象调用 FileTransportInternetX 中的 MessageStateOf 函数获取到消息信息，并将其存储在 internal 的 *Certificate 类型的变量 mi 中，最后返回 mi 的 MessageOf 函数的结果。

函数二的作用是返回一个由字节数组和 int 组成的元数据，其中构造函数返回一个 Certificate 类型的变量 x，然后将其存储在 internal 的 *Certificate 类型的变量 x 中，接着返回 FileTransportInternetX 中的 Descriptor 函数的结果，这个函数返回的是 x 的描述信息，即字节数组和 int 组成的一对值，因此返回的结果也是一个字节数组和 int 组成的元数据。


```go
func (x *Certificate) ProtoReflect() protoreflect.Message {
	mi := &file_transport_internet_xtls_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Certificate.ProtoReflect.Descriptor instead.
func (*Certificate) Descriptor() ([]byte, []int) {
	return file_transport_internet_xtls_config_proto_rawDescGZIP(), []int{0}
}

```

这段代码定义了三个函数，分别接收一个名为 x 的 *Certificate 类型的参数，然后返回不同的字段。

第一个函数 GetCertificate() 接收一个 *Certificate 类型的参数，然后判断 x 是否为 nil。如果是，那么直接返回 x.Certificate 的字节数组。否则，函数返回一个名为 nil 的类型。

第二个函数 GetKey() 接收一个 *Certificate 类型的参数，然后判断 x 是否为 nil。如果是，那么直接返回 x.Key 的字节数组。否则，函数返回一个名为 nil 的类型。

第三个函数 GetUsage() 接收一个 *Certificate 类型的参数，然后判断 x 是否为 nil。如果是，那么获取 x.Usage，否则返回 Certificate_ENCIPHERMENT。

注意，以上函数的实现没有对 *Certificate 类型进行初始化。如果 *Certificate 类型没有提供其自身的方法，那么上述函数的行为将无法确定。


```go
func (x *Certificate) GetCertificate() []byte {
	if x != nil {
		return x.Certificate
	}
	return nil
}

func (x *Certificate) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *Certificate) GetUsage() Certificate_Usage {
	if x != nil {
		return x.Usage
	}
	return Certificate_ENCIPHERMENT
}

```

该代码定义了一个名为 "Config" 的结构体，用于配置服务器的安全选项。该结构体包含以下字段：

- "state"：表示协议的状态，使用了 protoimpl.MessageState 类型。
- "sizeCache"：表示用于缓存客户端证书大小的字段，使用了 protoimpl.SizeCache 类型。
- "unknownFields"：表示未知字段，使用了 protoimpl.UnknownFields 类型。
- "allowInsecure": 表示是否允许使用不安全的 SSL/TLS certificate，将其存储为 allowInsecure 布尔值。
- "allowInsecureCiphers": 表示是否允许使用不安全的密码套接字，将其存储为 allowInsecureCiphers 布尔值。
- "certificate": 表示服务器上要服务的证书列表，使用了 bytes 类型的整数列表，每个证书包含了一个 Certificate 结构体。
- "server_name": 表示服务器的主机名，使用了 bytes 类型的字符串。
- "next_protocol": 表示 ALPN 列表，用于指定服务器应该使用的下一个协议，使用了 bytes 类型的字符串列表。
- "disable_session_resumption": 表示是否禁止会话（ticket）的恢复，将其存储为 disableSessionResumption 布尔值。
- "disable_system_root": 表示是否禁止加载系统根证书，将其存储为 disableSystemRoot 布尔值。


```go
type Config struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Whether or not to allow self-signed certificates.
	AllowInsecure bool `protobuf:"varint,1,opt,name=allow_insecure,json=allowInsecure,proto3" json:"allow_insecure,omitempty"`
	// Whether or not to allow insecure cipher suites.
	AllowInsecureCiphers bool `protobuf:"varint,5,opt,name=allow_insecure_ciphers,json=allowInsecureCiphers,proto3" json:"allow_insecure_ciphers,omitempty"`
	// List of certificates to be served on server.
	Certificate []*Certificate `protobuf:"bytes,2,rep,name=certificate,proto3" json:"certificate,omitempty"`
	// Override server name.
	ServerName string `protobuf:"bytes,3,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	// Lists of string as ALPN values.
	NextProtocol []string `protobuf:"bytes,4,rep,name=next_protocol,json=nextProtocol,proto3" json:"next_protocol,omitempty"`
	// Whether or not to disable session (ticket) resumption.
	DisableSessionResumption bool `protobuf:"varint,6,opt,name=disable_session_resumption,json=disableSessionResumption,proto3" json:"disable_session_resumption,omitempty"`
	// If true, root certificates on the system will not be loaded for
	// verification.
	DisableSystemRoot bool `protobuf:"varint,7,opt,name=disable_system_root,json=disableSystemRoot,proto3" json:"disable_system_root,omitempty"`
}

```

这段代码定义了两个函数：

1. `Reset()`函数接收一个指向`Config`类型的参数 `x`，并将其赋值为`Config{}`。然后，如果 `protoimpl.UnsafeEnabled`为`true`，则执行以下操作：

  - 创建一个空的 `file_transport_internet_xtls_config_proto_msgTypes` 结构体指针 `mi`。
  - 创建一个指向 `Config` 类型实体的指针 `x`。
  - 将 `mi` 存储为 `x` 的内存位置。
  - 调用 `protoimpl.X.MessageStateOf` 函数，将 `x` 存储为 `mi` 的 `file_transport_internet_xtls_config_proto_msgTypes` 类型实例的实例。
  - 返回 `x` 的字符串表示。

2. `String()`函数接收一个指向 `Config` 类型实体的参数 `x`，并返回一个字符串表示。

3. `ProtoMessage()`函数是一个通用函数，接收一个指向 `Config` 类型实体的参数 `x`，返回一个空的 `file_transport_internet_xtls_config_proto_msgTypes` 结构体指针。


```go
func (x *Config) Reset() {
	*x = Config{}
	if protoimpl.UnsafeEnabled {
		mi := &file_transport_internet_xtls_config_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

```

这段代码定义了两个函数，函数一是将一个名为Config的*Config类型的变量x作为参数传递给func函数，并返回一个名为protoreflect.Message的接口类型，该接口类型包含一个名为config_reflect_混写。函数二是根据传入的*Config类型变量x，返回其Descriptor或Deprecated函数中使用的Config.Descriptor函数，函数三是返回一个包含Config类型实现的Descriptor和依赖关系的指针的切片，其中Config.Descriptor是依赖关系的指针，而依赖关系是指针的类型。


```go
func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_transport_internet_xtls_config_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_transport_internet_xtls_config_proto_rawDescGZIP(), []int{1}
}

```

这段代码是一个 Go 语言中的函数指针，它接收一个名为 Config 的 *Config 类型的参数，并实现了三个函数 GetAllowInsecure、GetAllowInsecureCiphers 和 GetCertificate。

函数 GetAllowInsecure 接收一个 Config 类型的参数，并返回 x.AllowInsecure 的值，其中 x 是 Config 类型的指针。函数的作用是检查是否允许不安全的配置，如果允许，则返回 true，否则返回 false。

函数 GetAllowInsecureCiphers 同样接收一个 Config 类型的参数，并返回 x.AllowInsecureCiphers 的值，其中 x 是 Config 类型的指针。函数的作用是检查是否允许不安全的加密算法，如果允许，则返回 true，否则返回 false。

函数 GetCertificate 接收一个 Config 类型的参数，并返回 x.Certificate 数组，其中 x 是 Config 类型的指针。函数的作用是检查是否有证书，如果没有证书，则返回 nil。

总的来说，这段代码通过函数指针实现了 Config 类型的对象，用于管理系统的安全性配置，包括允许不安全的配置、加密算法等。


```go
func (x *Config) GetAllowInsecure() bool {
	if x != nil {
		return x.AllowInsecure
	}
	return false
}

func (x *Config) GetAllowInsecureCiphers() bool {
	if x != nil {
		return x.AllowInsecureCiphers
	}
	return false
}

func (x *Config) GetCertificate() []*Certificate {
	if x != nil {
		return x.Certificate
	}
	return nil
}

```

这是一段 Go 语言中的函数指针类型。它表示将一个名为 Config 的结构体中的三个名为 GetServerName,GetNextProtocol 和 GetDisableSessionResumption 的方法指向前面的方法实现。

具体来说，这段代码定义了一个名为 Config 的结构体，其中包含三个方法：GetServerName,GetNextProtocol 和 GetDisableSessionResumption。如果定义的 Config 对象不为空，则执行其中的方法，否则返回一个空字符串。

GetServerName() 的方法接收一个 Config 类型的参数 x，并返回 x.ServerName，如果 x 不为空，则返回 x.ServerName 的值；否则返回一个空字符串。

GetNextProtocol() 的方法接收一个 Config 类型的参数 x，并返回 x.NextProtocol，如果 x 不为空，则返回 x.NextProtocol 的值；否则返回一个空字符串。

GetDisableSessionResumption() 的方法接收一个 Config 类型的参数 x，并返回 x.DisableSessionResumption，如果 x 不为空，则返回 x.DisableSessionResumption 的值；否则返回 false。


```go
func (x *Config) GetServerName() string {
	if x != nil {
		return x.ServerName
	}
	return ""
}

func (x *Config) GetNextProtocol() []string {
	if x != nil {
		return x.NextProtocol
	}
	return nil
}

func (x *Config) GetDisableSessionResumption() bool {
	if x != nil {
		return x.DisableSessionResumption
	}
	return false
}

```

It appears that the output is a series of random numbers. 

The `0x76`, `0x32`, `0x72`, `0x61`, `0x79`, `0x2e`, `0x63`, `0x6f`, `0x6d`, `0x2f`, `0x63`, `0x6f`, `0x72`, `0x65`, `0x2f`, `0x74`, `0x72`, `0x61`, `0x6e`, `0x73`, `0x70`, `0x6f`, `0x72`, `0x74`, `0x2e`, `0x58`, `0x74`, `0x6c`, `0x73`, `0x62`, `0x06`, `0x70`, `0x72`, `0x6f`, `0x74`, `0x6f`, `0x33` randomly generated numbers.



```go
func (x *Config) GetDisableSystemRoot() bool {
	if x != nil {
		return x.DisableSystemRoot
	}
	return false
}

var File_transport_internet_xtls_config_proto protoreflect.FileDescriptor

var file_transport_internet_xtls_config_proto_rawDesc = []byte{
	0x0a, 0x24, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x2f, 0x69, 0x6e, 0x74, 0x65,
	0x72, 0x6e, 0x65, 0x74, 0x2f, 0x78, 0x74, 0x6c, 0x73, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x22, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f,
	0x72, 0x65, 0x2e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x2e, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x6e, 0x65, 0x74, 0x2e, 0x78, 0x74, 0x6c, 0x73, 0x22, 0xd4, 0x01, 0x0a, 0x0b, 0x43,
	0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x43, 0x65,
	0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x0b, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x12, 0x10, 0x0a, 0x03,
	0x4b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x03, 0x4b, 0x65, 0x79, 0x12, 0x4b,
	0x0a, 0x05, 0x75, 0x73, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x35, 0x2e,
	0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x74, 0x72, 0x61, 0x6e, 0x73,
	0x70, 0x6f, 0x72, 0x74, 0x2e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x2e, 0x78, 0x74,
	0x6c, 0x73, 0x2e, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2e, 0x55,
	0x73, 0x61, 0x67, 0x65, 0x52, 0x05, 0x75, 0x73, 0x61, 0x67, 0x65, 0x22, 0x44, 0x0a, 0x05, 0x55,
	0x73, 0x61, 0x67, 0x65, 0x12, 0x10, 0x0a, 0x0c, 0x45, 0x4e, 0x43, 0x49, 0x50, 0x48, 0x45, 0x52,
	0x4d, 0x45, 0x4e, 0x54, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x41, 0x55, 0x54, 0x48, 0x4f, 0x52,
	0x49, 0x54, 0x59, 0x5f, 0x56, 0x45, 0x52, 0x49, 0x46, 0x59, 0x10, 0x01, 0x12, 0x13, 0x0a, 0x0f,
	0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x54, 0x59, 0x5f, 0x49, 0x53, 0x53, 0x55, 0x45, 0x10,
	0x02, 0x22, 0xec, 0x02, 0x0a, 0x06, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x25, 0x0a, 0x0e,
	0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x69, 0x6e, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x49, 0x6e, 0x73, 0x65, 0x63,
	0x75, 0x72, 0x65, 0x12, 0x34, 0x0a, 0x16, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x69, 0x6e, 0x73,
	0x65, 0x63, 0x75, 0x72, 0x65, 0x5f, 0x63, 0x69, 0x70, 0x68, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x14, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x49, 0x6e, 0x73, 0x65, 0x63, 0x75,
	0x72, 0x65, 0x43, 0x69, 0x70, 0x68, 0x65, 0x72, 0x73, 0x12, 0x51, 0x0a, 0x0b, 0x63, 0x65, 0x72,
	0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f,
	0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x74, 0x72, 0x61, 0x6e,
	0x73, 0x70, 0x6f, 0x72, 0x74, 0x2e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x2e, 0x78,
	0x74, 0x6c, 0x73, 0x2e, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x52,
	0x0b, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x12, 0x1f, 0x0a, 0x0b,
	0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0a, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x23, 0x0a,
	0x0d, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x6e, 0x65, 0x78, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x12, 0x3c, 0x0a, 0x1a, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x73, 0x65,
	0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x72, 0x65, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x18, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x53,
	0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x2e, 0x0a, 0x13, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x73, 0x79, 0x73, 0x74,
	0x65, 0x6d, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11, 0x64,
	0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x52, 0x6f, 0x6f, 0x74,
	0x42, 0x77, 0x0a, 0x26, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f,
	0x72, 0x65, 0x2e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x2e, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x6e, 0x65, 0x74, 0x2e, 0x78, 0x74, 0x6c, 0x73, 0x50, 0x01, 0x5a, 0x26, 0x76, 0x32,
	0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x74, 0x72, 0x61,
	0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x2f,
	0x78, 0x74, 0x6c, 0x73, 0xaa, 0x02, 0x22, 0x56, 0x32, 0x52, 0x61, 0x79, 0x2e, 0x43, 0x6f, 0x72,
	0x65, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x2e, 0x49, 0x6e, 0x74, 0x65,
	0x72, 0x6e, 0x65, 0x74, 0x2e, 0x58, 0x74, 0x6c, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

```

此代码定义了一个名为file_transport_internet_xtls_config_proto_rawDescOnce的变量，其作用是确保一个名为file_transport_internet_xtls_config_proto_rawDesc的值的唯一性，并返回该值的副本。

file_transport_internet_xtls_config_proto_rawDescGZIP函数从file_transport_internet_xtls_config_proto_rawDescOnce中获取值，并使用gzip压缩算法对其进行压缩。其返回值是一个字节切片，包含file_transport_internet_xtls_config_proto_rawDescData经过压缩后的值。

file_transport_internet_xtls_config_proto_enumTypes定义了一个名为file_transport_internet_xtls_config_proto_enumTypes的变量，它包含一个名为0的类型，以及一个名为1的类型，其值为v2ray.core.transport.internet.xtls.Certificate。

file_transport_internet_xtls_config_proto_msgTypes定义了一个名为file_transport_internet_xtls_config_proto_msgTypes的变量，它包含一个名为2的类型，其值为v2ray.core.transport.internet.xtls.Config，以及一个名为1的类型，其值为v2ray.core.transport.internet.xtls.Certificate。

file_transport_internet_xtls_config_proto_goTypes定义了一个名为file_transport_internet_xtls_config_proto_goTypes的变量，它包含一个名为0的类型，其值为v2ray.core.transport.internet.xtls.CertificateUsage，以及一个名为1的类型，其值为v2ray.core.transport.internet.xtls.Certificate。


```go
var (
	file_transport_internet_xtls_config_proto_rawDescOnce sync.Once
	file_transport_internet_xtls_config_proto_rawDescData = file_transport_internet_xtls_config_proto_rawDesc
)

func file_transport_internet_xtls_config_proto_rawDescGZIP() []byte {
	file_transport_internet_xtls_config_proto_rawDescOnce.Do(func() {
		file_transport_internet_xtls_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_transport_internet_xtls_config_proto_rawDescData)
	})
	return file_transport_internet_xtls_config_proto_rawDescData
}

var file_transport_internet_xtls_config_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_transport_internet_xtls_config_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_transport_internet_xtls_config_proto_goTypes = []interface{}{
	(Certificate_Usage)(0), // 0: v2ray.core.transport.internet.xtls.Certificate.Usage
	(*Certificate)(nil),    // 1: v2ray.core.transport.internet.xtls.Certificate
	(*Config)(nil),         // 2: v2ray.core.transport.internet.xtls.Config
}
```

This is a Go-based implementation of the protobuf message that represents a Transport Security configuration.

The generated file, file\_transport\_internet\_xtls\_config\_proto.go, exports the generated types for the configuration message and its extensions.

The generated file exports a single field, Config, which is a struct that contains all the fields of the Transport Security configuration message.

The generated file also exports a function, Exporter, which is used to expose the Config field to external code.

The generated file uses the Protocol Buffers encoding for the generated types, which allows for the efficient transfer of messages between different programs.


```go
var file_transport_internet_xtls_config_proto_depIdxs = []int32{
	0, // 0: v2ray.core.transport.internet.xtls.Certificate.usage:type_name -> v2ray.core.transport.internet.xtls.Certificate.Usage
	1, // 1: v2ray.core.transport.internet.xtls.Config.certificate:type_name -> v2ray.core.transport.internet.xtls.Certificate
	2, // [2:2] is the sub-list for method output_type
	2, // [2:2] is the sub-list for method input_type
	2, // [2:2] is the sub-list for extension type_name
	2, // [2:2] is the sub-list for extension extendee
	0, // [0:2] is the sub-list for field type_name
}

func init() { file_transport_internet_xtls_config_proto_init() }
func file_transport_internet_xtls_config_proto_init() {
	if File_transport_internet_xtls_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_transport_internet_xtls_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Certificate); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_transport_internet_xtls_config_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_transport_internet_xtls_config_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_transport_internet_xtls_config_proto_goTypes,
		DependencyIndexes: file_transport_internet_xtls_config_proto_depIdxs,
		EnumInfos:         file_transport_internet_xtls_config_proto_enumTypes,
		MessageInfos:      file_transport_internet_xtls_config_proto_msgTypes,
	}.Build()
	File_transport_internet_xtls_config_proto = out.File
	file_transport_internet_xtls_config_proto_rawDesc = nil
	file_transport_internet_xtls_config_proto_goTypes = nil
	file_transport_internet_xtls_config_proto_depIdxs = nil
}

```

# `transport/internet/xtls/config_other.go`

这段代码是一个名为“xtls”的包的实现。它定义了一个名为“rootCertsCache”的结构体，该结构体使用了“sync.Pool”类型来管理一组“x509.CertPool”对象的池。这里使用了“+build”和“!confonly”这样的注释，它们可能是在项目的构建选项中设置的。

具体来说，这段代码定义了一个名为“rootCertsCache”的结构体，它包含一个“sync.Pool”类型的成员变量“pool”，该成员变量指定了一个“x509.CertPool”对象的池。这个结构体可能用于在应用程序中管理证书，例如在TLS协议创建的过程中，从证书颁发机构（CA）下载证书。

通过使用“sync.Mutex”类型的成员变量“mutex”，可以确保对“pool”成员变量的同步访问。这种同步方式有助于确保“rootCertsCache”结构体中的“x509.CertPool”对象是经过初始化、排他性检查的，并且在多核计算机上能够正常工作。

此外，“!confonly”注释指示这段代码只会在Linux系统上编译。这个注释通常用于指示编译器只编译不依赖SLIBRARY_AGREAB下降层的源代码的源文件。


```go
// +build !windows
// +build !confonly

package xtls

import (
	"crypto/x509"
	"sync"
)

type rootCertsCache struct {
	sync.Mutex
	pool *x509.CertPool
}

```

此函数名为`func (c *rootCertsCache) load() (*x509.CertPool, error)`，它接收一个指向`rootCertsCache`结构体的指针`c`作为参数，并返回一个指向`x509.CertPool`类型对象的`c`和一个错误对象`err`。

具体来说，该函数首先对传入的`rootCertsCache`结构体进行加锁操作，然后执行以下操作：

1. 如果`rootCertsCache`结构体中已经定义了一个`x509.CertPool`类型的变量，则直接返回该变量和`nil`，即`c.pool`和`nil`。
2. 否则，尝试从操作系统安全存储库中加载一个`x509.CertPool`类型对象，如果加载成功，则将`pool`字段设置为返回的`x509.CertPool`类型对象，并将返回的`x509.CertPool`类型对象返回。
3. 最后，释放之前获取的锁。

此函数的作用是用于从操作系统安全存储库中加载一个根证书颁发机构（CA）的列表，以供后续的加密和解密操作使用。它返回一个指向`x509.CertPool`类型对象的`c`和一个错误对象`err`，可以确保在函数调用成功的情况下正确地返回结果。


```go
func (c *rootCertsCache) load() (*x509.CertPool, error) {
	c.Lock()
	defer c.Unlock()

	if c.pool != nil {
		return c.pool, nil
	}

	pool, err := x509.SystemCertPool()
	if err != nil {
		return nil, err
	}
	c.pool = pool
	return pool, nil
}

```

这段代码定义了一个名为 `getCertPool` 的函数，属于一个名为 `Config` 的结构体类型。

该函数首先检查是否启用了系统根，如果是，则加载系统自己的证书存储区；如果不是，则加载根证书存储区。

接下来，函数检查 `Certificate` 字段是否为空。如果是，则尝试从根证书存储区加载证书。

如果从根证书存储区加载失败，函数将抛出一个错误，并返回 `nil`。否则，函数返回根证书存储区和系统根证书存储区，如果从根证书存储区加载过程中出现错误，则返回 `nil` 和错误。


```go
var rootCerts rootCertsCache

func (c *Config) getCertPool() (*x509.CertPool, error) {
	if c.DisableSystemRoot {
		return c.loadSelfCertPool()
	}

	if len(c.Certificate) == 0 {
		return rootCerts.load()
	}

	pool, err := x509.SystemCertPool()
	if err != nil {
		return nil, newError("system root").AtWarning().Base(err)
	}
	for _, cert := range c.Certificate {
		if !pool.AppendCertsFromPEM(cert.Certificate) {
			return nil, newError("append cert to root").AtWarning().Base(err)
		}
	}
	return pool, err
}

```

# `transport/internet/xtls/config_test.go`

这段代码是一个用于测试TLS证书颁发功能的功能性测试。它的作用是验证在给定的一组TLS证书下，证书是否能够正常地被授权并且使用者是否能够在使用该证书时正确的时间范围内使用该证书。

具体来说，它首先导入了必要的库，包括crypto/x509用于证书验证，testing用于测试框架的支出，以及time用于获取当前时间。然后定义了一个名为TestCertificateIssuing的函数，该函数使用ParseCertificate函数生成一个证书，然后将其设置为AUTHORITY_ISSUE用途。

接着，定义了一个名为Config的Config结构体，其中包含一个名为Certificate的列表，该列表包含一个经过授权的TLS证书。然后，使用该Config结构体中的Certificate函数获取一个经过授权的TLS证书，并将其存储在名为v2rayCert的变量中。

最后，使用另一个名为xtlsConfig的Config结构体函数获取一个经过授权的TLS配置，并使用其中的GetCertificate函数从该配置中获取一个证书。使用xtls.ClientHelloInfo结构体中的ServerName函数设置证书的使用者名称，然后使用GetCertificate函数获取证书。

最后，使用x509.ParseCertificate函数将证书解析为x509Cert类型，并使用其NotAfter字段检查证书是否在当前时间的范围内。如果证书的NotAfter字段小于当前时间，那么函数就会输出一个错误。

注意：这段代码的目的是验证函数的行为，而不是输出它的源代码。


```go
package xtls_test

import (
	"crypto/x509"
	"testing"
	"time"

	xtls "github.com/xtls/go"

	"v2ray.com/core/common"
	"v2ray.com/core/common/protocol/tls/cert"
	. "v2ray.com/core/transport/internet/xtls"
)

func TestCertificateIssuing(t *testing.T) {
	certificate := ParseCertificate(cert.MustGenerate(nil, cert.Authority(true), cert.KeyUsage(x509.KeyUsageCertSign)))
	certificate.Usage = Certificate_AUTHORITY_ISSUE

	c := &Config{
		Certificate: []*Certificate{
			certificate,
		},
	}

	xtlsConfig := c.GetXTLSConfig()
	v2rayCert, err := xtlsConfig.GetCertificate(&xtls.ClientHelloInfo{
		ServerName: "www.v2fly.org",
	})
	common.Must(err)

	x509Cert, err := x509.ParseCertificate(v2rayCert.Certificate[0])
	common.Must(err)
	if !x509Cert.NotAfter.After(time.Now()) {
		t.Error("NotAfter: ", x509Cert.NotAfter)
	}
}

```

该测试函数旨在测试在给定配置下，使用已过期证书是否可以正常使用。具体来说，它执行以下操作：

1. 生成一个自签名证书并设置其有效期为2分钟。
2. 生成一个自签名证书，并设置其有效期为当前时间减去2分钟。
3. 解析两个自签名证书。
4. 在一个配置对象中获取证书，并将它设置为证书的有效期为2分钟的证书。
5. 获取来自v2ray的证书，并解析其有效期限。

函数的目的是测试在给定配置下，证书过期后是否仍然可以使用正常的证书。如果函数返回一个错误，则说明存在问题。


```go
func TestExpiredCertificate(t *testing.T) {
	caCert := cert.MustGenerate(nil, cert.Authority(true), cert.KeyUsage(x509.KeyUsageCertSign))
	expiredCert := cert.MustGenerate(caCert, cert.NotAfter(time.Now().Add(time.Minute*-2)), cert.CommonName("www.v2fly.org"), cert.DNSNames("www.v2fly.org"))

	certificate := ParseCertificate(caCert)
	certificate.Usage = Certificate_AUTHORITY_ISSUE

	certificate2 := ParseCertificate(expiredCert)

	c := &Config{
		Certificate: []*Certificate{
			certificate,
			certificate2,
		},
	}

	xtlsConfig := c.GetXTLSConfig()
	v2rayCert, err := xtlsConfig.GetCertificate(&xtls.ClientHelloInfo{
		ServerName: "www.v2fly.org",
	})
	common.Must(err)

	x509Cert, err := x509.ParseCertificate(v2rayCert.Certificate[0])
	common.Must(err)
	if !x509Cert.NotAfter.After(time.Now()) {
		t.Error("NotAfter: ", x509Cert.NotAfter)
	}
}

```

这是一个 Go 语言中的测试函数，名为 `TestInsecureCertificates`，旨在测试是否可以使用不安全加密证书。

函数的目的是创建一个 `Config` 对象，该对象指定了允许使用不安全加密证书。然后，该 `Config` 对象用于获取一个 `XTLSConfig` 对象，该对象用于在应用程序中处理 TLS 配置。

如果 `c.GetXTLSConfig()` 返回的 `XTLSConfig` 对象中包含任何包含 `CipherSuites` 字段的字段，则函数会检查 `c.GetXTLSConfig()` 返回的 `XTLSConfig` 对象中 `CipherSuites` 字段中包含的逗号数量。

如果没有检查到 `CipherSuites` 字段中包含逗号，那么函数会打印一条错误消息并退出。

函数 `BenchmarkCertificateIssuing` 的目的是测试证书颁发功能。该函数使用 `ParseCertificate` 函数生成一个证书，然后设置该证书的用途为 `Certificate_AUTHORITY_ISSUE`。

接下来，该函数创建一个 `Config` 对象，该对象包含一个证书实例和一个 `XTLSConfig` 对象。然后，函数使用 `c.GetXTLSConfig()` 函数获取一个 `XTLSConfig` 对象，并使用该对象中包含的证书实例来设置 `c.Certificate` 字段以指定要使用的证书。

函数还使用 `lenCerts` 变量来存储 `c.GetXTLSConfig()` 返回的 `XTLSConfig` 对象中包含的证书数量。

最后，函数使用 `b.ResetTimer()` 函数来重置计时器，然后使用 `xtlsConfig.GetCertificate(&xtls.ClientHelloInfo{
	ServerName: "www.v2fly.org",
})` 函数获取一个 `xtls.ClientHelloInfo` 对象，其中包含服务器名称。然后，函数使用 `xtlsConfig.GetCertificate()` 函数获取一个 `Certificate` 对象，并设置其用途为 `Certificate_AUTHORITY_ISSUE`。

函数还使用 `xtlsConfig.Certificates` 字段将 `c.GetXTLSConfig()` 返回的 `XTLSConfig` 对象中 `Certificates` 字段中的所有证书复制到一个新的 `Certificate` 对象中。最后，函数使用 `b.N` 变量来计数证书数量，并使用 `xtlsConfig.GetCertificate()` 函数获取一个 `xtls.ClientHelloInfo` 对象，其中包含服务器名称。


```go
func TestInsecureCertificates(t *testing.T) {
	c := &Config{
		AllowInsecureCiphers: true,
	}

	xtlsConfig := c.GetXTLSConfig()
	if len(xtlsConfig.CipherSuites) > 0 {
		t.Fatal("Unexpected tls cipher suites list: ", xtlsConfig.CipherSuites)
	}
}

func BenchmarkCertificateIssuing(b *testing.B) {
	certificate := ParseCertificate(cert.MustGenerate(nil, cert.Authority(true), cert.KeyUsage(x509.KeyUsageCertSign)))
	certificate.Usage = Certificate_AUTHORITY_ISSUE

	c := &Config{
		Certificate: []*Certificate{
			certificate,
		},
	}

	xtlsConfig := c.GetXTLSConfig()
	lenCerts := len(xtlsConfig.Certificates)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		_, _ = xtlsConfig.GetCertificate(&xtls.ClientHelloInfo{
			ServerName: "www.v2fly.org",
		})
		delete(xtlsConfig.NameToCertificate, "www.v2fly.org")
		xtlsConfig.Certificates = xtlsConfig.Certificates[:lenCerts]
	}
}

```

# `transport/internet/xtls/config_windows.go`

这段代码是一个用于生成TLS证书池的构建工具链。它通过在项目的编译选项中添加两个选项来实现的：

+build 选项指定生成Windows版本的证书池，如果不添加该选项，则默认生成。

+build !confonly 选项用于指定仅在构建过程中生成证书池，而不在最终的可执行文件中包含。

在代码中，首先定义了一个名为Config的配置对象。它包含一个名为getCertPool的函数，用于获取证书池。

然后，在函数内部，通过判断Config对象中是否启用了系统根(DisableSystemRoot)，来决定是否加载系统证书。如果不启用系统根，则直接使用调用loadSelfCertPool函数加载本地证书池。如果启用了系统根，则不会加载本地证书池，需要通过加载自签名证书来获取证书池。

最后，函数返回一个指向x509.CertPool的指针，如果调用失败则返回nil。


```go
// +build windows
// +build !confonly

package xtls

import "crypto/x509"

func (c *Config) getCertPool() (*x509.CertPool, error) {
	if c.DisableSystemRoot {
		return c.loadSelfCertPool()
	}

	return nil, nil
}

```

# `transport/internet/xtls/errors.generated.go`

这段代码定义了一个名为 xtLS 的包，其中包含一个名为 errPathObjHolder 的结构体类型和一个名为 newError 的函数。

errPathObjHolder 是一个空结构体类型，没有任何成员变量。

newError 函数接收多个参数，其中 values 是其中的一个参数。这个函数创建一个新的 errors.Error 对象，并使用 values 中的任何一个对象来设置错误对象的错误路径对象。最后，这个函数返回一个新的 errors.Error 对象，并将错误对象的错误路径对象设置为 errPathObjHolder 类型的实例。

这段代码的作用是定义了一个用于创建错误对象的函数，可以用来创建一个新的 errors.Error 对象，并设置错误对象的错误路径对象。使用时，可以调用 newError 函数并传递多个参数，以表示错误对象需要传递的值。


```go
package xtls

import "v2ray.com/core/common/errors"

type errPathObjHolder struct{}

func newError(values ...interface{}) *errors.Error {
	return errors.New(values...).WithPathObj(errPathObjHolder{})
}

```

# `transport/internet/xtls/xtls.go`

这段代码是一个Go语言编写的工程命令，用于构建一个名为"xtls"的包。构建时会生成一个名为"go run v2ray.com/core/common/errors/errorgen"的运行时，用于在运行时使用。同时，它还创建了一个名为"!confonly"的标志，用于指示构建过程仅在生产环境输出，而不会在开发环境中输出。

具体来说，代码中：

1. 导入"xtls"包及其相关的导入语句。

2. 定义了一个名为"*conn"的类型，该类型代表一个允许写入的目标连接。

3. 定义了一个名为"!confonly"的标志，用于指示构建过程仅在生产环境输出，而不会在开发环境中输出。

4. 定义了一个名为"main"的函数，该函数没有实现具体的逻辑。

5. 在函数外定义了一个名为"buf.Writer"的函数，该函数是一个接受目标缓冲区的写入函数。

6. 在定义的"buf.Writer"函数中，创建了一个代表当前连接的"*conn"类型的变量，并将其赋值为nil，即一个空的目标连接。

7. 最后一行定义了一个名为"errorgen"的运行时，用于在运行时使用。


```go
// +build !confonly

package xtls

import (
	xtls "github.com/xtls/go"

	"v2ray.com/core/common/buf"
	"v2ray.com/core/common/net"
)

//go:generate go run v2ray.com/core/common/errors/errorgen

var (
	_ buf.Writer = (*Conn)(nil)
)

```

该代码定义了一个名为Conn的结构体，该结构体包含一个指向xtls.Conn的指针。

在WriteMultiBuffer函数中，将传入的buf.MultiBuffer进行压缩，并将其赋值给mb。接着，使用buf.WriteMultiBuffer函数将mb发送到连接上，然后使用buf.ReleaseMulti函数释放mb，最后返回错误。

在HandshakeAddress函数中，如果发现在初始化套接字时出现错误，则返回 nil。接着，获取当前连接状态并将其存储在state变量中。如果state.ServerName为空，则返回 nil。最后，使用net.ParseAddress函数将获取到的服务器名称解析为net.Address类型。


```go
type Conn struct {
	*xtls.Conn
}

func (c *Conn) WriteMultiBuffer(mb buf.MultiBuffer) error {
	mb = buf.Compact(mb)
	mb, err := buf.WriteMultiBuffer(c, mb)
	buf.ReleaseMulti(mb)
	return err
}

func (c *Conn) HandshakeAddress() net.Address {
	if err := c.Handshake(); err != nil {
		return nil
	}
	state := c.ConnectionState()
	if state.ServerName == "" {
		return nil
	}
	return net.ParseAddress(state.ServerName)
}

```

这段代码定义了两个名为 Client 和 Server 的函数，用于在给定的网络连接上发起 XTLS 会话。Client 函数用于创建一个 XTLS 客户端会话，而 Server 函数用于创建一个 XTLS 服务器会话。

Client 和 Server 函数的实现都使用 xtls.Client 和 xtls.Server 函数来创建 XTLS 会话。其中，xtls.Client 函数用于在客户端发起会话，xtls.Server 函数用于在服务器发起会话。

在函数内部，首先创建一个名为 xtlsConn 的 XTLS 会话。接着，分别调用 xtls.Client 和 xtls.Server 函数来创建 XTLS 会话。最后，将创建好的 XTLS 会话返回，作为函数的返回值。

通过 Client 和 Server 函数，可以使得客户端和服务器之间建立安全可靠的 XTLS 会话。这些函数使得在客户端和服务器之间传输数据更加安全和可靠。


```go
// Client initiates a XTLS client handshake on the given connection.
func Client(c net.Conn, config *xtls.Config) net.Conn {
	xtlsConn := xtls.Client(c, config)
	return &Conn{Conn: xtlsConn}
}

// Server initiates a XTLS server handshake on the given connection.
func Server(c net.Conn, config *xtls.Config) net.Conn {
	xtlsConn := xtls.Server(c, config)
	return &Conn{Conn: xtlsConn}
}

```

# `transport/pipe/impl.go`

这段代码是一个名为 "pipe" 的包，它实现了异步传输的基本功能。下面是代码的一些关键部分，我将对其进行逐步解释。

1. 导入需要的库：


import (
	"errors"
	"io"
	"runtime"
	"sync"
	"time"

	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	"v2ray.com/core/common/signal"
	"v2ray.com/core/common/signal/done"
)


这些库提供了异步传输所需的基本功能，例如错误处理、IO 操作、时间同步、信号等功能。

2. 定义了 "pipe" 包的结构：


package pipe


这个包定义了一个名为 "pipe" 的包，将以下导出为 "pipe" 包的函数和变量。

3. 定义了 "Pipe" 接口：


type Pipe<out chan, in chan> 
{
   // 连接到 "out" 和 "in" 端口
   Out(chan):
       chan<-in,<-out>
   In(chan):
       <-in,<-out>
   Close(int):
       int
}


这个接口定义了 "pipe" 包中所有函数和变量的必要说明，包括连接到端口、读写数据等。

4. 实现了 "Pipe" 接口：


package pipe


在这个包的实现中，我们通过 "out" 和 "in" 端口连接到 "common/signal" 和 "v2ray.com/core/common/ errors" 包中定义的信号，实现了 "Pipe" 接口。


import (
   "errors"
   "io"
   "runtime"
   "sync"
   "time"

	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	"v2ray.com/core/common/signal"
	"v2ray.com/core/common/signal/done"
)

type Pipe<out chan, in chan> 
{
   // 连接到 "out" 和 "in" 端口
	Out(chan):
		chans := make(chan<-in,<-out>)
	In(chan):
		<-in,<-out>
	Close(int):
		int
	// 连接关闭的信号
		done.SigInt
}


在这个实现中，我们使用了 "common/signal" 和 "v2ray.com/core/common/ errors" 包中的信号来实现异步传输所需的基本功能，包括错误处理、IO 操作、时间同步、信号等。

在这个 "Pipe" 接口中，我们使用了一个名为 "Out" 的函数和一个名为 "In" 的函数来连接到 "out" 和 "in" 端口，并实现了 "close" 函数来关闭连接。

另外，我们还实现了一个名为 "done" 的信号，用于通知所有连接的 "done" 函数，以完成 "Pipe" 的连接操作。


```go
package pipe

import (
	"errors"
	"io"
	"runtime"
	"sync"
	"time"

	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	"v2ray.com/core/common/signal"
	"v2ray.com/core/common/signal/done"
)

```

这段代码定义了一个名为`pipeOption`的结构体类型，它包含两个整型字段`limit`和`discardOverflow`，以及一个名为`isFull`的布尔变量。

同时，还定义了一个名为`open`的整型变量，一个名为`closed`的整型变量，和一个名为`errord`的整型变量。

`pipeOption`结构体定义了一个`isFull`方法，该方法接收一个整型变量`curSize`，并返回`true`如果`curSize`不超出`limit`的最大缓冲区大小，否则返回`false`。

`isFull`方法的实现比较简单，它比较了当前缓冲区大小`curSize`和最大缓冲区大小`limit`，如果`curSize`不超出`limit`，则返回`true`，否则返回`false`。

另外，`open`变量定义了一个整型变量`iota`，它是一个自动递增的整数，用于初始化一个名为` closed`的变量。

`closed`变量定义了一个整型变量`errord`，它用于定义一个错误处理程序。

最后，没有定义任何方法或函数，也没有定义任何外部变量或函数。


```go
type state byte

const (
	open state = iota
	closed
	errord
)

type pipeOption struct {
	limit           int32 // maximum buffer size in bytes
	discardOverflow bool
}

func (o *pipeOption) isFull(curSize int32) bool {
	return o.limit >= 0 && curSize > o.limit
}

```

这是一个 Go 语言中的结构体，定义了一个名为 `pipe` 的管道组件。`pipe` 旨在解决多个缓冲区同时发送/接收数据时的多个问题。

具体来说，这个 `pipe` 结构体包含以下几个部分：

1. 一个 `sync.Mutex`，用于在多个读/写请求同时有多个数据时，保证数据读/写的互斥。
2. 一个 `buf.MultiBuffer`，用于同时读/写多个缓冲区。
3. 一个指向 `signal.Notifier` 的指针，用于通知读/写请求的完成。
4. 一个指向 `done.Instance` 的指针，用于通知操作完成（尽管 `done` 本身是一个遥信，这里应该是指通知）。
5. 一个 `pipeOption` 字段，用于设置管道的一些选项。
6. 一个 `state` 字段，用于表示当前管道状态（可能包括错误）。

`getState` 函数用于获取 `pipe` 实例的当前状态，根据 `forRead` 和 `option` 两个参数来判断，函数的实现如下：

go
func (p *pipe) getState(forRead bool) error {
	switch p.state {
	case open:
		if !forRead && p.option.isFull(p.data.Len()) {
			return errBufferFull
		}
		return nil
	case closed:
		if !forRead {
			return io.ErrClosedPipe
		}
		if !p.data.IsEmpty() {
			return nil
		}
		return io.EOF
	case errord:
		return io.ErrClosedPipe
	default:
		panic("impossible case")
	}
}


这个 `getState` 函数首先根据 `forRead` 和 `option` 两个参数判断 `pipe` 实例的当前状态，然后根据不同的状态采取不同的措施。

- 如果 `forRead` 为 `false` 且 `option.isFull(p.data.Len())`，那么这种情况通常应该尽量避免，因为同时发送多个缓冲区可能会导致数据读/写的丢失。此时，函数返回一个 `errBufferFull` 的错误。
- 如果 `forRead` 为 `true` 或者 `option.isFull(p.data.Len())`，那么这些请求都可以正常进行，函数返回 `nil`。
- 如果 `closed` 且 `forRead` 为 `true`，那么函数返回 `io.ErrClosedPipe`。
- 如果 `closed` 且 `forRead` 为 `false`，那么函数返回 `io.EOF`，因为此时所有请求都已经完成。
- 如果 `errord`，则函数直接返回 `io.ErrClosedPipe`，因为此时数据已经到达了 `done`，这个错误通常不会出现。

无论哪种情况，函数的实现都遵循了 Go 语言编程规范中的错误处理原则。


```go
type pipe struct {
	sync.Mutex
	data        buf.MultiBuffer
	readSignal  *signal.Notifier
	writeSignal *signal.Notifier
	done        *done.Instance
	option      pipeOption
	state       state
}

var errBufferFull = errors.New("buffer full")
var errSlowDown = errors.New("slow down")

func (p *pipe) getState(forRead bool) error {
	switch p.state {
	case open:
		if !forRead && p.option.isFull(p.data.Len()) {
			return errBufferFull
		}
		return nil
	case closed:
		if !forRead {
			return io.ErrClosedPipe
		}
		if !p.data.IsEmpty() {
			return nil
		}
		return io.EOF
	case errord:
		return io.ErrClosedPipe
	default:
		panic("impossible case")
	}
}

```

这段代码是Go语言中pipecipient类的一个函数，它接收一个名为pipe的管道句柄（pipe.Reader或pip.Writer），并返回一个缓冲区.MultiBuffer，或者错误（.Error）。

函数的作用是读取给定的多个数据流（multi-byte data streams）中的数据，并返回给定的缓冲区.MultiBuffer。在函数内部，首先尝试从管道中读取数据，如果失败则返回nil。如果成功读取数据，则将其复制到名为data的变量中，并将给定管道中的数据复制到名为p.data的变量中。

函数有一个无返回值的函数式接口，它返回一个名为buf的缓冲区和一个名为err的错误。通过调用pipecipient.ReadMultiBuffer函数，可以读取多个数据流中的数据并将其复制到缓冲区中。当缓冲区已满或者读取完成后，函数会发送一个Signal信号通知所有已连接的缓冲区读者继续读取数据。如果函数执行完毕，则会等待缓冲区读者执行完他们的操作并返回结果。


```go
func (p *pipe) readMultiBufferInternal() (buf.MultiBuffer, error) {
	p.Lock()
	defer p.Unlock()

	if err := p.getState(true); err != nil {
		return nil, err
	}

	data := p.data
	p.data = nil
	return data, nil
}

func (p *pipe) ReadMultiBuffer() (buf.MultiBuffer, error) {
	for {
		data, err := p.readMultiBufferInternal()
		if data != nil || err != nil {
			p.writeSignal.Signal()
			return data, err
		}

		select {
		case <-p.readSignal.Wait():
		case <-p.done.Wait():
		}
	}
}

```

这段代码定义了一个名为 `func` 的函数，接收一个名为 `pipe` 的指针参数，并返回一个名为 `buf.MultiBuffer` 的双向缓冲区和一个名为 `error` 的错误类型。函数的作用是在一个 timeout 时间间隔内，从 `pipe` 的 `readMultiBufferInternal` 函数中读取数据，并在读取完成后，如果读取成功，则输出数据并返回；如果读取失败，则发送 `readSignal` 信号，并返回错误信息。

函数内部使用了多线程安全技术，以确保在 `for` 循环期间，如果有多个读取请求正在等待，则只有一个读取请求会被执行。在读取完成后，函数会检查是否有读取完成，如果是，则发送 `done` 信号给 `pipe`，等待所有请求完成。如果计时器超时，则会发送 `C` 信号给 `timer` 停止计时，并返回一个名为 `nil` 的错误。


```go
func (p *pipe) ReadMultiBufferTimeout(d time.Duration) (buf.MultiBuffer, error) {
	timer := time.NewTimer(d)
	defer timer.Stop()

	for {
		data, err := p.readMultiBufferInternal()
		if data != nil || err != nil {
			p.writeSignal.Signal()
			return data, err
		}

		select {
		case <-p.readSignal.Wait():
		case <-p.done.Wait():
		case <-timer.C:
			return nil, buf.ErrReadTimeout
		}
	}
}

```

此函数的作用是执行一个名为 `writeMultiBufferInternal` 的函数，该函数接受一个名为 `mb` 的 `MultiBuffer` 参数。

函数的主要作用是读取传入的 `mb` 并将其写入一个名为 `p.data` 的缓冲区中。在写入之前，函数先尝试从传入的 `mb` 中读取数据，若读取失败则返回一个错误。

若要执行此函数，您需要在其定义之前定义一个名为 `writeMultiBufferInternal` 的函数，并在需要时调用它。


```go
func (p *pipe) writeMultiBufferInternal(mb buf.MultiBuffer) error {
	p.Lock()
	defer p.Unlock()

	if err := p.getState(false); err != nil {
		return err
	}

	if p.data == nil {
		p.data = mb
		return nil
	}

	p.data, _ = buf.MergeMulti(p.data, mb)
	return errSlowDown
}

```

这段代码是一个名为 `func` 的函数，接收一个名为 `pipe` 的指针参数，以及一个名为 `MultiBuffer` 的 `MultiBuffer` 类型参数。

函数的作用是接收一个 `MultiBuffer`，将其中的数据写入管道中的目标 `MultiBuffer`，并在写入过程中处理可能出现的错误。

以下是具体的实现步骤：

1. 如果 `MultiBuffer` 为空，函数返回 `nil`。
2. 对于每个数据包，函数调用 `p.writeMultiBufferInternal` 函数将其写入管道中的目标 `MultiBuffer`。
3. 如果写入过程中出现错误，函数会根据不同的错误类型采取不同的措施：
	* 如果出现 `errSlowDown`，函数会尝试暂停读取，等待读取器追赶上并继续写入。
	* 如果出现 `errBufferFull`，函数会尝试释放已分配的 `MultiBuffer`，并继续写入。
	* 如果 `p.option.discardOverflow` 为 `true`，函数会尝试释放已分配的 `MultiBuffer`，并继续写入。
4. 如果写入过程中成功，函数会通知读取器有数据可用，并返回 `nil`。
5. 如果读取器已经准备好，函数会继续等待，直到有数据可用并返回。


```go
func (p *pipe) WriteMultiBuffer(mb buf.MultiBuffer) error {
	if mb.IsEmpty() {
		return nil
	}

	for {
		err := p.writeMultiBufferInternal(mb)
		if err == nil {
			p.readSignal.Signal()
			return nil
		}

		if err == errSlowDown {
			p.readSignal.Signal()

			// Yield current goroutine. Hopefully the reading counterpart can pick up the payload.
			runtime.Gosched()
			return nil
		}

		if err == errBufferFull && p.option.discardOverflow {
			buf.ReleaseMulti(mb)
			return nil
		}

		if err != errBufferFull {
			buf.ReleaseMulti(mb)
			p.readSignal.Signal()
			return err
		}

		select {
		case <-p.writeSignal.Wait():
		case <-p.done.Wait():
			return io.ErrClosedPipe
		}
	}
}

```

该代码实现了一个名为 `func` 的函数，接收一个名为 `pipe` 的指针参数，该函数的作用是关闭管道并处理可能的异常。

具体来说，以下是该函数的实现步骤：

1. 首先获取 `pipe` 指针所指向的管道对象，并使用 `Lock` 函数保证只读。
2. 在函数中使用 `defer` 关键字声明一个名为 `Unlock` 的函数，该函数在管道关闭之后被调用，确保在调用 `Close` 函数之前所有挂起的读或写操作都已经完成。
3. 如果 `pipe` 指针所指向的管道状态为 `closed` 或 `errord`，则直接返回，因为这些状态已经意味着管道已关闭，不需要做其他操作。
4. 如果 `pipe` 指针所指向的管道状态不是 `closed` 或 `errord`，则调用 `Close` 函数关闭管道。
5. 在 `Interrupt` 函数中，使用 `Lock` 函数保证只读。
6. 如果 `pipe` 指针所指向的管道状态不是 `closed` 或 `errord`，则调用 `Interrupt` 函数。
7. 在 `Interrupt` 函数中，使用 `Unlock` 函数释放所有已经挂起的读或写操作。
8. 在 `Close` 函数中，由于 `pipe` 指针所指向的管道已经关闭，不需要执行其他操作。
9. 在 `Interrupt` 函数中，如果 `pipe` 指针所指向的管道存在数据，则使用 `ReleaseMulti` 函数将数据释放。
10. 在 `Interrupt` 函数中，调用 `Close` 函数关闭所有已经挂起的读或写操作。


```go
func (p *pipe) Close() error {
	p.Lock()
	defer p.Unlock()

	if p.state == closed || p.state == errord {
		return nil
	}

	p.state = closed
	common.Must(p.done.Close())
	return nil
}

// Interrupt implements common.Interruptible.
func (p *pipe) Interrupt() {
	p.Lock()
	defer p.Unlock()

	if p.state == closed || p.state == errord {
		return
	}

	p.state = errord

	if !p.data.IsEmpty() {
		buf.ReleaseMulti(p.data)
		p.data = nil
	}

	common.Must(p.done.Close())
}

```

# `transport/pipe/pipe.go`

这段代码定义了一个名为`Pipe`的包，包含了一些与`Pipe`相关的函数和选项。

`import`语句导入了一些外部的包，包括`v2ray.com/core/common/signal`包，它提供了用于`v2ray.com`协议的`Signal`类型，以及`policy`包，它提供了用于策略的选项。

`type Option func(*pipeOption)`定义了一个名为`Option`的函数类型，它接受一个`*pipeOption`类型的参数。

`func WithoutSizeLimit() Option`定义了一个名为`WithoutSizeLimit`的函数，它返回一个`Option`类型，这个选项表示`Pipe`可以在没有大小限制的情况下使用。这个函数将`limit`字段设置为`-1`，表示它不会限制`Pipe`的大小。

由于没有定义任何函数体，所以无法了解这段代码的实际作用，但是可以看出它定义了一个`Pipe`包，其中包含了一些用于`Pipe`的函数和选项。


```go
package pipe

import (
	"context"

	"v2ray.com/core/common/signal"
	"v2ray.com/core/common/signal/done"
	"v2ray.com/core/features/policy"
)

// Option for creating new Pipes.
type Option func(*pipeOption)

// WithoutSizeLimit returns an Option for Pipe to have no size limit.
func WithoutSizeLimit() Option {
	return func(opt *pipeOption) {
		opt.limit = -1
	}
}

```

这两段代码定义了两个高阶函数，旨在为`pipe`函数提供更多的选项。

`WithSizeLimit`函数接收一个`int32`类型的参数`limit`，并返回一个`Option`类型。这个函数的作用是设置`pipe`函数的最大大小限制，这样在调用`pipe`函数时，如果超过这个限制，函数会返回一个`None`，避免了产生错误。

`DiscardOverflow`函数同样接收一个`Option`类型的参数，然后返回一个`Option`类型。这个函数的作用是，如果`pipe`函数正在写入数据，但是堆栈已经溢出，那么函数将丢弃所有的写入数据，避免了产生错误。

这两段代码定义了两个高阶函数，可以作为选项传递给`pipe`函数，用于设置或取消堆栈溢出。


```go
// WithSizeLimit returns an Option for Pipe to have the given size limit.
func WithSizeLimit(limit int32) Option {
	return func(opt *pipeOption) {
		opt.limit = limit
	}
}

// DiscardOverflow returns an Option for Pipe to discard writes if full.
func DiscardOverflow() Option {
	return func(opt *pipeOption) {
		opt.discardOverflow = true
	}
}

// OptionsFromContext returns a list of Options from context.
```

该代码定义了两个名为`OptionsFromContext`和`New`的函数。

函数`OptionsFromContext`接收一个`context.Context`作为参数，并返回一个选项数组。函数实现了一个`policy.BufferPolicyFromContext`的实例，用于从当前上下文中获取缓冲区策略，并将其存储在名为`opt`的选项数组中。如果缓冲区策略不为零，函数将在选项数组中添加一个大小限制的选项，否则将添加一个不包含大小的选项。最后，函数返回选项数组。

函数`New`接收一个或多个选项，并返回一个名为`Reader`和一个名为`Writer`的组合，这两个组合将连接到缓冲区。函数创建了一个`pipe`实例，其中包含一个读取信号和一个写入信号。`pipeOption`结构包含一个缓冲区限制，用于指定可以写入缓冲区的大小。

对于每个选项，函数将其传递给`pipeOption`实例中的`option`字段，并将它与之前创建的`pipe`实例连接起来。`option`字段包含一个指向`option`实例的引用，以便在需要时进行修改。

函数`New`返回一个`Reader`和一个`Writer`实例，这些实例将连接到缓冲区，并可以写入和读取数据。


```go
func OptionsFromContext(ctx context.Context) []Option {
	var opt []Option

	bp := policy.BufferPolicyFromContext(ctx)
	if bp.PerConnection >= 0 {
		opt = append(opt, WithSizeLimit(bp.PerConnection))
	} else {
		opt = append(opt, WithoutSizeLimit())
	}

	return opt
}

// New creates a new Reader and Writer that connects to each other.
func New(opts ...Option) (*Reader, *Writer) {
	p := &pipe{
		readSignal:  signal.NewNotifier(),
		writeSignal: signal.NewNotifier(),
		done:        done.New(),
		option: pipeOption{
			limit: -1,
		},
	}

	for _, opt := range opts {
		opt(&(p.option))
	}

	return &Reader{
			pipe: p,
		}, &Writer{
			pipe: p,
		}
}

```