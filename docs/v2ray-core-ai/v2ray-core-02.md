# v2ray-core源码解析 2

# `app/commander/config.pb.go`

该代码是一个 Go 语言程序，它导出了一个名为 "commander" 的包的接口定义。这个包可能用于与其他包进行通信，或者用于配置和序列化数据。

首先，该代码定义了一个名为 "config" 的接口，该接口定义了需要配置的参数。然后，该代码导出了 "commander" 包的接口定义，这个包可能包含实现这个接口的所有组件。

接下来，该代码导入了一些依赖项，包括 "github.com/golang/protobuf/proto"、"google.golang.org/protobuf/reflect/protoreflect"、"google.golang.org/protobuf/runtime/protoimpl" 和 "reflect"。这些依赖项可能用于提供命令行应用程序的协议头信息、反向代理、代码生成器等功能。

最后，该代码还导入了 "v2ray.com/core/common/serial" 包，该包可能用于在命令行应用程序中序列化和反序列化数据。


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: app/commander/config.proto

package commander

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	serial "v2ray.com/core/common/serial"
)

```

这段代码是一个Go语言中的const类型，定义了一个名为Config的结构体类型。这个Config结构体类型的定义了在Go 2.0中应该使用的足够老旧的遗留protobuf包版本，以及用于Commander的设置。

具体来说，代码的作用是：

1. 验证Go 2.0足够老旧的遗留protobuf包版本，以保证不会影响现有的Go 2.0应用。这个功能是通过执行protoimpl.EnforceVersion函数来实现的，这个函数会比较当前下载的protobuf包版本和protoimpl.MinVersion和protoimpl.MaxVersion之间的差距，如果差距大于20，则会强制使用较旧的版本。

2. 验证运行时/protoimpl包足够老旧，以保证不会影响Go 2.0应用的运行时和protobuf功能。这个验证是通过执行protoimpl.EnforceVersion函数来实现的，函数会比较当前下载的protobuf包版本和protoimpl.MinVersion和protoimpl.MaxVersion之间的差距，如果差距大于20，则会强制使用较旧的版本。

3. 通过定义一个名为_的const类型，来设置一个临时的、足够老旧的遗留protobuf包版本。这个const类型在代码中多次被用来配置各种Go 2.0的依赖，所以它并不会对Go 2.0应用的运行时产生影响。

4. 通过一个名为_的变量，来存储一个临时的、足够老旧的遗留protobuf包版本，这个变量会在需要的时候被用来配置Go 2.0的依赖。这个变量在代码中被用来配置Commander的服务，所以它对于Go 2.0应用的运行时是至关重要的。


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

// Config is the settings for Commander.
type Config struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Tag of the outbound handler that handles grpc connections.
	Tag string `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
	// Services that supported by this server. All services must implement Service
	// interface.
	Service []*serial.TypedMessage `protobuf:"bytes,2,rep,name=service,proto3" json:"service,omitempty"`
}

```

这是一个C++语言的函数，接收一个指向Config类型结构体的指针变量x，并实现了两个函数：Reset和String。

Reset函数首先将接收的指针变量x的值设为Config{}，然后检查是否启用了UnsafeEnabled日志记录，如果是，则执行以下操作：

1. 在内存中查找一个名为"file_app_commander_config_proto_msgTypes"的类型定义，并查找一个名为"Config"的类型别名。
2. 创建一个名为"file_app_commander_config_proto_msgTypes"的接口类型，并将其作为类型别名，类型定义中的"Config"类型别名。
3. 使用类型定义中的指针类型创建一个名为"mi"的指针变量，并将其存储为类型定义中的"Config"类型别名。
4. 使用类型定义中的指针类型创建一个名为"ms"的指针变量，并将其存储为类型定义中的"Config"类型别名。
5. 调用类型定义中的"StoreMessageInfo"函数，并将mi和ms作为参数，存储的消息信息类型为"Config"的实例将作为参数传递。

String函数执行以下操作：

1. 调用类型定义中的"MessageStringOf"函数，将接收的Config结构体作为参数，并将结果存储到一个字符串变量中。

这两函数一起作用于Config结构体，实现了将接收的Config结构体转换为字符串的能力。


```go
func (x *Config) Reset() {
	*x = Config{}
	if protoimpl.UnsafeEnabled {
		mi := &file_app_commander_config_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

```

此代码定义了两个函数，函数一是将一个名为`Config`的`*Message`类型的`x`对象转换为`protoreflect.Message`类型，函数二是返回`Config`对象的`descriptor`字段。

函数一：
kotlin
func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_app_commander_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

此函数的作用是将`x`对象转换为一个`protoreflect.Message`类型。首先，它创建一个指向`file_app_commander_config_proto_msgTypes[0]`类型对象的引用。然后，如果`protoimpl.UnsafeEnabled`为`true`，则执行以下操作：尝试从`x`对象中恢复一个`Message`类型的`ms`，如果可以，则将其转换为一个`ms.LoadMessageInfo`类型的`ms`，否则将其存储为一个包含`mi`类型对象的`ms`。最后，返回`ms`的`MessageOf`函数的返回值作为`protoreflect.Message`类型对象的`msg`字段。

函数二：
kotlin
// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_app_commander_config_proto_rawDescGZIP(), []int{0}
}

此函数返回`Config`对象的`descriptor`字段的值，其中`file_app_commander_config_proto_rawDescGZIP()`函数返回了`file_app_commander_config_proto_rawDescGZIP`函数的返回值，它是一个`protoreflect.Message`类型对象，具有`descriptor`字段的`msg`字段。


```go
func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_app_commander_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_app_commander_config_proto_rawDescGZIP(), []int{0}
}

```

此代码定义了两个函数，分别接收一个`Config`类型的参数`x`，并返回其标签和服务的列表。

这两个函数都使用了`if`语句，当`x`不为`nil`时，返回`x`的标签值；否则返回一个空字符串。这两个函数的实现都使用了`x.Tag`和`x.Service`，这两个字段都是`Config`类型的成员变量，很可能从`Config`的定义中得到。

函数`File_app_commander_config_proto`是一个来自`protoreflect`的`FileDescriptor`类型，它提供了一个接口，用于定义`Config`的序列化和反序列化。


```go
func (x *Config) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

func (x *Config) GetService() []*serial.TypedMessage {
	if x != nil {
		return x.Service
	}
	return nil
}

var File_app_commander_config_proto protoreflect.FileDescriptor

```

0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x61, 0x79,
	0x2e, 0x63, 0x6f, 0x6d, 0x6e, 0x72, 0x65, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x61, 0x6e, 0x64,
	0x65, 0x72, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,


```go
var file_app_commander_config_proto_rawDesc = []byte{
	0x0a, 0x1a, 0x61, 0x70, 0x70, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x65, 0x72, 0x2f,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x18, 0x76, 0x32,
	0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x63, 0x6f, 0x6d,
	0x6d, 0x61, 0x6e, 0x64, 0x65, 0x72, 0x1a, 0x21, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x73,
	0x65, 0x72, 0x69, 0x61, 0x6c, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x64, 0x5f, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x5c, 0x0a, 0x06, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x74, 0x61, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x74, 0x61, 0x67, 0x12, 0x40, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63,
	0x6f, 0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x73, 0x65, 0x72, 0x69, 0x61,
	0x6c, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x07,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x42, 0x59, 0x0a, 0x1c, 0x63, 0x6f, 0x6d, 0x2e, 0x76,
	0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x65, 0x72, 0x50, 0x01, 0x5a, 0x1c, 0x76, 0x32, 0x72, 0x61, 0x79,
	0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x61, 0x70, 0x70, 0x2f, 0x63, 0x6f,
	0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x65, 0x72, 0xaa, 0x02, 0x18, 0x56, 0x32, 0x52, 0x61, 0x79, 0x2e,
	0x43, 0x6f, 0x72, 0x65, 0x2e, 0x41, 0x70, 0x70, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64,
	0x65, 0x72, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

```

这段代码定义了一个名为file_app_commander_config_proto_rawDescOnce的变量，其类型为sync.Once，作用是确保一个名为file_app_commander_config_proto_rawDescData的静态变量每次只被访问一次。

接着，定义了一个名为file_app_commander_config_proto_rawDescGZIP的函数，该函数将file_app_commander_config_proto_rawDescData进行GZIP压缩并返回压缩后的二进制字节数组。

在函数内部，使用了protoimpl.X.CompressGZIP()方法，这个方法将一个字节数组通过GZIP压缩算法进行压缩，并返回压缩后的字节数组。

接着，定义了一个名为file_app_commander_config_proto_msgTypes的变量，它使用了protoimpl.MessageInfo类型，这个类型定义了函数需要输入和输出的消息类型。

最后，定义了一个名为file_app_commander_config_proto_goTypes的变量，它使用了interface{type}类型，定义了函数需要输入和输出的接口类型。

总结起来，这段代码定义了一个名为file_app_commander_config_proto的函数，它接收一个空的超类型参数，返回一个压缩后的字节数组，用于file_app_commander_config_proto.XXX函数的输入和output。


```go
var (
	file_app_commander_config_proto_rawDescOnce sync.Once
	file_app_commander_config_proto_rawDescData = file_app_commander_config_proto_rawDesc
)

func file_app_commander_config_proto_rawDescGZIP() []byte {
	file_app_commander_config_proto_rawDescOnce.Do(func() {
		file_app_commander_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_app_commander_config_proto_rawDescData)
	})
	return file_app_commander_config_proto_rawDescData
}

var file_app_commander_config_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_app_commander_config_proto_goTypes = []interface{}{
	(*Config)(nil),              // 0: v2ray.core.app.commander.Config
	(*serial.TypedMessage)(nil), // 1: v2ray.core.common.serial.TypedMessage
}
```

This is a generated file that implements the initialization of the `file_app_commander_config_proto` type.

The initialization function for this file is implemented using the `protoimpl.TypeBuilder` class, which is used to build the type using the generated descriptors.

The `file_app_commander_config_proto` type is a sub-list of the `extension_field_types` list, which is defined in the `file_app_commander_config_proto.proto` file.

The initialization of the `file_app_commander_config_proto_init` function is used to initialize the `file_app_commander_config_proto` field when the `File_app_commander_config_proto` file is read-only.


```go
var file_app_commander_config_proto_depIdxs = []int32{
	1, // 0: v2ray.core.app.commander.Config.service:type_name -> v2ray.core.common.serial.TypedMessage
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_app_commander_config_proto_init() }
func file_app_commander_config_proto_init() {
	if File_app_commander_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_app_commander_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_app_commander_config_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_app_commander_config_proto_goTypes,
		DependencyIndexes: file_app_commander_config_proto_depIdxs,
		MessageInfos:      file_app_commander_config_proto_msgTypes,
	}.Build()
	File_app_commander_config_proto = out.File
	file_app_commander_config_proto_rawDesc = nil
	file_app_commander_config_proto_goTypes = nil
	file_app_commander_config_proto_depIdxs = nil
}

```

# `app/commander/errors.generated.go`

这段代码定义了一个名为 "errPathObjHolder" 的名为 "errPathObjHolder" 的结构体类型。该类型包含一个名为 "err" 的字段，其类型为 "errors.Error" 并包含一个名为 "pathObj" 的字段，其类型为 "errPathObjHolder" 并包含一个名为 "普通错误" 的字段，其类型为 "errors.Error"。

该代码的目的是提供一个名为 "err" 的字段，该字段通过 "newError" 函数创建一个名为 "err" 的错误对象，并将其 "pathObj" 字段的值设置为给定的参数 "values" 中的一个或多个对象。

通过将一个自定义类型 "errPathObjHolder" 赋值给 "err" 字段的类型，可以保证 "err" 字段始终是一个错误对象，无论它所包含的错误信息如何，都可以通过 "WithPathObj" 方法获取到错误对象的完整路径。


```go
package commander

import "v2ray.com/core/common/errors"

type errPathObjHolder struct{}

func newError(values ...interface{}) *errors.Error {
	return errors.New(values...).WithPathObj(errPathObjHolder{})
}

```

# `app/commander/outbound.go`

这段代码定义了一个名为"commander"的包，它导出了以下几个接口：

1. "build"函数：这是一个通用的 build 函数，它可以在编译时、运行时或只读时编译。

2. "confonly"函数：这是一个通用的 "仅配置" 的函数，它可以在编译时、运行时或只读时运行。

3. "OutboundListener"接口：这是一个net.Listener，用于监听gRPC连接。

4. "context"类型：这是一个用于创建上下文的函数。

5. "sync"类型：这是一个用于 synchronization 的函数。

6. "net"类型：这是一个用于网络通信的函数。

7. "signal"类型：这是一个用于信号的函数。

8. "done"类型：这是一个用于完成的函数。

9. "transport"类型：这是一个用于传输的函数。

通过这些接口，"commander"包可以提供一些常用的功能，比如编译时、运行时或只读时编译，配置独立的运行时，网络连接、同步、信号和完成等。


```go
// +build !confonly

package commander

import (
	"context"
	"sync"

	"v2ray.com/core/common"
	"v2ray.com/core/common/net"
	"v2ray.com/core/common/signal/done"
	"v2ray.com/core/transport"
)

// OutboundListener is a net.Listener for listening gRPC connections.
```

这段代码定义了一个名为 `OutboundListener` 的结构体，它表示网络套接字监听器。

该结构体包含两个方法：

1. `add` 方法，该方法接收一个网络套接字 `conn`并将其添加到监听器中。
2. `<net.Listener>` 类型的 `add` 方法的默认实现，该实现在接收一个网络套接字 `conn`时，将其关闭并返回。

该结构体的 `buffer` 字段是一个 `chan net.Conn`类型的缓冲区，用于存储添加到的网络套接字。

该 `OutboundListener` 结构体的 `done` 字段是一个指向 `done.Instance` 类型的指针，用于通知监听器有新数据可读取。当 `done` 字段指向的实例的 `Ready` 方法被调用时，它将通知所有已经完成的 `OutboundListener` 实例，导致它们开始读取新的数据。

因此，该代码定义了一个网络套接字监听器，用于监听网络套接字，并在接收到数据时通知所有已经完成的 `OutboundListener` 实例。


```go
type OutboundListener struct {
	buffer chan net.Conn
	done   *done.Instance
}

func (l *OutboundListener) add(conn net.Conn) {
	select {
	case l.buffer <- conn:
	case <-l.done.Wait():
		conn.Close() // nolint: errcheck
	default:
		conn.Close() // nolint: errcheck
	}
}

```

这段代码定义了两个名为`Accept`和`Close`的函数，它们都继承自`net.Listener`接口。

`Accept`函数的实现接受一个`OutboundListener`对象`l`，并返回一个`net.Conn`和一个错误。函数的选择行为会连续接受尝试连接的客户端数据，直到客户端连接成功或连接失败。如果连接失败，函数将返回一个`Error`对象。

`Close`函数的实现关闭一个`OutboundListener`对象`l`，返回一个错误。函数的选择行为会等待所有连续的客户端连接 closed，然后关闭并返回一个错误。如果关闭连接失败，函数不会返回任何错误。

这两个函数的实现使得`OutboundListener`对象可以接受客户端连接并接收客户端发送的数据。当客户端连接成功并发送数据时，`Accept`函数会将客户端连接关闭并返回客户端发送的数据。当客户端连接失败或关闭时，`Accept`函数将返回一个错误。当客户端发送数据时，`Close`函数会将客户端连接关闭并返回一个错误。


```go
// Accept implements net.Listener.
func (l *OutboundListener) Accept() (net.Conn, error) {
	select {
	case <-l.done.Wait():
		return nil, newError("listen closed")
	case c := <-l.buffer:
		return c, nil
	}
}

// Close implement net.Listener.
func (l *OutboundListener) Close() error {
	common.Must(l.done.Close())
L:
	for {
		select {
		case c := <-l.buffer:
			c.Close() // nolint: errcheck
		default:
			break L
		}
	}
	return nil
}

```

这是一个 Go 语言中的网络监听器实现，它实现了 net.Listener。Outbound 以 outbound.Handler 类型定义了一个处理 gRPC 连接的 outbound 实例。该实现添加到 net.Listener 类型中，并实现了 net.IPAddr，表示监听的 IP 地址和端口均为 0。代码中定义了一个名为 Outbound 的类型，该类型包含一个标签（tag）和一个 OutboundListener 实例，以及一个名为 access 的 sync.RWMutex 和一个名为 closed 的布尔类型变量。


```go
// Addr implements net.Listener.
func (l *OutboundListener) Addr() net.Addr {
	return &net.TCPAddr{
		IP:   net.IP{0, 0, 0, 0},
		Port: 0,
	}
}

// Outbound is a outbound.Handler that handles gRPC connections.
type Outbound struct {
	tag      string
	listener *OutboundListener
	access   sync.RWMutex
	closed   bool
}

```

该代码是一个 Go 语言中的函数，名为 `Dispatch`。它属于名为 `Outbound` 的传输模式类。

函数的作用是处理通过 `Outbound` 实例发送的数据，实现 `transport.Handler` 接口。以下是函数的步骤：

1. 使用 `co.access.RLock()` 获取 `co` 实例的 `access` 字段（可能为 `null`）。
2. 如果 `co.closed` 的值为 `true`，那么执行以下操作：
   a. 使用 `common.Interrupt(link.Reader)` 停止读取链接的读者；
   b. 使用 `common.Interrupt(link.Writer)` 停止写入链接的写入者；
   c. 使用 `co.access.RUnlock()` 释放访问 `access` 字段的互斥锁；
   d. 使用 `<-closeSignal.Wait()` 等待 `closeSignal` 事件完成。
3. 如果 `co.closed` 的值为 `false`，那么执行以下操作：
   a. 创建一个新的 `closeSignal` 事件；
   b. 使用 `net.NewConnection` 创建一个新的 `网络连接`；
   c. 使用 `net.ConnectionInputMulti` 和 `net.ConnectionOutputMulti` 设置连接的输入和输出；
   d. 使用 `net.ConnectionOnClose` 注册 `closeSignal` 事件的回调函数；
   e. 使用 `co.listener.add(c)` 将 `c` 添加到 `Outbound` 实例的监听器列表中；
   f. 使用 `co.access.RUnlock()` 释放访问 `access` 字段的互斥锁；
   g. 使用 `<-closeSignal.Wait()` 等待 `closeSignal` 事件完成。

这个函数在 `Outbound` 实例中处理数据传输，确保在关闭连接时正确处理并停止所有连接。


```go
// Dispatch implements outbound.Handler.
func (co *Outbound) Dispatch(ctx context.Context, link *transport.Link) {
	co.access.RLock()

	if co.closed {
		common.Interrupt(link.Reader)
		common.Interrupt(link.Writer)
		co.access.RUnlock()
		return
	}

	closeSignal := done.New()
	c := net.NewConnection(net.ConnectionInputMulti(link.Writer), net.ConnectionOutputMulti(link.Reader), net.ConnectionOnClose(closeSignal))
	co.listener.add(c)
	co.access.RUnlock()
	<-closeSignal.Wait()
}

```

该代码实现了一个名为“Tag”的接口，该接口定义了“出站”事件的处理程序。

以下是“Outbound”类的实现，它实现了“Tag”接口：


func (co *Outbound) Tag() string {
	return co.tag
}


该函数返回“co.tag”的值，作为“出站”事件的标签。

以下是“Start”函数的实现，它实现了“common.Runnable”接口：


func (co *Outbound) Start() error {
	co.access.Lock()
	co.closed = false
	co.access.Unlock()
	return nil
}


该函数先获取所有公开访问的端点的锁，然后设置“co.closed”为false，最后返回一个nil值。

以下是“Close”函数的实现，它实现了“common.Closable”接口：


func (co *Outbound) Close() error {
	co.access.Lock()
	defer co.access.Unlock()

	co.closed = true
	return co.listener.Close()
}


该函数先获取所有公开访问的端点的锁，然后设置“co.closed”为true，最后调用“co.listener.Close”函数关闭事件监听器。


```go
// Tag implements outbound.Handler.
func (co *Outbound) Tag() string {
	return co.tag
}

// Start implements common.Runnable.
func (co *Outbound) Start() error {
	co.access.Lock()
	co.closed = false
	co.access.Unlock()
	return nil
}

// Close implements common.Closable.
func (co *Outbound) Close() error {
	co.access.Lock()
	defer co.access.Unlock()

	co.closed = true
	return co.listener.Close()
}

```

# `app/commander/service.go`

这段代码定义了一个名为"commander"的包，其中包含一个名为"Service"的接口，以及用于构建、运行和仅输出命令行工具的实用函数。

具体来说，这段代码：

1. 定义了一个名为"Service"的接口，它包含一个名为"Register"的方法，用于将该服务注册到gRPC服务器上。

2. 在grpc.h文件中导入"google.golang.org/grpc"和"github.com/markbates/g昆仑" packages。

3. 在main函数中，使用package.com.标注命令编译该代码，这将生成一个名为"commander_grpc.go"的易于使用的.go文件。

4. 使用build函数生成一个名为"commander_grpc.wasm"的wasm文件，这将允许在不受最终用户干预的情况下编译该代码以在真实的机器上运行。

5. 使用confonly参数使编译器在编译时不要输出任何命令行参数和选项的列表，这有助于保护编译器免受恶意的攻击。

6. 在.github页面上，有一个名为"Mark Bate"的用户，他经常在.github上分享他的gRPC教程和示例代码，并且尤其喜欢使用Mark Bate作为命令行工具的用户。


```go
// +build !confonly

package commander

import (
	"google.golang.org/grpc"
)

// Service is a Commander service.
type Service interface {
	// Register registers the service itself to a gRPC server.
	Register(*grpc.Server)
}

```

# `app/dispatcher/config.pb.go`

这段代码是一个 Go 语言编写的命令行工具程序，它使用了 Protoc-gen-go 和 protoc 工具来自动生成该工具 program 的接口定义。以下是它的主要作用和所用到的依赖：

1. 定义了该工具程序的接口：通过 `dispatcher/config.proto` 文件定义了 `dispatcher` 包的接口，该接口可以被其他程序或代码使用。
2. 自动生成 Go 代码：使用了 protoc-gen-go 和 protoc 工具来自动生成程序的接口定义，以及程序的其他依赖，如反射、同步等。
3. 解释器：使用反射实现了程序的接口，可以接收和处理输入的 `dispatcher` 包结构。


```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.13.0
// source: app/dispatcher/config.proto

package dispatcher

import (
	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

```

这段代码是一个用于确保生成的代码足够最新版本的const类型的变量。它包含两个 checksum，一个 check使


```go
const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type SessionConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

```

这段代码定义了两个函数，以及一个名为SessionConfig的接口。

这两个函数分别实现了SessionConfig的`Reset`函数和`String`函数。在实现`Reset`函数时，清空了`x`参数的值，并且进行了安全检查，如果使用了`protoimpl.UnsafeEnabled`，则允许了通过非安全的函数指针访问`SessionConfig`类型的实例。在实现`String`函数时，使用了`protoimpl.X.MessageStringOf`函数，将`SessionConfig`的`*x`变量序列化为字节切片并返回。

这两个函数分别实现了`SessionConfig`接口的`Reset`函数和`String`函数。通过这两个函数，可以设置或获取`SessionConfig`实例的值。

另外，还定义了一个名为`SessionConfig`的接口，以及一个名为`SessionConfigImpl`的实现类，该实现类实现了`SessionConfig`接口。这个实现类也实现了`Reset`函数和`String`函数，并且通过重载实现了`SessionConfig`接口的`*SessionConfig`类型。


```go
func (x *SessionConfig) Reset() {
	*x = SessionConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_app_dispatcher_config_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SessionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionConfig) ProtoMessage() {}

```

这段代码定义了两个函数，分别接收一个`SessionConfig`类型的参数`x`，并返回其与`file_app_dispatcher_config_proto_msgTypes`类型相关的类型信息。

函数1：`func (x *SessionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_app_dispatcher_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}`

这段代码的作用是，当`SessionConfig`类型的参数`x`不为`nil`时，尝试使用`file_app_dispatcher_config_proto_msgTypes`类型对应的`descriptor`函数获取该类型的一组字节数组，然后如果`x`被正确地传递，那么使用`file_app_dispatcher_config_proto_msgTypes.Pointer`类型访问`x`的`descriptor`类型，并尝试从`x`的`descriptor`中获取与`file_app_dispatcher_config_proto_msgTypes`类型相关的信息，如果失败，则返回与`file_app_dispatcher_config_proto_msgTypes`类型相关的第一个值。如果`x`被认为是`nil`，则返回与`file_app_dispatcher_config_proto_msgTypes`类型相关的第二个值。

函数2：`func (x *SessionConfig) Descriptor() ([]byte, []int)`

这段代码的作用与函数1类似，但是使用不同的名称，并且返回一个固定长度的字节数组，其中包含两个整数，分别表示与`file_app_dispatcher_config_proto_msgTypes`类型相关的起始索引和结束索引。

由于函数1已经返回了与`file_app_dispatcher_config_proto_msgTypes`类型相关的类型信息，因此函数2中的`Descriptor()`函数没有实际的作用，只是一个名称，用于与函数1中的函数进行匹配。


```go
func (x *SessionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_app_dispatcher_config_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionConfig.ProtoReflect.Descriptor instead.
func (*SessionConfig) Descriptor() ([]byte, []int) {
	return file_app_dispatcher_config_proto_rawDescGZIP(), []int{0}
}

```

这段代码定义了一个名为 "Config" 的结构体类型，该类型包含三个成员变量：state、sizeCache 和 unknownFields。

state 变量是一个 protoimpl.MessageState 类型的成员变量，它用于保存当前配置的状态信息。

sizeCache 变量是一个 protoimpl.SizeCache 类型的成员变量，它用于保存当前配置中的 SizeCache 信息，该信息用于记录缓存的字节数。

unknownFields 变量是一个 protoimpl.UnknownFields 类型的成员变量，它用于保存当前配置中未定义的私有成员变量。

此外，该 struct 还包含一个名为 settings 的成员变量，该成员变量是一个 pointer 类型，指向一个名为 SessionConfig 的结构体类型。

最后，该 struct 还包含一个名为 reset 的函数，该函数用于重置当前配置的 state 变量，并清空 sizeCache 和 unknownFields 中的所有成员变量。如果设置了 protoimpl.UnsafeEnabled，则会自动设置好 unknownFields 中的成员变量。


```go
type Config struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Settings *SessionConfig `protobuf:"bytes,1,opt,name=settings,proto3" json:"settings,omitempty"`
}

func (x *Config) Reset() {
	*x = Config{}
	if protoimpl.UnsafeEnabled {
		mi := &file_app_dispatcher_config_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

```

这段代码定义了两个函数，分别接收一个`Config`类型的参数`x`，并返回与该参数相关的`string`类型和`protoimpl.X.MessageStringOf`类型。

第一个函数`func (x *Config) String() string`接收一个`Config`类型的参数`x`，并将其作为`string`类型返回。这个函数的作用类似于`strconv.Itoa()`函数，将`x`转换为字符串并返回。

第二个函数`func (x *Config) ProtoMessage() []byte`接收一个`Config`类型的参数`x`，并将其作为`protoimpl.X.MessageStringOf`类型返回。这个函数的作用类似于`json.Marshal()`函数，将`x`转换为字节数组并返回。注意，这个函数有一个限制条件，只有在`protoimpl.UnsafeEnabled`是`true`时才会返回字节数组，否则会返回`nil`。

第三个函数`func (x *Config) ProtoReflect() protoreflect.Message`接收一个`Config`类型的参数`x`，并将其作为`file_app_dispatcher_config_proto_msgTypes[1]`类型返回。这个函数的作用类似于`type.Marshal()`函数，将`x`转换为`protoreflect.Message`类型并返回。

第四个函数`func (x *Config) GetConfigValue() Config.Value`接收一个`Config`类型的参数`x`，并返回`x`的`Value`字段，这个字段类型是`Config.Value`类型。这个函数的作用类似于`printf("%.*s", x, x.Value)`，返回`x`的`Value`字段并将其打印出来。


```go
func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_app_dispatcher_config_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

```

0x61 0x70 0x70 0x2e 0x64 0x69 0x73 0x70 0x61 0x74 0x63 0x68 0x65 0x72 0x50 0x01 0x5a 0x1d 0x76 0x32 0x72 0x61 0x79 0x2e 0x63 0x6f 0x6d 0x2f 0x63 0x6f 0x72 0x65 0x2f 0x61 0x70 0x70 0x2e 0x44 0x69 0x73 0x70 0x61 0x74 0x63 0x68 0x65 0x72 0x62 0x06 0x70 0x72 0x6f 0x74 0x6f 0x33



```go
// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_app_dispatcher_config_proto_rawDescGZIP(), []int{1}
}

func (x *Config) GetSettings() *SessionConfig {
	if x != nil {
		return x.Settings
	}
	return nil
}

var File_app_dispatcher_config_proto protoreflect.FileDescriptor

var file_app_dispatcher_config_proto_rawDesc = []byte{
	0x0a, 0x1b, 0x61, 0x70, 0x70, 0x2f, 0x64, 0x69, 0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72,
	0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x19, 0x76,
	0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x64, 0x69,
	0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x22, 0x15, 0x0a, 0x0d, 0x53, 0x65, 0x73, 0x73,
	0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4a, 0x04, 0x08, 0x01, 0x10, 0x02, 0x22,
	0x4e, 0x0a, 0x06, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x44, 0x0a, 0x08, 0x73, 0x65, 0x74,
	0x74, 0x69, 0x6e, 0x67, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x76, 0x32,
	0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x64, 0x69, 0x73,
	0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x08, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x42,
	0x5c, 0x0a, 0x1d, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x72,
	0x65, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x64, 0x69, 0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72,
	0x50, 0x01, 0x5a, 0x1d, 0x76, 0x32, 0x72, 0x61, 0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f,
	0x72, 0x65, 0x2f, 0x61, 0x70, 0x70, 0x2f, 0x64, 0x69, 0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65,
	0x72, 0xaa, 0x02, 0x19, 0x56, 0x32, 0x52, 0x61, 0x79, 0x2e, 0x43, 0x6f, 0x72, 0x65, 0x2e, 0x41,
	0x70, 0x70, 0x2e, 0x44, 0x69, 0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x62, 0x06, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x33,
}

```

此代码定义了一个名为file_app_dispatcher_config_proto_rawDescOnce的变量，其类型为sync.Once，用于保证只有一次对file_app_dispatcher_config_proto_rawDesc的初始化。

同时，定义了一个名为file_app_dispatcher_config_proto_rawDescData的变量，其类型为protoimpl.X.CompressGZIP，用于将file_app_dispatcher_config_proto_rawDescData进行GZIP压缩。

接着，定义了一个名为file_app_dispatcher_config_proto_rawDescGZIP的函数，返回值为file_app_dispatcher_config_proto_rawDescData经过GZIP压缩后的字节切片。

最后，定义了一个名为file_app_dispatcher_config_proto_msgTypes的变量，其类型为protoimpl.MessageInfo，包含两个消息类型，一个用于表示SessionConfig类型，另一个用于表示Config类型。另外，定义了一个名为file_app_dispatcher_config_proto_goTypes的变量，其类型为[]interface{}。


```go
var (
	file_app_dispatcher_config_proto_rawDescOnce sync.Once
	file_app_dispatcher_config_proto_rawDescData = file_app_dispatcher_config_proto_rawDesc
)

func file_app_dispatcher_config_proto_rawDescGZIP() []byte {
	file_app_dispatcher_config_proto_rawDescOnce.Do(func() {
		file_app_dispatcher_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_app_dispatcher_config_proto_rawDescData)
	})
	return file_app_dispatcher_config_proto_rawDescData
}

var file_app_dispatcher_config_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_app_dispatcher_config_proto_goTypes = []interface{}{
	(*SessionConfig)(nil), // 0: v2ray.core.app.dispatcher.SessionConfig
	(*Config)(nil),        // 1: v2ray.core.app.dispatcher.Config
}
```

This is a TypeScript file that defines the structure of the `file_app_dispatcher_config_proto` message.

The `file_app_dispatcher_config_proto` message has two fields:

1. `i`: This field represents an integer value.
2. `v`: This field represents a `SessionConfig` object.

The `SessionConfig` object has a `state` field, which is a field that represents the current state of the session.

If the `state` field is 0, it means that the session has not been initialized yet.

If the `state` field is 1, it means that the session has been initialized and is ready to be used.

If the `state` field is 2, it means that the session has successfully completed an operation and has been saved.

If the `v` field is not provided, it is defaulted to `nil`.

The `file_app_dispatcher_config_proto_msgTypes` field is a mapping of message names to message types. It maps the message names to the corresponding fields in the `SessionConfig` object.

The `file_app_dispatcher_config_proto_Exporter` field is a method that exposes the `SessionConfig` object to the external world. It takes an interface{} parameter and returns an interface{} object.

The `file_app_dispatcher_config_proto_file_app_dispatcher_config_proto_init` function initializes the `file_app_dispatcher_config_proto` file and sets the initial values of the `i` and `v` fields.

The `file_app_dispatcher_config_proto_file_app_dispatcher_config_proto_parseFromText` function parses a `Text` message from the input stream and returns an object that matches the `SessionConfig` object defined in the file.

The `file_app_dispatcher_config_proto_exporter_func` function is the exporter for the `SessionConfig` object. It returns an interface{} object that represents the `SessionConfig` object.

The `file_app_dispatcher_config_proto_go_exporter_func` function is the exporter for the `SessionConfig` object in the `go` environment. It returns an interface{} object that represents the `SessionConfig` object.

The `file_app_dispatcher_config_proto_go_types` field is a mapping of message names to message types in the `go` environment.

The `file_app_dispatcher_config_proto_go_types_mapping` field is a mapping from message names to message types in the `go` environment.

The `file_app_dispatcher_config_proto_go_types_mapping` field is a mapping from message names to message types in the `go` environment.

The `file_app_dispatcher_config_proto_go_types_mapping` field is a mapping from message names to message types in the `go` environment.


```go
var file_app_dispatcher_config_proto_depIdxs = []int32{
	0, // 0: v2ray.core.app.dispatcher.Config.settings:type_name -> v2ray.core.app.dispatcher.SessionConfig
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_app_dispatcher_config_proto_init() }
func file_app_dispatcher_config_proto_init() {
	if File_app_dispatcher_config_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_app_dispatcher_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SessionConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_app_dispatcher_config_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Config); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_app_dispatcher_config_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_app_dispatcher_config_proto_goTypes,
		DependencyIndexes: file_app_dispatcher_config_proto_depIdxs,
		MessageInfos:      file_app_dispatcher_config_proto_msgTypes,
	}.Build()
	File_app_dispatcher_config_proto = out.File
	file_app_dispatcher_config_proto_rawDesc = nil
	file_app_dispatcher_config_proto_goTypes = nil
	file_app_dispatcher_config_proto_depIdxs = nil
}

```

# `app/dispatcher/default.go`

这段代码是一个 Go 语言编写的命令行工具，它用于处理 V2Ray 的配置文件。它包含了一个名为 "dispatcher" 的包，提供了以下功能：

1. 生成指定的 V2Ray 配置文件；
2. 通过 "go run" 运行 Go 运行时，从而运行 "v2ray.com/core/common/errors/errorgen"；
3. 通过 "!confonly" 标志，只输出配置文件的修改内容，而不是整个 V2Ray 安装目录的配置文件；
4. 通过 "v2ray.com/core/features/policy" 配置文件，设置 V2Ray 的策略（policy）；
5. 通过 "v2ray.com/core/features/outbound" 配置文件，设置 V2Ray 的出站策略；
6. 通过 "v2ray.com/core/features/routing" 配置文件，设置 V2Ray 的路由策略；
7. 通过 "v2ray.com/core/features/stats" 配置文件，设置 V2Ray 的统计功能；
8. 通过 "v2ray.com/core/transport" 配置文件，设置 V2Ray 的传输协议；
9. 通过 "v2ray.com/core/transport/pipe" 配置文件，设置 V2Ray 的传输协程。


```go
// +build !confonly

package dispatcher

//go:generate go run v2ray.com/core/common/errors/errorgen

import (
	"context"
	"strings"
	"sync"
	"time"

	"v2ray.com/core"
	"v2ray.com/core/common"
	"v2ray.com/core/common/buf"
	"v2ray.com/core/common/log"
	"v2ray.com/core/common/net"
	"v2ray.com/core/common/protocol"
	"v2ray.com/core/common/session"
	"v2ray.com/core/features/outbound"
	"v2ray.com/core/features/policy"
	"v2ray.com/core/features/routing"
	routing_session "v2ray.com/core/features/routing/session"
	"v2ray.com/core/features/stats"
	"v2ray.com/core/transport"
	"v2ray.com/core/transport/pipe"
)

```

该代码定义了一个名为`cachedReader`的结构体，该结构体代表一个缓存读者。该缓存读者使用一个名为`var`的局部变量来保存错误超时时间，以确保在缓存读者时出错。

`type cachedReader`定义了一个`cachedReader`结构体，该结构体包含以下字段：

* `reader`：一个`pipe.Reader`类型，代表一个网络套接字，用于从网络中读取数据。
* `cache`：一个`buf.MultiBuffer`类型，代表一个多缓冲区缓冲区，用于存储已经下载的数据。
* `errSniffingTimeout`：一个`NewError`类型，用于表示超时错误，该错误将在缓存读者时尝试从网络中读取数据，但若超时则产生。

`Cache`方法用于从缓存中下载数据，并将其存储到缓冲区中。方法使用`reader.ReadMultiBufferTimeout`方法从网络中读取数据，并将其封装到一个`MultiBuffer`对象中。然后，使用`buf.MergeMulti`方法将缓存中的数据与读取的数据进行合并。如果合并成功，则返回一个新的`MultiBuffer`对象，其中包含下载的数据。最后，将下载的数据设置为缓冲区的`Size`字段的整数倍，并返回更新后的缓冲区。

若要使用该缓存读者，可以创建一个`cachedReader`实例，并调用`Cache`方法，传入需要下载的缓冲区作为参数。例如：
scss
var cachedReader = &cachedReader{
	reader: &pipe.Reader{
		Read:   1024,
		Write:  1024,
		Idle:  1024,
		// 超时错误
		Error: &errSniffingTimeout{
			time: 2,
			// 如果在2秒内仍然无法从网络中读取数据，则产生超时错误
		},
	},
	cache: &buf.MultiBuffer{
		// 初始化为1GB
		Max:   1024*1024,
		// 缓存大小
		Size:   1024*1024,
		// 初始化为1GB
		// 是否已用缓存
		Used:  false,
	},
}

cachedReader.Cache(&buf.Buffer{
	Size:   1024,
	// 从网络中读取的数据
	Data: make([]byte, 1024),
})

该代码将创建一个`cachedReader`实例，并使用该实例的`reader`字段下载一个大小为1GB的缓冲区。在下载过程中，如果超时错误，则会产生一个超时错误，并在缓冲区中使用缓存。下载完成后，返回更新后的缓冲区。


```go
var (
	errSniffingTimeout = newError("timeout on sniffing")
)

type cachedReader struct {
	sync.Mutex
	reader *pipe.Reader
	cache  buf.MultiBuffer
}

func (r *cachedReader) Cache(b *buf.Buffer) {
	mb, _ := r.reader.ReadMultiBufferTimeout(time.Millisecond * 100)
	r.Lock()
	if !mb.IsEmpty() {
		r.cache, _ = buf.MergeMulti(r.cache, mb)
	}
	b.Clear()
	rawBytes := b.Extend(buf.Size)
	n := r.cache.Copy(rawBytes)
	b.Resize(0, int32(n))
	r.Unlock()
}

```

这两段代码是描述一个名为`func`的函数，该函数接收一个名为`r`的指针变量和一个名为`cachedReader`的接口类型的变量作为参数。

这两段代码的主要目的是在`cachedReader`缓存器中读取数据，并在需要时返回一个 multibufer 类型的数据。

具体来说，这两段代码实现了一个以下步骤：

1. 如果缓存器不为空，则读取缓存器中的数据，并返回一个 multibufer 类型的数据。
2. 如果缓存器为空，则返回一个名为`nil`的值。
3. 如果缓存器不为空，则读取缓存器中的数据，并返回一个 multibufer 类型的数据。
4. 如果缓存器为空，则返回一个名为`nil`的值。

此外，这两段代码还实现了一个名为`ReadMultiBuffer`的函数，该函数接收一个名为`r`的指针变量和一个名为`cachedReader`的接口类型的变量作为参数。

该函数返回一个名为`buf.MultiBuffer`的多缓冲器类型数据，或者是`nil`的错误类型。

如果缓存器不为空，该函数返回 multibufer 类型的数据，如果缓存器为空，该函数返回一个名为`nil`的错误类型。


```go
func (r *cachedReader) readInternal() buf.MultiBuffer {
	r.Lock()
	defer r.Unlock()

	if r.cache != nil && !r.cache.IsEmpty() {
		mb := r.cache
		r.cache = nil
		return mb
	}

	return nil
}

func (r *cachedReader) ReadMultiBuffer() (buf.MultiBuffer, error) {
	mb := r.readInternal()
	if mb != nil {
		return mb, nil
	}

	return r.reader.ReadMultiBuffer()
}

```

这两段代码定义了一个名为`ReadMultiBufferTimeout`的函数接收一个名为`r`的`cachedReader`对象作为参数，并在 timeout 时间范围内读取多个缓冲区。如果缓冲区成功读取，函数返回缓冲区和 nil 错误；如果发生错误，函数返回 nil 错误。

函数首先检查缓存区是否已经分配，如果已经分配，则直接返回缓存区和 nil 错误。否则，它使用 `r.reader` 的 `ReadMultiBufferTimeout` 函数，将 timeout 时间范围内的所有缓冲区读取到 `r.cache` 缓存区中。最后，函数会尝试通知 `r.reader` 继续读取数据，如果 `r.reader` 已经关闭，函数将不会继续读取，此时返回的也是 nil 错误。

函数 `Interrupt` 接收一个名为 `r` 的`cachedReader` 对象作为参数。这个函数会先尝试通知 `r.reader` 继续读取数据，如果 `r.reader` 已经关闭，函数将不会继续读取，此时返回的也是 nil 错误。然后，函数会尝试通知 `r.cache` 缓存区中的缓冲区释放，如果 `r.cache` 缓存区不为空，函数将释放缓存区中的所有缓冲区。最后，函数会通知 `r.reader` 关闭，此时所有的缓冲区都已经读取完成，函数返回的也是 nil 错误。


```go
func (r *cachedReader) ReadMultiBufferTimeout(timeout time.Duration) (buf.MultiBuffer, error) {
	mb := r.readInternal()
	if mb != nil {
		return mb, nil
	}

	return r.reader.ReadMultiBufferTimeout(timeout)
}

func (r *cachedReader) Interrupt() {
	r.Lock()
	if r.cache != nil {
		r.cache = buf.ReleaseMulti(r.cache)
	}
	r.Unlock()
	r.reader.Interrupt()
}

```

该代码定义了一个名为DefaultDispatcher的结构体，它实现了Dispatcher接口。该结构体包含以下类型的成员变量：

- ohm：是一个outbound.Manager类型的成员变量，用于存储OutboundManager实例。
- router：是一个routing.Router类型的成员变量，用于存储路由器实例。
- policy：是一个policy.Manager类型的成员变量，用于存储策略实例。
- stats：是一个stats.Manager类型的成员变量，用于存储统计数据。

该结构体还包含一个名为init的静态方法。该方法接受两个参数，第一个参数是一个Config类型的上下文，第二个参数是一个空的应用程序上下文。该方法内部创建一个新的DefaultDispatcher实例，并调用其Init方法来自动初始化DefaultDispatcher实例。如果当前代码运行时出现错误，将返回一个非空错误。否则，将返回一个指向DefaultDispatcher实例的引用，表示初始化成功。

该代码的作用是创建一个DefaultDispatcher实例，该实例可以使用OutboundManager、路由器、策略和统计数据进行初始化。


```go
// DefaultDispatcher is a default implementation of Dispatcher.
type DefaultDispatcher struct {
	ohm    outbound.Manager
	router routing.Router
	policy policy.Manager
	stats  stats.Manager
}

func init() {
	common.Must(common.RegisterConfig((*Config)(nil), func(ctx context.Context, config interface{}) (interface{}, error) {
		d := new(DefaultDispatcher)
		if err := core.RequireFeatures(ctx, func(om outbound.Manager, router routing.Router, pm policy.Manager, sm stats.Manager) error {
			return d.Init(config.(*Config), om, router, pm, sm)
		}); err != nil {
			return nil, err
		}
		return d, nil
	}))
}

```

这段代码定义了一个名为DefaultDispatcher的类型，它实现了common.HasType和common.Runnable接口。

在该函数中，首先定义了该dispatcher类型的指针变量d，然后初始化了其 OM(outbound.Manager)、Router(routing.Router)、Policy(policy.Manager)和 Statistics(stats.Manager)。这些变量都是该dispatcher所需的依赖关系，其中 OM 是 outbound.Manager 类型的实例，Router 和 Policy 分别是 routing.Router 和 policy.Manager 类型的实例，Statistics 是 stats.Manager 类型的实例。

然后函数没有返回任何值，接着开始执行 body 中的代码。

在 body 中，首先输出了一条消息 Init initializes DefaultDispatcher.，然后打印了 DefaultDispatcher 的类型(*DefaultDispatcher.Type)，接着又重载了 common.HasType 的函数，使得它能够打印出该dispatcher类型的别名。

最后，开始执行 body 中的代码。


```go
// Init initializes DefaultDispatcher.
func (d *DefaultDispatcher) Init(config *Config, om outbound.Manager, router routing.Router, pm policy.Manager, sm stats.Manager) error {
	d.ohm = om
	d.router = router
	d.policy = pm
	d.stats = sm
	return nil
}

// Type implements common.HasType.
func (*DefaultDispatcher) Type() interface{} {
	return routing.DispatcherType()
}

// Start implements common.Runnable.
```

This appears to be a Go implementation of the Common API for a LinkBridge service that provides a pipe to establish a connection between two endpoints, allowing for the transfer of data in both directions.

The implementation defines a `DefaultDispatcher` struct that implements the ` common.Closable` interface, which requires the implementation of the `Close()` method to return an error when the connection is closed.

The `getLink()` function is used to retrieve the link parameters for the incoming and outgoing connections, creating the appropriate pipes for each direction. The function returns a pointer to the incoming and outgoing links, which can then be used to read or write data.

The `*DefaultDispatcher` struct has fields for the incoming and outgoing links, as well as the statistics for the traffic往上和往下流量的 sizes. These statistics are used to track the traffic being received and sent, allowing for the monitoring and diagnosis of network issues.


```go
func (*DefaultDispatcher) Start() error {
	return nil
}

// Close implements common.Closable.
func (*DefaultDispatcher) Close() error { return nil }

func (d *DefaultDispatcher) getLink(ctx context.Context) (*transport.Link, *transport.Link) {
	opt := pipe.OptionsFromContext(ctx)
	uplinkReader, uplinkWriter := pipe.New(opt...)
	downlinkReader, downlinkWriter := pipe.New(opt...)

	inboundLink := &transport.Link{
		Reader: downlinkReader,
		Writer: uplinkWriter,
	}

	outboundLink := &transport.Link{
		Reader: uplinkReader,
		Writer: downlinkWriter,
	}

	sessionInbound := session.InboundFromContext(ctx)
	var user *protocol.MemoryUser
	if sessionInbound != nil {
		user = sessionInbound.User
	}

	if user != nil && len(user.Email) > 0 {
		p := d.policy.ForLevel(user.Level)
		if p.Stats.UserUplink {
			name := "user>>>" + user.Email + ">>>traffic>>>uplink"
			if c, _ := stats.GetOrRegisterCounter(d.stats, name); c != nil {
				inboundLink.Writer = &SizeStatWriter{
					Counter: c,
					Writer:  inboundLink.Writer,
				}
			}
		}
		if p.Stats.UserDownlink {
			name := "user>>>" + user.Email + ">>>traffic>>>downlink"
			if c, _ := stats.GetOrRegisterCounter(d.stats, name); c != nil {
				outboundLink.Writer = &SizeStatWriter{
					Counter: c,
					Writer:  outboundLink.Writer,
				}
			}
		}
	}

	return inboundLink, outboundLink
}

```

This is a Rust implementation of a middleware router that uses the `net` package for networking and the `stapler` package for middleware.

The router takes a function `Dispatch` as its middleware inline, which means it will be invoked for every incoming request that matches the router's rules.

The `Dispatch` function takes a `ctx` and a `destination` network, and dispatches the connection to that destination.

The router has a condition that checks if the `destination` network is valid. If it's not valid, the middleware will panicked and any inbound connections will be lost.

The router also has a condition that checks if the `SniffingRequest` in the `Content` of the incoming request is enabled or not. If it's not enabled, the middleware will not dispatch any content to the router.

The router is using the `Sniffer` middleware which is a tool that parse the packet contents.

The router also have a function `shouldOverride` which checks if the given `SniffingRequest` have an `OverwriteDestinationForProtocol` flag. If it does, it will override the destination network of the incoming request.


```go
func shouldOverride(result SniffResult, domainOverride []string) bool {
	for _, p := range domainOverride {
		if strings.HasPrefix(result.Protocol(), p) {
			return true
		}
	}
	return false
}

// Dispatch implements routing.Dispatcher.
func (d *DefaultDispatcher) Dispatch(ctx context.Context, destination net.Destination) (*transport.Link, error) {
	if !destination.IsValid() {
		panic("Dispatcher: Invalid destination.")
	}
	ob := &session.Outbound{
		Target: destination,
	}
	ctx = session.ContextWithOutbound(ctx, ob)

	inbound, outbound := d.getLink(ctx)
	content := session.ContentFromContext(ctx)
	if content == nil {
		content = new(session.Content)
		ctx = session.ContextWithContent(ctx, content)
	}
	sniffingRequest := content.SniffingRequest
	if destination.Network != net.Network_TCP || !sniffingRequest.Enabled {
		go d.routedDispatch(ctx, outbound, destination)
	} else {
		go func() {
			cReader := &cachedReader{
				reader: outbound.Reader.(*pipe.Reader),
			}
			outbound.Reader = cReader
			result, err := sniffer(ctx, cReader)
			if err == nil {
				content.Protocol = result.Protocol()
			}
			if err == nil && shouldOverride(result, sniffingRequest.OverrideDestinationForProtocol) {
				domain := result.Domain()
				newError("sniffed domain: ", domain).WriteToLog(session.ExportIDToError(ctx))
				destination.Address = net.ParseAddress(domain)
				ob.Target = destination
			}
			d.routedDispatch(ctx, outbound, destination)
		}()
	}
	return inbound, nil
}

```

该函数的作用是实现了一个简单的网络数据包抓取工具，接收一个cachedReader对象，尝试最多2次从网络上抓取数据包，如果抓取失败则返回相应的错误。

具体来说，该函数首先创建一个包含1MB缓冲区的payload，以及一个名为NewSniffer的函数实例，然后开始一个无限循环，在每次循环中，使用select语句等待ctx上下文操作对象（可能是io.io或net.http.Client）的完成操作，然后执行以下操作：

1. 如果当前尝试已经大于2次，则直接返回nil，表示抓取数据包失败。
2. 如果尝试次数还没有到2次，则创建一个没有内容的payload，并将其缓存到cachedReader中。
3. 使用函数Sniffer.Sniff从网络上抓取数据包，并将其存储在payload中。
4. 如果payload已经是满的，则继续尝试抓取，即尝试最多2次。

函数在每次循环结束后，检查下是否已经遍历了所有的数据包，如果是，则表示所有的数据包都已经抓取完成，此时可以返回之前的结果或者错误，否则继续等待下一次循环。如果尝试了最多2次仍然没有抓到任何数据包，则返回错误。


```go
func sniffer(ctx context.Context, cReader *cachedReader) (SniffResult, error) {
	payload := buf.New()
	defer payload.Release()

	sniffer := NewSniffer()
	totalAttempt := 0
	for {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
			totalAttempt++
			if totalAttempt > 2 {
				return nil, errSniffingTimeout
			}

			cReader.Cache(payload)
			if !payload.IsEmpty() {
				result, err := sniffer.Sniff(payload.Bytes())
				if err != common.ErrNoClue {
					return result, err
				}
			}
			if payload.IsFull() {
				return nil, errUnknownContent
			}
		}
	}
}

```

这段代码定义了一个名为 func 的函数，接收一个指向 DefaultDispatcher 的指针 d，以及一个目标网络目的地 net.Destination。函数的作用是处理经过路由器后，目标为 destination 的数据包。

函数内部首先定义了一个名为 handler 的变量，表示一个 outbound.Handler。这个变量将在后续的 dispatch 过程中被使用。

接着定义了一个名为 skipRoutePick 的布尔变量，用于判断是否跳过路由器选择策略。如果内容（也就是数据包）来自默认内容，那么这个变量将设置为 true，否则设置为 false。

接下来是判断条件，如果 d.router 存在且不为空，那么会执行 d.router.PickRoute 函数。如果选择路由成功，就获取通过路由器后到达目的地 network.Destination。否则，会执行以下操作：

1. 如果跳过路由器选择策略，那么直接将 handler 设置为默认的 outbound.Handler。
2. 如果选择路由失败，那么执行以下操作：

a. 获取所有 outbound 标签（也就是内容）。

b. 通过路由器（也就是 d.router）获取 outbound 标签对应的 handler。

c. 如果 handler 不存在，那么执行以下操作：

i. 输出 "taking detour <标签> for <目标>" 错误消息。

ii. 将 handler 设置为默认的 outbound.Handler。

iii. 设置 skipRoutePick 为 true。

iv. 尝试获取默认内容（也就是默认的 outbound 标签），如果获取成功，就继续执行选择路由器的操作。否则，执行以下操作：

v. 尝试获取所有内容（也就是内容）。

vi. 通过路由器（也就是 d.router）获取 outbound 标签对应的 handler。

vii. 如果 handler 不存在，那么执行以下操作：

viii. 输出 "default route for <目标>" 错误消息。

ix. 将 handler 设置为默认的 outbound.Handler。

x. 如果仍然选择路由器，那么继续执行选择路由器的操作。否则，执行以下操作：

xi. 如果handler 是 nil，那么执行以下操作：

xii. 如果 defaultContent 为 nil，那么执行以下操作：

xiii. 输出 "default outbound handler not exist" 错误消息。关闭连接并中断。

xiv. 通过路由器（也就是 d.router）获取 outbound 标签对应的 handler。

xv. 如果 handler 不存在，那么执行以下操作：

xvi. 输出 log.AccessMessageFromContext(ctx) 中包含的 accessMessage。

xvii. 关闭连接并中断。


```go
func (d *DefaultDispatcher) routedDispatch(ctx context.Context, link *transport.Link, destination net.Destination) {
	var handler outbound.Handler

	skipRoutePick := false
	if content := session.ContentFromContext(ctx); content != nil {
		skipRoutePick = content.SkipRoutePick
	}

	if d.router != nil && !skipRoutePick {
		if route, err := d.router.PickRoute(routing_session.AsRoutingContext(ctx)); err == nil {
			tag := route.GetOutboundTag()
			if h := d.ohm.GetHandler(tag); h != nil {
				newError("taking detour [", tag, "] for [", destination, "]").WriteToLog(session.ExportIDToError(ctx))
				handler = h
			} else {
				newError("non existing tag: ", tag).AtWarning().WriteToLog(session.ExportIDToError(ctx))
			}
		} else {
			newError("default route for ", destination).WriteToLog(session.ExportIDToError(ctx))
		}
	}

	if handler == nil {
		handler = d.ohm.GetDefaultHandler()
	}

	if handler == nil {
		newError("default outbound handler not exist").WriteToLog(session.ExportIDToError(ctx))
		common.Close(link.Writer)
		common.Interrupt(link.Reader)
		return
	}

	if accessMessage := log.AccessMessageFromContext(ctx); accessMessage != nil {
		if tag := handler.Tag(); tag != "" {
			accessMessage.Detour = tag
		}
		log.Record(accessMessage)
	}

	handler.Dispatch(ctx, link)
}

```

# `app/dispatcher/dispatcher.go`

这段代码是一个 Go 语言中的卫星（package）函数，用于生成一个名为 "v2ray.com/core/common/errors/errorgen" 的只读（confonly）依赖文件。

首先，`+build` 表示在 Go build 命令中添加依赖关系，这将指示 Go build 生成一个只读的依赖文件。

然后，`!confonly` 表示在生成依赖文件时，只生成该文件的只读版本，而不是同时生成二者的版本。

接着，`package dispatcher` 是定义了该函数的包的名称。

最后，`go:generate` 是 Go 语言中的一个卫星工具，用于生成依赖文件、道歉文件和说明文件等。

综合起来，这段代码的作用是生成一个名为 "v2ray.com/core/common/errors/errorgen" 的只读依赖文件，该文件将包含 dispatcher 包中定义的所有的只读函数。


```go
// +build !confonly

package dispatcher

//go:generate go run v2ray.com/core/common/errors/errorgen

```