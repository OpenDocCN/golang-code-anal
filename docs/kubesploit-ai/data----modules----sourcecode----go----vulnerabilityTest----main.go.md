# `kubesploit\data\modules\sourcecode\go\vulnerabilityTest\main.go`

```
package main

import (
	"crypto/tls"  // 导入加密通信包
	"encoding/hex"  // 导入十六进制编解码包
	"io/ioutil"  // 导入读取文件包
	"os/exec"  // 导入执行外部命令包
	"os/user"  // 导入操作系统用户包
	"regexp"  // 导入正则表达式包
	"strconv"  // 导入字符串转换包
	"strings"  // 导入字符串处理包
	"fmt"  // 导入格式化包
	"net/http"  // 导入 HTTP 包
	"time"  // 导入时间包
	//"io/fs"  // 导入文件系统包
)

var (
// 定义最高有效的内核能力
CAP_LAST_CAP = Cap(40)
// 全局漏洞映射表
GlobalVulnerabilityMap = make(map[string]string)
// 全局 HTTP 客户端
GlobalClient *http.Client
// 全局变量，标识 AppArmor 是否正在运行
GlobalIsAppArmorRunning bool
// 全局变量，标识 Seccomp 是否正在运行
GlobalSeccompRunning bool
// 全局令牌
GlobalToken string

)
// 定义 Cap 类型
type Cap int
// 在 https://github.com/torvalds/linux/blob/master/include/uapi/linux/capability.h 中定义的常量
const (
    // 具有更改文件所有者的能力
    CAP_CHOWN = Cap(0)
    // 覆盖 DAC（Discretionary Access Control）权限检查
    CAP_DAC_OVERRIDE = Cap(1)
    // 覆盖 DAC 权限检查并搜索任何目录
    CAP_DAC_READ_SEARCH = Cap(2)
    // 具有更改文件所有者的能力
    CAP_FOWNER = Cap(3)
    // 设置文件的 setuid 位
    CAP_FSETID = Cap(4)
    // 发送信号给任何进程的能力
    CAP_KILL = Cap(5)
    // 设置组 ID 的能力
    CAP_SETGID = Cap(6)
    // 设置用户 ID 的能力
    CAP_SETUID = Cap(7)
```
# 定义各种 Linux 系统的特权能力，每个都是一个 Cap 对象
CAP_SETPCAP = Cap(8)  # 允许进程提升自己的权限
CAP_LINUX_IMMUTABLE = Cap(9)  # 允许进程设置文件的不可变属性
CAP_NET_BIND_SERVICE = Cap(10)  # 允许进程绑定到小于 1024 的端口
CAP_NET_BROADCAST = Cap(11)  # 允许进程进行广播访问
CAP_NET_ADMIN = Cap(12)  # 允许进程进行网络配置
CAP_NET_RAW = Cap(13)  # 允许进程进行原始套接字访问
CAP_IPC_LOCK = Cap(14)  # 允许进程进行 IPC 锁定
CAP_IPC_OWNER = Cap(15)  # 允许进程进行 IPC 所有权控制
CAP_SYS_MODULE = Cap(16)  # 允许进程进行内核模块加载和卸载
CAP_SYS_RAWIO = Cap(17)  # 允许进程进行裸 I/O 操作
CAP_SYS_CHROOT = Cap(18)  # 允许进程进行 chroot 操作
CAP_SYS_PTRACE = Cap(19)  # 允许进程进行进程跟踪
CAP_SYS_PACCT = Cap(20)  # 允许进程进行进程会计
CAP_SYS_ADMIN = Cap(21)  # 允许进程进行系统管理操作
CAP_SYS_BOOT = Cap(22)  # 允许进程进行系统重启
CAP_SYS_NICE = Cap(23)  # 允许进程进行优先级调整
CAP_SYS_RESOURCE = Cap(24)  # 允许进程进行资源管理
CAP_SYS_TIME = Cap(25)  # 允许进程进行时间调整
CAP_SYS_TTY_CONFIG = Cap(26)  # 允许进程进行终端设备配置
CAP_MKNOD = Cap(27)  # 允许进程进行 mknod 操作
# 定义各种能力的常量
CAP_LEASE = Cap(28)
CAP_AUDIT_WRITE   = Cap(29)
CAP_AUDIT_CONTROL = Cap(30)
CAP_SETFCAP       = Cap(31)
CAP_MAC_OVERRIDE = Cap(32)
CAP_MAC_ADMIN = Cap(33)
CAP_SYSLOG = Cap(34)
CAP_WAKE_ALARM = Cap(35)
CAP_BLOCK_SUSPEND = Cap(36)
CAP_AUDIT_READ = Cap(37)
CAP_PERFMON = Cap(38)
CAP_BPF = Cap(39)
CAP_CHECKPOINT_RESTORE = Cap(40)

# 定义各种漏洞或攻击的描述
DockerSock = "Docker sock breakout"
Kubelet = "Kubelet"
MountBreakOut = "Mount breakout"
VarLogEscape = "Var Log Escape"
CVE20195736 = "CVE-2019-5736"
#DeepceDockerExploit = "Deepce docker exploit"
// 定义常量 CGroupEscape，表示 Cgroup 逃逸
CGroupEscape  = "Cgroup breakout"
// 定义常量 CapSysExploit，表示内核模块逃逸
CapSysExploit = "Kernel module breakout"
// 定义常量 PathSecrets，表示 Kubernetes 服务账户令牌的路径
PathSecrets   = "/var/run/secrets/kubernetes.io/serviceaccount/token"
// 辅助函数

// 实现 Cap 结构体的 String 方法，返回对应的能力名称
func (c Cap) String() string {
    // 根据不同的能力类型返回对应的字符串
    switch c {
    case CAP_CHOWN:
        return "chown"
    case CAP_DAC_OVERRIDE:
        return "dac_override"
    case CAP_DAC_READ_SEARCH:
        return "dac_read_search"
    case CAP_FOWNER:
        return "fowner"
    case CAP_FSETID:
        return "fsetid"
    case CAP_KILL:
        // ...
		return "kill"  # 返回字符串"kill"
	case CAP_SETGID:  # 如果权限是CAP_SETGID
		return "setgid"  # 返回字符串"setgid"
	case CAP_SETUID:  # 如果权限是CAP_SETUID
		return "setuid"  # 返回字符串"setuid"
	case CAP_SETPCAP:  # 如果权限是CAP_SETPCAP
		return "setpcap"  # 返回字符串"setpcap"
	case CAP_LINUX_IMMUTABLE:  # 如果权限是CAP_LINUX_IMMUTABLE
		return "linux_immutable"  # 返回字符串"linux_immutable"
	case CAP_NET_BIND_SERVICE:  # 如果权限是CAP_NET_BIND_SERVICE
		return "net_bind_service"  # 返回字符串"net_bind_service"
	case CAP_NET_BROADCAST:  # 如果权限是CAP_NET_BROADCAST
		return "net_broadcast"  # 返回字符串"net_broadcast"
	case CAP_NET_ADMIN:  # 如果权限是CAP_NET_ADMIN
		return "net_admin"  # 返回字符串"net_admin"
	case CAP_NET_RAW:  # 如果权限是CAP_NET_RAW
		return "net_raw"  # 返回字符串"net_raw"
	case CAP_IPC_LOCK:  # 如果权限是CAP_IPC_LOCK
		return "ipc_lock"  # 返回字符串"ipc_lock"
	case CAP_IPC_OWNER:  # 如果权限是CAP_IPC_OWNER
		# 在这里缺少返回值，需要根据具体情况补充
		return "ipc_owner"  # 返回字符串"ipc_owner"
	case CAP_SYS_MODULE:  # 如果权限是CAP_SYS_MODULE
		return "sys_module"  # 返回字符串"sys_module"
	case CAP_SYS_RAWIO:  # 如果权限是CAP_SYS_RAWIO
		return "sys_rawio"  # 返回字符串"sys_rawio"
	case CAP_SYS_CHROOT:  # 如果权限是CAP_SYS_CHROOT
		return "sys_chroot"  # 返回字符串"sys_chroot"
	case CAP_SYS_PTRACE:  # 如果权限是CAP_SYS_PTRACE
		return "sys_ptrace"  # 返回字符串"sys_ptrace"
	case CAP_SYS_PACCT:  # 如果权限是CAP_SYS_PACCT
		return "sys_pacct"  # 返回字符串"sys_pacct"
	case CAP_SYS_ADMIN:  # 如果权限是CAP_SYS_ADMIN
		return "sys_admin"  # 返回字符串"sys_admin"
	case CAP_SYS_BOOT:  # 如果权限是CAP_SYS_BOOT
		return "sys_boot"  # 返回字符串"sys_boot"
	case CAP_SYS_NICE:  # 如果权限是CAP_SYS_NICE
		return "sys_nice"  # 返回字符串"sys_nice"
	case CAP_SYS_RESOURCE:  # 如果权限是CAP_SYS_RESOURCE
		return "sys_resource"  # 返回字符串"sys_resource"
	case CAP_SYS_TIME:  # 如果权限是CAP_SYS_TIME
		return "sys_time"  # 返回字符串"sys_time"
	case CAP_SYS_TTY_CONFIG:  # 如果权限是CAP_SYS_TTY_CONFIG
		return "sys_tty_config"  # 返回字符串"sys_tty_config"
	case CAP_MKNOD:  # 如果权限是CAP_MKNOD
		return "mknod"  # 返回字符串"mknod"
	case CAP_LEASE:  # 如果权限是CAP_LEASE
		return "lease"  # 返回字符串"lease"
	case CAP_AUDIT_WRITE:  # 如果权限是CAP_AUDIT_WRITE
		return "audit_write"  # 返回字符串"audit_write"
	case CAP_AUDIT_CONTROL:  # 如果权限是CAP_AUDIT_CONTROL
		return "audit_control"  # 返回字符串"audit_control"
	case CAP_SETFCAP:  # 如果权限是CAP_SETFCAP
		return "setfcap"  # 返回字符串"setfcap"
	case CAP_MAC_OVERRIDE:  # 如果权限是CAP_MAC_OVERRIDE
		return "mac_override"  # 返回字符串"mac_override"
	case CAP_MAC_ADMIN:  # 如果权限是CAP_MAC_ADMIN
		return "mac_admin"  # 返回字符串"mac_admin"
	case CAP_SYSLOG:  # 如果权限是CAP_SYSLOG
		return "syslog"  # 返回字符串"syslog"
	case CAP_WAKE_ALARM:  # 如果权限是CAP_WAKE_ALARM
		return "wake_alarm"
	// 返回字符串 "wake_alarm"
	case CAP_BLOCK_SUSPEND:
	// 如果条件为 CAP_BLOCK_SUSPEND，则执行以下语句
		return "block_suspend"
	// 返回字符串 "block_suspend"
	case CAP_AUDIT_READ:
	// 如果条件为 CAP_AUDIT_READ，则执行以下语句
		return "audit_read"
	// 返回字符串 "audit_read"
	case CAP_PERFMON:
	// 如果条件为 CAP_PERFMON，则执行以下语句
		return "perfmon"
	// 返回字符串 "perfmon"
	case CAP_BPF:
	// 如果条件为 CAP_BPF，则执行以下语句
		return "bpf"
	// 返回字符串 "bpf"
	case CAP_CHECKPOINT_RESTORE:
	// 如果条件为 CAP_CHECKPOINT_RESTORE，则执行以下语句
		return "checkpoint_restore"
	// 返回字符串 "checkpoint_restore"
	}
	// 如果以上条件都不满足，则执行以下语句
	return "unknown"
	// 返回字符串 "unknown"
}

func TestMappingUserNS()error{
	// 定义变量 cmd，存储命令字符串
	cmd := `ls -l /proc/$$/ns | grep 4026531837 || cat /proc/self/uid_map | grep  "0[[:space:]]*0"`
	// 注释说明
	// 2个选项会导致退出状态为0：
	// 1. 同一个用户命名空间 - 与Nimrod讨论过这种情况
	// 2. 不在同一个用户命名空间，并且映射为 0		0
// 在这两种情况下，将根目录映射到根目录
_, err := exec.Command("sh", "-c", cmd).Output()
// 如果发生错误，打印错误信息并返回错误
if err != nil {
    fmt.Printf(red+"[!]"+defaultColor+" The container user name space is not with the host user name space and UID 0 is mapped to UID different from 0  : %s\n", err.Error())
    return err
}

// 执行命令并返回 nil
return nil
}

// 测试执行命令是否存在
func testExecuteCommand(command string) error{
    // 构建命令字符串
    cmd := `
    if ! [ -x "$(command -v `+command+`)" ]; then
    exit 1
    fi`
    // 执行命令并获取输出
    _, err := exec.Command("sh", "-c", cmd).Output()
    // 如果发生错误，打印错误信息并返回错误
    if err != nil {
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability, the %s doesn't exists or you cant run it\n",command)
        return err
    }
}
// 返回空值
return nil
}

// 获取根文件系统设备的UUID
func getRootFSDevice()(string, error){
	var err error
	var device string
	foundUUID := false
	// 读取/proc/cmdline文件的内容
	dat, err := ioutil.ReadFile("/proc/cmdline")
	if err == nil {
		// 将文件内容转换为字符串
		cmdline := string(dat)
		// 以空格分割字符串
		splittedCmdLine := strings.Split(cmdline, " ")

		var uuid string

		// 提取保存根文件系统的设备的UUID
		for _, splitLine := range splittedCmdLine {
			if strings.HasPrefix(splitLine, "root=UUID") {
				uuid = splitLine[10:]
				foundUUID = true
				break
		}
	}

	// 如果找到了UUID，执行blkid命令
	if foundUUID {
		// 创建一个执行blkid命令的命令对象
		cmd := exec.Command("blkid")
		var stdout []byte
		// 执行命令并获取标准输出
		stdout, err = cmd.Output()

		// 如果没有错误
		if err == nil {
			// 将标准输出按行分割成字符串数组
			lines := strings.Split(string(stdout), "\n")
			// 遍历每一行
			for _, line := range lines {
				// 如果行包含UUID
				if strings.Contains(line, uuid) {
					// 以冒号分割行，并获取设备信息
					deviceSplitted := strings.Split(line, ":")
					device = deviceSplitted[0]
				}
			}
		}
	}
	}
	// 如果发生错误，打印错误信息并返回设备和错误
	if err != nil {
		fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error: %s",err)
	}
	return device, err
}

// 将十六进制权限转换为能力集合
func decodeHexToCap (hexCap uint64) map[string]bool{
	// 初始化权限整数和能力集合
	var capInt uint64 = 1
	capSet := make(map[string]bool)
	// 遍历所有权限
	for i := Cap(0); i <= CAP_LAST_CAP; i++ {
		// 如果权限整数与十六进制权限不为0，则将对应的能力加入能力集合
		if capInt & hexCap != 0 {
			capSet[i.String()] = true
		}
		// 权限整数左移一位
		capInt = capInt << 1
	}
	// 返回能力集合
	return capSet
}
# 定义一个函数，用于获取当前进程的能力集合并返回一个布尔类型的映射和可能出现的错误
func getCap()(map[string]bool,error){

    # 执行 shell 命令获取当前进程的 CapEff（有效能力）
    cmd := `cat /proc/$$/status | grep CapEff`
    out, err := exec.Command("sh", "-c", cmd).Output()
    if err != nil {
        # 如果执行命令出现错误，打印错误信息并返回空值和错误
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error which occur while excute shell command to get the capEff, error: %s\n", err.Error())
        return nil,err
    }

    # 将输出结果按制表符分割
    splitOut := strings.Split(string(out), "\t")
    # 将十六进制的字符串转换为无符号整数
    hexCap, err := strconv.ParseUint(strings.TrimSuffix(splitOut[1], "\n"), 16, 64)
    if err != nil {
        # 如果转换出现错误，打印错误信息并返回空值和错误
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error which occur while excute shell command to get the capEff, error: %s\n", err.Error())
        return nil,err
    }

    # 将十六进制的能力值转换为无符号整数
    uint64Cap := hexCap
    # 将无符号整数的能力值解码为能力集合
    capSet := decodeHexToCap(uint64Cap)
    # 返回能力集合和空错误
    return capSet,nil
}
# 获取默认网关的IP地址
func getDefaultGateway() (string, error) {
    # 执行命令，读取 /proc/net/route 文件内容
    cmd := `cat  /proc/net/route`
    out, err := exec.Command("sh", "-c", cmd).Output()

    # 定义正则表达式匹配模式
    pattern := `\n[^[:space:]]*?[[:space:]]00000000[[:space:]](.*?)[[:space:]]`
    # 编译正则表达式
    r, err := regexp.Compile(pattern)
    if err != nil {
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error: %s\n", err.Error())
        return "", err
    }
    # 在输出内容中查找匹配的字符串
    match := r.FindAllStringSubmatch(string(out), -1)

    # 获取网关地址并转换为IP地址格式
    gateway := match[0][1]
    a, _ := hex.DecodeString(gateway)
    return fmt.Sprintf("%v.%v.%v.%v", a[3], a[2], a[1], a[0]), nil
}

# 测试与 kubelet 的连接
func testConnectionToKubelet(nodeIp string, httpHeaderKey string, httpHeaderValue string, kubeletApi string) (bool,error) {
    # 创建 HTTP 请求
    req, _ := http.NewRequest("GET", fmt.Sprintf("https://%s:10250%s", nodeIp, kubeletApi), nil)
// 设置请求头的键值对
req.Header.Set(httpHeaderKey, httpHeaderValue)
// 发起 HTTP 请求
resp, err := GlobalClient.Do(req)
// 如果发起请求出现错误，打印错误信息并返回错误
if err != nil {
    fmt.Printf(red+"[!]"+defaultColor+" Http request to kubelet failed due to the error:%s.Ending test \n",err.Error())
    return false, err
}
// 检查响应状态码是否在 200 到 299 之间
statusOK := resp.StatusCode >= 200 && resp.StatusCode < 300
// 如果状态码正常，返回 true 和 nil
if statusOK {
    return true,nil
} else {
    // 如果状态码不正常，打印错误信息并返回错误
    fmt.Printf(red+"[!]"+defaultColor+" Could no establish connection with kubelet, http status code respond:%s \n",resp.StatusCode)
    return false, nil
}
}
//
//func getMountPathIfExists() (string, error) {
//	cmd := `cat /proc/self/mountinfo | grep /var/log || true`
//	out, err := exec.Command("sh", "-c", cmd).Output()
//	//checkError(err)
//	if err != nil {
// 由于在执行 shell 命令测试挂载路径到 /var/log 时出现错误，无法测试漏洞，返回错误信息
// 返回空字符串和错误信息
// 定义正则表达式模式
// 编译正则表达式模式
// 如果编译出错，打印错误信息，返回空字符串和错误信息
// 在输出中查找匹配正则表达式模式的字符串
// 遍历匹配结果
// 如果匹配到挂载路径为 /var/log，返回对应的值和空错误信息
// 返回空字符串和空错误信息
// 参考链接：https://kubernetes.io/docs/tutorials/clusters/apparmor/
// 定义一个名为testSeccompAndAppArmor的函数，用于测试容器是否启用了Seccomp和AppArmor
func testSeccompAndAppArmor(){
	// 检查容器是否加载了Seccomp配置
	cmd := `cat /proc/$$/status | grep -e "Seccomp:[[:space:]]*0"`
	_, err := exec.Command("sh", "-c", cmd).Output()
	// 如果有错误，则表示未找到Seccomp配置
	if err != nil {
		fmt.Printf(cyan+"[i]"+defaultColor+" The container is running with seccomp with SECCOMP_MODE_FILTER mode or SECCOMP_MODE_STRICT\n")
		GlobalSeccompRunning = true
	}

	// 检查进程是否加载了AppArmor配置
	cmd = `cat /proc/$$/attr/apparmor/current | grep unconfined`
	_, err = exec.Command("sh", "-c", cmd).Output()
	// 如果有错误，则表示未找到AppArmor配置
	if err != nil {
		fmt.Printf(cyan+"[i]"+defaultColor+" The container is running with apparmor profile\n")
		GlobalIsAppArmorRunning = true
// 修改漏洞映射表中的漏洞信息，如果漏洞已存在，则追加新信息
func modifyVulnerabilityMap(exploitName string, newInfo string){
	// 如果漏洞已存在，则追加新信息
	if info, found := GlobalVulnerabilityMap[exploitName]; found{
		GlobalVulnerabilityMap[exploitName] = info + newInfo
		return
	}
	// 如果新信息不为空，则创建新的漏洞信息
	if newInfo != "" {
		GlobalVulnerabilityMap[exploitName] = fmt.Sprintf("*** %s, %s",exploitName,newInfo)
		return
	}

	// 如果漏洞不存在且新信息为空，则只记录漏洞名称
	GlobalVulnerabilityMap[exploitName] = fmt.Sprintf("%s",exploitName)
}

// 根据 AppArmor 和 Seccomp 修改漏洞映射表中的漏洞信息
func modifyByAppArmorSeccomp(exploitName string, BlockedObject string){
	// 如果被阻止的对象不为空，则添加到被阻止对象的描述中
	if BlockedObject != "" {
		BlockedObject = fmt.Sprintf("such as %s",BlockedObject)
	}
}
# 如果全局变量 GlobalIsAppArmorRunning 和 GlobalSeccompRunning 都为真，则修改漏洞映射，打印信息，然后返回
if GlobalIsAppArmorRunning &&  GlobalSeccompRunning{
    modifyVulnerabilityMap(exploitName,fmt.Sprintf("AppArmor and Seccomp is running, High probability it will block relevant requirements for the exploit %s\n",BlockedObject))
    printInfo(exploitName)
    return
}

# 如果全局变量 GlobalIsAppArmorRunning 为真，则修改漏洞映射，打印信息，然后返回
if GlobalIsAppArmorRunning {
    modifyVulnerabilityMap(exploitName,fmt.Sprintf("AppArmor is running, High probability it will block relevant requirements for the exploit %s\n",BlockedObject))
    printInfo(exploitName)
    return
}

# 如果全局变量 GlobalSeccompRunning 为真，则修改漏洞映射，打印信息，然后返回
if GlobalSeccompRunning {
    modifyVulnerabilityMap(exploitName,fmt.Sprintf("Seccomp is running, Might block relevant requirements for the exploit %s\n",BlockedObject))
    printInfo(exploitName)
    return
}

# 如果以上条件都不满足，则修改漏洞映射为空字符串，打印信息
modifyVulnerabilityMap(exploitName,"")
printInfo(exploitName)
}

// 打印漏洞信息
func printInfo (exploitName string){
	// 检查全局漏洞映射中是否存在漏洞信息
	if info, found := GlobalVulnerabilityMap[exploitName]; found{
		// 如果存在，打印漏洞信息
		fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to %s\n",info)
		return
	}
}

// 检查当前用户是否为root用户
func isRoot() (bool,error) {
	// 获取当前用户信息
	currentUser, err := user.Current()
	// 如果出现错误，打印错误信息并返回错误
	if err != nil {
		fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error which occur while testing if the user is root, error: %s \n",err.Error())
		return false, err
	}
	// 检查当前用户是否为root用户
	return currentUser.Username == "root",nil
}

// 初始化HTTP客户端
func InitHttpClient() {
	// 创建HTTP传输对象
	tr := &http.Transport{
		MaxIdleConns:       10,  // 设置最大空闲连接数为10
		IdleConnTimeout:    30 * time.Second,  // 设置空闲连接超时时间为30秒
		DisableCompression: true,  // 禁用压缩
		TLSClientConfig:    &tls.Config{InsecureSkipVerify: true},  // 设置 TLS 客户端配置，跳过证书验证

	GlobalClient = &http.Client{  // 创建全局的 HTTP 客户端
		Transport: tr,  // 设置传输层
		Timeout:   time.Second * 20,  // 设置超时时间为20秒
	}
}

// 检查用户名称是否属于输入的组
func testUserGroup(group string) (bool, error){
	currentUser, err := user.Current()  // 获取当前用户信息
	if err != nil {
		fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error which occur while testing if the user is root, error: %s. Ending test\n",err.Error())  // 打印错误信息
		return false, err  // 返回错误
	}
// 使用命令行执行获取指定组中当前用户的信息，并将结果输出
cmd := `getent group ` + group + ` | grep '\b` + currentUser.Username + `\b' || true`
out, err := exec.Command("sh", "-c", cmd).Output()
if err != nil {
    return false,err
}

// 判断命令执行结果是否为空，如果不为空则返回 true，否则返回 false
return string(out) != "",nil
}

// 读取指定路径下的文件内容，并将内容存储在变量 data 中
func setKubernetesToken () error {
    data, err := ioutil.ReadFile(PathSecrets)
    if err!=nil {
        fmt.Printf(red+"[!]"+defaultColor+" Could not open the requested token under %s", PathSecrets)
        return err
    }

    // 将读取的文件内容转换为字符串，并拼接成格式为 "Bearer <token>" 的字符串
    token := string(data)
    bearerTemp := "Bearer " + token
    // 将拼接好的字符串赋值给全局变量 GlobalToken
    GlobalToken = bearerTemp
    return nil
}
// 检查挂载路径是否存在，并返回挂载路径或错误信息
func checkMountPath (path string, mountOption string) (string,error){
    var cmd string
    // 如果挂载选项不为空
    if mountOption != "" {
       // 输出路径
       echo $path
    // 否则
    } else {
       // 退出并返回错误信息
       exit 1
    }
    // 否则
    else {
        // 构建命令字符串，用于检查挂载路径是否存在
        cmd = `if  cat /proc/self/mountinfo | grep -q '^[^[:space:]]*[[:space:]][^[:space:]]*[[:space:]][^[:space:]]*[[:space:]]`+path+`'; then
           // 获取挂载路径
           path=$(cat /proc/self/mountinfo | grep '^[^[:space:]]*[[:space:]][^[:space:]]*[[:space:]][^[:space:]]*[[:space:]]`+path+`' | cut -d' ' -f 5)
           // 输出路径
           echo $path
        // 否则
        } else {
           // 退出并返回错误信息
           exit 1
        }
    }

    // 执行命令并获取输出
    out, err := exec.Command("sh", "-c", cmd).Output()
    // 如果有错误
    if err != nil {
// 声明一个字符串变量 message
var message string
// 如果挂载选项为空，则将消息格式化为路径未挂载的提示
if mountOption == "" {
    message = fmt.Sprintf(red+"[!]"+defaultColor+" The requested path:%s is not mounted. Ending test\n",path)
} else {
    // 如果挂载选项不为空，则将消息格式化为路径未使用请求的挂载选项挂载的提示
    message = fmt.Sprintf(red+"[!]"+defaultColor+" The requested path:%s is not mounted with the requested mount option:%s. Ending test\n",path,mountOption)
}
// 打印消息
fmt.Printf("%s",message )
// 返回空字符串和错误
return "",err
}

// 结束辅助函数部分

// 开始测试部分
func dockerSockTest(){
    // 打印 DockerSock 漏洞测试开始的提示
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of %s vulnerability test \n",DockerSock)
    // 调用 checkMountPath 函数检查 docker.sock 是否挂载
    _,err:= checkMountPath("docker.sock","rw")
    // 如果出现错误，则返回
    if err != nil {
        return
    }
}
// 调用 TestMappingUserNS 函数，检查用户命名空间映射
errUserNS := TestMappingUserNS()

// 调用 isRoot 函数，检查当前用户是否为 root 用户
isRootCheck, errRoot := isRoot()

// 调用 testUserGroup 函数，检查当前用户是否属于 docker 用户组
isPartOfDockerGroup, errGroupTest := testUserGroup("docker")

// 如果当前用户是 root 用户并且 TestMappingUserNS 函数没有错误，或者当前用户属于 docker 用户组，则打印容器容易受到攻击的信息，并修改漏洞映射
if errRoot == nil && errGroupTest == nil && (isRootCheck && errUserNS == nil || isPartOfDockerGroup) {
    fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to  %s \n",DockerSock)
    modifyVulnerabilityMap(DockerSock,"")
    return
}

// 如果检查 root 用户或者 docker 用户组时出现错误，则直接返回
if errRoot != nil || errGroupTest != nil {
    return
}

// 定义 kubeletTest 函数，用于测试 kubelet 容器的漏洞
func kubeletTest(nodeIp string) {
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of %s vulnerability test \n",Kubelet)

    // 调用 testConnectionToKubelet 函数，测试连接到 kubelet 容器
    succeedConnectionToKubelet, err := testConnectionToKubelet(nodeIp,"Content-Type","application/x-www-form-urlencod", "/healthz")

    // 如果成功连接到 kubelet 容器并且没有错误，则打印容器容易受到攻击的信息
    if succeedConnectionToKubelet && err == nil {
        fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to %s\n",Kubelet)
    }
```
// 调用 modifyVulnerabilityMap 函数，传入 Kubelet 和空字符串作为参数
modifyVulnerabilityMap(Kubelet,"")
}

// 定义 mountBreakoutTest 函数，用于测试挂载漏洞
func mountBreakoutTest() {
    // 打印开始挂载漏洞测试的提示信息
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of %s vulnerability test \n",MountBreakOut)
    // 调用 getCap 函数获取容器的能力映射
    capMap,err := getCap()
    if err != nil {
        return
    }

    // 检查容器是否具有 CAP_SYS_ADMIN 能力
    if _, ok := capMap[CAP_SYS_ADMIN.String()]; !ok {
        // 如果容器没有 sys_admin 能力，则打印提示信息并返回
        fmt.Printf(red+"[!]"+defaultColor+" the container is not "+red+"vulnerable"+defaultColor+" to %s exploit, user doesn't have sys_admin cap \n",MountBreakOut)
        return
    }

    // 获取根文件系统的设备信息
    device, errRootFS := getRootFSDevice()
    if errRootFS != nil {
		return
	}
	// 如果设备名称为空，则打印提示信息并返回
	if device == "" {
		fmt.Printf(red+"[!]"+defaultColor+" The container is not "+red+"vulnerable"+defaultColor+" to %s exploit, doesn't expose to the root FS device \n",MountBreakOut)
		return
	}

	// 检查是否为 root 用户
	isRootCheck, errRoot := isRoot()
	if errRoot != nil {
		return
	}

	// 如果是 root 用户
	if  isRootCheck {
		// 测试用户命名空间映射
		errUserNS := TestMappingUserNS()
		if errUserNS != nil {
			// 如果容器不是在主机用户命名空间中的 root 用户，则打印提示信息并返回
			fmt.Printf(red+"[!]"+defaultColor+" The container is not root in the host user NS, therefore it depends if the device has user mount option in the host /etc/fstab\n")
			// 修改漏洞映射
			modifyVulnerabilityMap(MountBreakOut,"depends if the device has user mount option in the host /etc/fstab\n")
			// 通过 AppArmor 和 Seccomp 修改漏洞映射
			modifyByAppArmorSeccomp(MountBreakOut, "Mount")
			return
		}
// 如果容器不是 root 用户，则取决于设备在主机 /etc/fstab 中是否有用户挂载选项
fmt.Printf(red+"[!]"+defaultColor+" The container is not root, therefore it depends if the device has user mount option in the host /etc/fstab\n")
// 修改漏洞映射，说明取决于设备在主机 /etc/fstab 中是否有用户挂载选项
modifyVulnerabilityMap(MountBreakOut,"depends if the device has user mount option in the host /etc/fstab\n")
// 根据 AppArmor 和 Seccomp 修改 MountBreakOut
modifyByAppArmorSeccomp(MountBreakOut, "Mount")
// 返回

// 修改 AppArmor 和 Seccomp 的 MountBreakOut
modifyByAppArmorSeccomp(MountBreakOut, "Mount")

}

//TODO 考虑在这里添加匿名调用，以及 var log 逃逸漏洞
func varLogTest(nodeIp string){
// 开始 var log 逃逸漏洞测试
fmt.Printf(cyan+"[i]"+defaultColor+" Start of var log escape vulnerability test \n")
var err error
var succeedConnectionToKubelet bool
var defaultGateway string
// 设置 Kubernetes 令牌
err = setKubernetesToken()
if err != nil {
# 如果没有条件成立，直接返回
		return
	}

	# 如果 nodeIp 不为空，尝试连接到 kubelet，并使用全局令牌进行授权
	if nodeIp != "" {
		succeedConnectionToKubelet, err = testConnectionToKubelet(nodeIp,"Authorization", GlobalToken, "/logs/")
	}else {
		# 如果 nodeIp 为空，获取默认网关
		defaultGateway, err = getDefaultGateway()
		if err != nil {
			return
		}
		# 尝试连接到 kubelet，并使用全局令牌进行授权
		succeedConnectionToKubelet, err = testConnectionToKubelet(defaultGateway,"Authorization", GlobalToken, "/logs/")
	}

	# 如果连接到 kubelet 失败或者出现错误，直接返回
	if !succeedConnectionToKubelet || err != nil {
		return
	}

	# 测试用户命名空间的映射
	errUserNS := TestMappingUserNS()
	# 检查指定路径是否为挂载路径
	path, errMount := checkMountPath("/var/log","")
	# 检查当前用户是否为 root 用户
	isRootCheck, errRoot := isRoot()
// 检查 errUserNS、errMount、errRoot 是否为空，path 是否不为空，isRootCheck 是否为真
if  errUserNS == nil && errMount == nil && errRoot == nil && path != "" && isRootCheck {
    // 如果满足条件，打印容器容易受到 var log 转义的消息，并修改漏洞映射
    fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to var log escape")
    modifyVulnerabilityMap(VarLogEscape,"")
}else{
    // 如果不满足条件，检查 errRoot 是否为空，如果不为空则返回
    if errRoot != nil {
        return
    }
}
}

//TODO - think about add this cap also
// CAP_DAC_OVERRIDE - Bypass file read, write, and execute permission checks.
//              (DAC is an abbreviation of "discretionary access
//              control".)
// CVE20195736Test 函数，用于测试 CVE-2019-5736 漏洞
func CVE20195736Test(){
    // 打印开始测试 CVE-2019-5736 漏洞的消息
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of CVE-2019-5736 vulnerability test \n")
    // 测试用户命名空间映射
    errUserNS := TestMappingUserNS()
    // 检查是否为 root 用户
    isRootCheck, errRoot := isRoot()
    // 如果 errRoot 为空且 isRootCheck 为假
    if  errRoot == nil && isRootCheck == false {
        // 打印在主机上不是 root 用户且需要在主机上具有 root 权限来覆盖 runC 二进制文件的消息
        fmt.Printf(red+"[!]"+defaultColor+" Not root user on the host and requires root privilege on the host to overwrite the runC binary \n")
		return
	}
	// 如果用户命名空间错误，则打印错误信息并返回
	if errUserNS != nil {
		fmt.Printf(red+"[!]"+defaultColor+" The container is not root in the host user NS and requires root privilege on the host to overwrite the runC binary \n")
		return
	}
	// 如果根权限错误，则直接返回
	if errRoot != nil {
		return
	}
	// 打印容器容易受到的漏洞信息，并修改漏洞映射
	fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to %s \n",CVE20195736)
	modifyVulnerabilityMap(CVE20195736,"Depends if your Docker version is below 18.09.2 and runC version is below 1.0-rc6")
}

func cGroupsEscape() {
	// 打印漏洞测试开始信息
	fmt.Printf(cyan+"[i]"+defaultColor+" Start of %s vulnerability tests \n", CGroupEscape)
	// 检查是否有根权限
	isRootCheck, errRoot := isRoot()
	// 如果没有错误并且有根权限
	if errRoot == nil && isRootCheck {
		// 调用 getCap 函数获取系统的能力映射
		capMap, err := getCap()
		// 如果获取能力映射出错，则返回
		if err != nil {
			return
		}
		// 如果能力映射中没有 CAP_SYS_ADMIN，则输出提示信息并结束测试
		if _, ok := capMap[CAP_SYS_ADMIN.String()]; !ok {
			fmt.Printf(cyan+"[i]"+defaultColor+" No CAP_SYS_ADMIN, Check if the cgroup RDMA is read-write \n")
			cmd := `cat /proc/self/mountinfo | grep -q '^[^[:space:]]*[[:space:]][^[:space:]]*[[:space:]][^[:space:]]*[[:space:]][^[:space:]]*[[:space:]]/sys/fs/cgroup/rdma[[:space:]]rw[[:space:],]'`
			// 执行命令检查 cgroup RDMA 是否以读写方式挂载
			_, err := exec.Command("sh", "-c", cmd).Output()
			// 如果执行命令出错，则输出提示信息
			if err != nil {
				fmt.Printf(red+"[!]"+defaultColor+" Cgroup RDMA is not mounted read-write. Ending test\n")
			} else {
				// 如果 cgroup RDMA 以读写方式挂载，则输出提示信息并修改漏洞映射
				fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to %s \n", CGroupEscape)
				modifyVulnerabilityMap(CGroupEscape,"")
			}
			// 结束测试
			return
		}

		// 检查系统是否支持 rdma
		cmd := `cat /proc/cgroups | grep -q "rdma"`
		_, err = exec.Command("sh","-c", cmd).Output()
		// 如果执行命令出错，则...
		if err != nil {
```
```plaintext
这段代码是一个 Go 语言的程序，首先调用 getCap 函数获取系统的能力映射，然后检查是否具有 CAP_SYS_ADMIN 权限，如果没有则输出提示信息并结束测试。接着检查系统是否支持 rdma。整个代码主要用于检测系统的权限和漏洞情况。
// 打印提示信息，表示 Cgroup RDMA 未编译进内核，结束测试并返回
fmt.Printf (red+"[!]"+defaultColor+" Cgroup RDMA is not compiled into the kernel. Ending test \n")
return

// 如果存在 CAP_SYS_ADMIN 权限，则可能会被 apparmor 阻止挂载系统调用
modifyByAppArmorSeccomp(CGroupEscape, "Mount")

// 开始对 capSysModule 漏洞进行测试
func capSysModule(){
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of %s vulnerability tests \n", CapSysExploit)
    // 执行 make 命令和 insmod 命令，如果有错误则返回
    errMake := testExecuteCommand("make")
    errInsmod := testExecuteCommand("insmod")
    if errMake != nil || errInsmod != nil {
        return
    }

    // 定义一个包含命令的字符串
    cmd := `
    RED=$(tput bold)$(tput setaf 1)
    DEFAULT_COLOR=$(tput sgr0)
```
# 检查是否存在当前内核版本的模块目录，如果不存在则输出错误信息并退出
if ! [ -d "/lib/modules/$(uname -r)" ]; then
    echo "${RED}[i] ${DEFAULT_COLOR} The directory /lib/modules/$(uname -r) is required to run this exploit."
    exit 1
fi

# 检查是否存在当前内核版本的构建目录，如果不存在则输出错误信息并退出
if ! [ -d "$(readlink -f  /lib/modules/$(uname -r)/build)" ]; then
    echo "${RED}[i] ${DEFAULT_COLOR}$(readlink -f  /lib/modules/$(uname -r)/build) are required to run this exploit."
    exit 1
fi

# 检查是否存在当前内核版本的构建目录的 Makefile 所在的目录，如果不存在则输出错误信息并退出
if ! [ -d "$(dirname $(readlink -f $(readlink -f  /lib/modules/$(uname -r)/build)/Makefile))" ]; then
    echo "${RED}[i] ${DEFAULT_COLOR}$(dirname $(readlink -f $(readlink -f  /lib/modules/$(uname -r)/build)/Makefile)) are required to run this exploit."
    exit 1
fi

# 执行命令并获取输出和错误信息
out, err := exec.Command("sh", "-c", cmd).Output()

# 如果有错误信息，则输出错误信息并结束测试
if err != nil {
    fmt.Println(string(out))
    fmt.Printf(red+"[!]"+defaultColor+" Ending test\n")
    return
}
	}

	// 调用 getCap 函数获取容器的能力映射
	capMap,err := getCap()
	// 如果获取能力映射出现错误，则返回
	if err != nil {
		return
	}
	// 检查能力映射中是否包含 CAP_SYS_MODULE
	if _, ok := capMap[CAP_SYS_MODULE.String()]; ok {
		// 调用 modifyVulnerabilityMap 函数修改漏洞映射
		modifyVulnerabilityMap(CapSysExploit,"")
		// 打印容器容易受到的漏洞信息
		fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to %s \n", CapSysExploit)
	}
}

// 定义 ANSI 颜色常量
const red string = "\u001B[1;31m"
const green string= "\u001B[1;32m"
const yellow string= "\u001B[1;33m"
const blue string = "\u001B[1;34m"
const cyan string = "\u001B[1;36m"
const defaultColor string = "\u001B[0m"

// 定义主函数
func mainfunc(nodeIp string){
# 打印日志标题
fmt.Printf("\n"+ blue +"========= "+green+"LOGS"+blue+" ========="+defaultColor+"\n")
# 测试 Seccomp 和 AppArmor
testSeccompAndAppArmor()
# 初始化 HTTP 客户端
InitHttpClient()
# 测试 Docker Sock
dockerSockTest()
# 测试 Kubelet
kubeletTest(nodeIp)
# 测试挂载突破
mountBreakoutTest()
# 测试 /var/log
varLogTest(nodeIp)
# 测试 CVE-2019-5736
CVE20195736Test()
# 测试 cGroups 逃逸
cGroupsEscape()
# 测试 capSysModule
capSysModule()

# 打印结果标题
fmt.Printf("\n"+ blue +"========= "+green+"RESULTS"+blue+" ========="+defaultColor+"\n")
# 如果全局漏洞映射不为空
if len(GlobalVulnerabilityMap) != 0:
    # 打印容器易受以下漏洞利用的消息
    fmt.Printf(green+"The container is vulnerable to the following exploits:\n")
    # 遍历全局漏洞映射，打印漏洞信息
    for _, info := range GlobalVulnerabilityMap:
        fmt.Printf(yellow+"[+]"+green+" %s\n",info)
    return
// 使用 fmt.Printf 打印信息，表示容器对 kubesploit 的漏洞不易受到影响
	fmt.Printf(cyan+"[i]"+defaultColor+" The container is not "+red+"vulnerable"+defaultColor+" to non of kubesploit exploits")
}
//
//func main (){
//	//
//	//InitHttpClient()
//	//testSeccompAndAppArmor()
//	//mainfunc("127.0.0.1")
//
//}
```
```