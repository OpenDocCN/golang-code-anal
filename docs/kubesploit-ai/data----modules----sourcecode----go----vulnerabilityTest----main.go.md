# `kubesploit\data\modules\sourcecode\go\vulnerabilityTest\main.go`

```
package main

import (
    "crypto/tls"  // 导入加密通信包
    "encoding/hex"  // 导入十六进制编解码包
    "io/ioutil"  // 导入输入输出工具包
    "os/exec"  // 导入执行外部命令包
    "os/user"  // 导入操作系统用户包
    "regexp"  // 导入正则表达式包
    "strconv"  // 导入字符串转换包
    "strings"  // 导入字符串处理包
    "fmt"  // 导入格式化包
    "net/http"  // 导入网络通信包
    "time"  // 导入时间包
)

var (
    CAP_LAST_CAP            = Cap(40)  // 运行内核的最高有效能力
    GlobalVulnerabilityMap  = make(map[string]string)  // 全局漏洞映射
    GlobalClient            *http.Client  // 全局 HTTP 客户端
    GlobalIsAppArmorRunning bool  // 全局 AppArmor 是否运行
    GlobalSeccompRunning    bool  // 全局 Seccomp 是否运行
    GlobalToken string  // 全局令牌
)

type Cap int  // 定义能力类型

const (
    CAP_CHOWN = Cap(0)  // 更改文件所有者的能力
    CAP_DAC_OVERRIDE = Cap(1)  // 覆盖 DAC 的能力
    CAP_DAC_READ_SEARCH = Cap(2)  // 读取和搜索 DAC 的能力
    // ... 其他能力的定义
    CAP_BPF = Cap(39)  // BPF 的能力
    CAP_CHECKPOINT_RESTORE = Cap(40)  // 检查点恢复的能力

    DockerSock = "Docker sock breakout"  // Docker sock 逃逸
    Kubelet = "Kubelet"  // Kubelet
    MountBreakOut = "Mount breakout"  // 挂载逃逸
    VarLogEscape = "Var Log Escape"  // Var Log 逃逸
    CVE20195736 = "CVE-2019-5736"  // CVE-2019-5736
    //DeepceDockerExploit = "Deepce docker exploit"
)
    # 定义变量CGroupEscape，用于表示Cgroup逃逸漏洞
    CGroupEscape  = "Cgroup breakout"
    # 定义变量CapSysExploit，用于表示内核模块漏洞
    CapSysExploit = "Kernel module breakout"
    # 定义变量PathSecrets，用于表示Kubernetes服务账户令牌的存储路径
    PathSecrets   = "/var/run/secrets/kubernetes.io/serviceaccount/token"
// 定义 Cap 结构体的 String 方法，返回权限名称
func (c Cap) String() string {
    // 根据权限值返回对应的权限名称
    switch c {
    case CAP_CHOWN:
        return "chown"
    case CAP_DAC_OVERRIDE:
        return "dac_override"
    // ... 其他权限的处理
    case CAP_BLOCK_SUSPEND:
        return "block_suspend"
    }
}
    # 如果权限是 CAP_AUDIT_READ，则返回字符串 "audit_read"
    case CAP_AUDIT_READ:
        return "audit_read"
    # 如果权限是 CAP_PERFMON，则返回字符串 "perfmon"
    case CAP_PERFMON:
        return "perfmon"
    # 如果权限是 CAP_BPF，则返回字符串 "bpf"
    case CAP_BPF:
        return "bpf"
    # 如果权限是 CAP_CHECKPOINT_RESTORE，则返回字符串 "checkpoint_restore"
    case CAP_CHECKPOINT_RESTORE:
        return "checkpoint_restore"
    # 如果权限不是以上任何一种，则返回字符串 "unknown"
    }
    return "unknown"
}

func TestMappingUserNS()error{
    cmd := `ls -l /proc/$$/ns | grep 4026531837 || cat /proc/self/uid_map | grep  "0[[:space:]]*0"`
    // 检查用户命名空间映射情况的命令
    // 两种情况会导致退出状态为 0：
    // 1. 相同的用户命名空间 - 与 Nimrod 确认了这种情况
    // 2. 不在相同的用户命名空间，并且映射为 0        0
    // 在这两种情况下，root 用户映射为 root
    _, err := exec.Command("sh", "-c", cmd).Output()
    if err != nil {
        fmt.Printf(red+"[!]"+defaultColor+" The container user name space is not with the host user name space and UID 0 is mapped to UID different from 0  : %s\n", err.Error())
        return err
    }

    return nil
}

func testExecuteCommand(command string) error{
    cmd := `
    if ! [ -x "$(command -v `+command+`)" ]; then
    exit 1
    fi`
    // 执行命令是否存在的测试
    _, err := exec.Command("sh", "-c", cmd).Output()
    if err != nil {
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability, the %s doesn't exists or you cant run it\n",command)
        return err
    }
    return nil
}

func getRootFSDevice()(string, error){
    var err error
    var device string
    foundUUID := false
    // 读取 /proc/cmdline 文件的内容
    dat, err := ioutil.ReadFile("/proc/cmdline")
    // 如果没有错误发生
    if err == nil {
        // 将字节数组转换为字符串
        cmdline := string(dat)
        // 使用空格分割命令行参数
        splittedCmdLine := strings.Split(cmdline, " ")

        var uuid string

        // 提取持有根文件系统的设备的 UUID
        for _, splitLine := range splittedCmdLine {
            if strings.HasPrefix(splitLine, "root=UUID") {
                uuid = splitLine[10:]
                foundUUID = true
                break
            }
        }

        // 如果找到了 UUID
        if foundUUID {
            // 执行命令 "blkid"
            cmd := exec.Command("blkid")
            var stdout []byte
            // 获取命令执行的标准输出
            stdout, err = cmd.Output()

            // 如果没有错误发生
            if err == nil {
                // 将标准输出转换为字符串并按换行符分割
                lines := strings.Split(string(stdout), "\n")
                // 遍历每一行
                for _, line := range lines {
                    // 如果包含 UUID
                    if strings.Contains(line, uuid) {
                        // 使用冒号分割行并获取设备信息
                        deviceSplitted := strings.Split(line, ":")
                        device = deviceSplitted[0]
                    }
                }
            }

        }
    }
    // 如果有错误发生
    if err != nil {
        // 打印错误信息
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error: %s",err)
    }
    // 返回设备信息和错误
    return device, err
# 将十六进制权限转换为对应的能力集合
func decodeHexToCap (hexCap uint64) map[string]bool{
    # 初始化能力值为1
    var capInt uint64 = 1
    # 创建空的能力集合
    capSet := make(map[string]bool)
    # 遍历所有能力
    for i := Cap(0); i <= CAP_LAST_CAP; i++ {
        # 检查能力是否在十六进制权限中
        if capInt & hexCap != 0 {
            # 将能力添加到能力集合中
            capSet[i.String()] = true
        }
        # 左移一位，检查下一个能力
        capInt = capInt << 1
    }
    # 返回能力集合
    return capSet
}

# 获取当前进程的有效能力
func getCap()(map[string]bool,error){
    # 执行 shell 命令获取 CapEff
    cmd := `cat /proc/$$/status | grep CapEff`
    out, err := exec.Command("sh", "-c", cmd).Output()
    # 检查执行命令是否出错
    if err != nil {
        # 输出错误信息
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error which occur while excute shell command to get the capEff, error: %s\n", err.Error())
        # 返回空和错误信息
        return nil,err
    }
    # 分割输出结果
    splitOut := strings.Split(string(out), "\t")
    # 将十六进制字符串转换为 uint64 类型
    hexCap, err := strconv.ParseUint(strings.TrimSuffix(splitOut[1], "\n"), 16, 64)
    # 检查转换是否出错
    if err != nil {
        # 输出错误信息
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error which occur while excute shell command to get the capEff, error: %s\n", err.Error())
        # 返回空和错误信息
        return nil,err
    }
    # 将 uint64 类型的十六进制权限转换为能力集合
    uint64Cap := hexCap
    capSet := decodeHexToCap(uint64Cap)
    # 返回能力集合和空错误信息
    return capSet,nil
}

# 获取默认网关
func getDefaultGateway() (string, error) {
    # 执行 shell 命令获取路由信息
    cmd := `cat  /proc/net/route`
    out, err := exec.Command("sh", "-c", cmd).Output()
    # 定义正则表达式匹配路由信息
    pattern := `\n[^[:space:]]*?[[:space:]]00000000[[:space:]](.*?)[[:space:]]`
    r, err := regexp.Compile(pattern)
    # 检查正则表达式是否出错
    if err != nil {
        # 输出错误信息
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error: %s\n", err.Error())
        # 返回空字符串和错误信息
        return "", err
    }
    # 使用正则表达式匹配路由信息
    match := r.FindAllStringSubmatch(string(out), -1)
    # 获取网关地址
    gateway := match[0][1]
    a, _ := hex.DecodeString(gateway)
    # 返回格式化后的网关地址和空错误信息
    return fmt.Sprintf("%v.%v.%v.%v", a[3], a[2], a[1], a[0]), nil
}

# 测试与 kubelet 的连接
func testConnectionToKubelet(nodeIp string, httpHeaderKey string, httpHeaderValue string, kubeletApi string) (bool,error) {
    # 创建 HTTP 请求
    req, _ := http.NewRequest("GET", fmt.Sprintf("https://%s:10250%s", nodeIp, kubeletApi), nil)
    # 设置请求头中的键值对
    req.Header.Set(httpHeaderKey, httpHeaderValue)
    # 发起 HTTP 请求并获取响应和可能的错误
    resp, err := GlobalClient.Do(req)
    # 如果发生错误，打印错误信息并返回错误
    if err != nil {
        fmt.Printf(red+"[!]"+defaultColor+" Http request to kubelet failed due to the error:%s.Ending test \n",err.Error())
        return false, err
    }
    # 检查响应状态码是否在 200 到 299 之间，表示请求成功
    statusOK := resp.StatusCode >= 200 && resp.StatusCode < 300
    # 如果请求成功，返回 true 和空错误
    if statusOK {
        return true,nil
    }else{
        # 如果请求失败，打印错误信息并返回 false 和空错误
        fmt.Printf(red+"[!]"+defaultColor+" Could no establish connection with kubelet, http status code respond:%s \n",resp.StatusCode)
        return false, nil
    }
//func getMountPathIfExists() (string, error) {
//    cmd := `cat /proc/self/mountinfo | grep /var/log || true`
//    out, err := exec.Command("sh", "-c", cmd).Output()
//    //checkError(err)
//    if err != nil {
//        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error which occur while excutinn shell command to test the mount path to /var/log, error: %s\n", err.Error())
//        return "",err
//    }
//    pattern := ".*? .*? .*? (.*?) (.*?) .*?\n"
//    r, err := regexp.Compile(pattern)
//    //checkError(err)
//    if err != nil {
//        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error: %s \n", err.Error())
//        return "",err
//    }
//    match := r.FindAllStringSubmatch(string(out), -1)
//    for _, matchInner := range match {
//        if matchInner[1] == "/var/log" {
//            return matchInner[2],nil
//        }
//    }
//    return "",nil
//}

// https://kubernetes.io/docs/tutorials/clusters/apparmor/
// https://lwn.net/Articles/656307/
// http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2019/02/04/seccomp
// https://dockerlabs.collabnix.com/advanced/security/apparmor/#no-profile
// https://gitlab.com/apparmor/apparmor/-/wikis/AppArmorInterfaces
func testSeccompAndAppArmor(){
    //Test which profile is loaded to the container
    cmd := `cat /proc/$$/status | grep -e "Seccomp:[[:space:]]*0"`
    // 执行 shell 命令，获取输出结果和错误信息
    _, err := exec.Command("sh", "-c", cmd).Output()
    //if there is error i take it as not found
    // 如果有错误，则认为未找到
    if err != nil {
        fmt.Printf(cyan+"[i]"+defaultColor+" The container is running with seccomp with SECCOMP_MODE_FILTER mode or SECCOMP_MODE_STRICT\n")
        GlobalSeccompRunning = true
    }

    // Test if the process have apparmor profile loaded
    // 测试进程是否加载了 apparmor 配置文件
    cmd = `cat /proc/$$/attr/apparmor/current | grep unconfined`
    _, err = exec.Command("sh", "-c", cmd).Output()
    # 如果错误不为空，表示容器正在运行 apparmor profile
    if err != nil:
        # 打印提示信息，指示容器正在运行 apparmor profile
        fmt.Printf(cyan+"[i]"+defaultColor+" The container is running with apparmor profile\n")
        # 设置全局变量 GlobalIsAppArmorRunning 为 true
        GlobalIsAppArmorRunning = true
# 修改漏洞映射表，根据漏洞名称和新信息更新漏洞映射表
func modifyVulnerabilityMap(exploitName string, newInfo string){
    # 如果漏洞名称在全局漏洞映射表中存在
    if info, found := GlobalVulnerabilityMap[exploitName]; found{
        # 更新漏洞信息
        GlobalVulnerabilityMap[exploitName] = info + newInfo
        # 返回
        return
    }
    # 如果新信息不为空
    if newInfo != "" {
        # 在全局漏洞映射表中添加新的漏洞信息
        GlobalVulnerabilityMap[exploitName] = fmt.Sprintf("*** %s, %s",exploitName,newInfo)
        # 返回
        return
    }

    # 在全局漏洞映射表中添加漏洞名称
    GlobalVulnerabilityMap[exploitName] = fmt.Sprintf("%s",exploitName)
}

# 根据 AppArmor 和 Seccomp 修改漏洞映射表
func modifyByAppArmorSeccomp(exploitName string, BlockedObject string){
    # 如果被阻止的对象不为空
    if BlockedObject != "" {
        # 格式化被阻止的对象信息
        BlockedObject = fmt.Sprintf("such as %s",BlockedObject)
    }

    # 如果 AppArmor 和 Seccomp 都在运行
    if GlobalIsAppArmorRunning &&  GlobalSeccompRunning{
        # 修改漏洞映射表
        modifyVulnerabilityMap(exploitName,fmt.Sprintf("AppArmor and Seccomp is running, High probability it will block relevant requirements for the exploit %s\n",BlockedObject))
        # 打印漏洞信息
        printInfo(exploitName)
        # 返回
        return
    }

    # 如果只有 AppArmor 在运行
    if GlobalIsAppArmorRunning {
        # 修改漏洞映射表
        modifyVulnerabilityMap(exploitName,fmt.Sprintf("AppArmor is running, High probability it will block relevant requirements for the exploit %s\n",BlockedObject))
        # 打印漏洞信息
        printInfo(exploitName)
        # 返回
        return
    }

    # 如果只有 Seccomp 在运行
    if GlobalSeccompRunning {
        # 修改漏洞映射表
        modifyVulnerabilityMap(exploitName,fmt.Sprintf("Seccomp is running, Might block relevant requirements for the exploit %s\n",BlockedObject))
        # 打印漏洞信息
        printInfo(exploitName)
        # 返回
        return
    }
    # 修改漏洞映射表
    modifyVulnerabilityMap(exploitName,"")
    # 打印漏洞信息
    printInfo(exploitName)
}

# 打印漏洞信息
func printInfo (exploitName string){
    # 如果漏洞名称在全局漏洞映射表中存在
    if info, found := GlobalVulnerabilityMap[exploitName]; found{
        # 打印漏洞信息
        fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to %s\n",info)
        # 返回
        return
    }
}

# 检查当前用户是否为 root 用户
func isRoot() (bool,error) {
    # 获取当前用户信息
    currentUser, err := user.Current()
    # 如果出现错误
    if err != nil {
        # 打印错误信息
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error which occur while testing if the user is root, error: %s \n",err.Error())
        # 返回 false 和错误信息
        return false, err
    }
    # 检查当前用户的用户名是否为"root"，如果是则返回True，否则返回False
    return currentUser.Username == "root", nil
// 初始化全局的 HTTP 客户端
func InitHttpClient() {
    // 创建一个自定义的传输对象，设置最大空闲连接数、空闲连接超时时间、禁用压缩、TLS 客户端配置
    tr := &http.Transport{
        MaxIdleConns:       10,
        IdleConnTimeout:    30 * time.Second,
        DisableCompression: true,
        TLSClientConfig:    &tls.Config{InsecureSkipVerify: true},
    }

    // 使用自定义传输对象创建全局的 HTTP 客户端，设置超时时间
    GlobalClient = &http.Client{
        Transport: tr,
        Timeout:   time.Second * 20,
    }
}

// 检查用户名称是否属于输入组
func testUserGroup(group string) (bool, error){
    // 获取当前用户信息
    currentUser, err := user.Current()
    if err != nil {
        // 打印错误信息并返回错误
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error which occur while testing if the user is root, error: %s. Ending test\n",err.Error())
        return false, err
    }

    // 构建 shell 命令，检查当前用户是否属于指定组
    cmd := `getent group ` + group + ` | grep '\b` + currentUser.Username + `\b' || true`
    // 执行 shell 命令并获取输出
    out, err := exec.Command("sh", "-c", cmd).Output()
    if err != nil {
        // 打印错误信息并返回错误
        fmt.Printf(red+"[!]"+defaultColor+" Could not test the vulnerability due to the error which occur while excutinn shell command to test if the current user is part of the docker group, error: %s. Ending test\n", err.Error())
        return false,err
    }

    // 返回是否输出结果不为空和 nil 错误
    return string(out) != "",nil
}

// 设置 Kubernetes 的令牌
func setKubernetesToken () error {
    // 读取指定路径下的文件内容
    data, err := ioutil.ReadFile(PathSecrets)
    if err!=nil {
        // 打印错误信息并返回错误
        fmt.Printf(red+"[!]"+defaultColor+" Could not open the requested token under %s", PathSecrets)
        return err
    }

    // 将文件内容转换为字符串类型的令牌
    token := string(data)
    bearerTemp := "Bearer " + token
    // 设置全局的令牌
    GlobalToken = bearerTemp
    return nil
}

// 检查挂载路径
func checkMountPath (path string, mountOption string) (string,error){
    var cmd string
    # 如果挂载选项不为空
    if mountOption != "" {
        # 构建命令，检查指定路径是否以指定挂载选项挂载
        cmd = `if  cat /proc/self/mountinfo | grep -q '^[^[:space:]]*[[:space:]][^[:space:]]*[[:space:]][^[:space:]]*[[:space:]]`+path+`[^[:space:]]*[[:space:]][^[:space:]]*[[:space:]]`+mountOption+`[[:space:],]'; then
       path=$(cat /proc/self/mountinfo | grep '^[^[:space:]]*[[:space:]][^[:space:]]*[[:space:]][^[:space:]]*[[:space:]]`+path+`[^[:space:]]*[[:space:]][^[:space:]]*[[:space:]]`+mountOption+`[[:space:],]' | cut -d' ' -f 5)
       echo $path
     else
       exit 1
     fi`
    } else{
        # 构建命令，检查指定路径是否已挂载
        cmd = `if  cat /proc/self/mountinfo | grep -q '^[^[:space:]]*[[:space:]][^[:space:]]*[[:space:]][^[:space:]]*[[:space:]]`+path+`'; then
       path=$(cat /proc/self/mountinfo | grep '^[^[:space:]]*[[:space:]][^[:space:]]*[[:space:]][^[:space:]]*[[:space:]]`+path+`' | cut -d' ' -f 5)
       echo $path
     else
       exit 1
     fi`
    }

    # 执行命令并获取输出
    out, err := exec.Command("sh", "-c", cmd).Output()
    # 如果执行出错
    if err != nil {
        var message string
        # 如果挂载选项为空
        if mountOption == "" {
            # 构建未挂载的路径错误信息
            message = fmt.Sprintf(red+"[!]"+defaultColor+" The requested path:%s is not mounted. Ending test\n",path)
        }else{
            # 构建未挂载指定选项的路径错误信息
            message = fmt.Sprintf(red+"[!]"+defaultColor+" The requested path:%s is not mounted with the requested mount option:%s. Ending test\n",path,mountOption)
        }
        # 打印错误信息
        fmt.Printf("%s",message )
        # 返回空字符串和错误
        return "",err
    }
    # 返回去除换行符的输出和空错误
    return strings.TrimSuffix(string(out), "\n"),nil
//END HELPER FUNCTIONS
//START TESTS

func dockerSockTest(){
    // 打印开始 DockerSock 漏洞测试
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of %s vulnerability test \n",DockerSock)
    // 检查 docker.sock 是否可读写
    _,err:= checkMountPath("docker.sock","rw")
    if err != nil {
        return
    }

    // 测试用户命名空间映射
    errUserNS := TestMappingUserNS()
    // 检查是否为 root 用户
    isRootCheck, errRoot := isRoot()
    // 检查用户是否属于 docker 组
    isPartOfDockerGroup, errGroupTest := testUserGroup("docker")
    // 如果用户是 root 或者属于 docker 组，则容器容易受到 DockerSock 漏洞影响
    if errRoot == nil && errGroupTest == nil && (isRootCheck && errUserNS == nil || isPartOfDockerGroup) {
        fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to  %s \n",DockerSock)
        // 修改漏洞映射
        modifyVulnerabilityMap(DockerSock,"")
        return
    }

    // 如果用户不是 root 或者不属于 docker 组，则不受 DockerSock 漏洞影响
    if errRoot != nil || errGroupTest != nil {
        return
    }
}

func kubeletTest(nodeIp string) {
    // 打印开始 Kubelet 漏洞测试
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of %s vulnerability test \n",Kubelet)
    // 测试连接到 Kubelet
    succeedConnectionToKubelet, err := testConnectionToKubelet(nodeIp,"Content-Type","application/x-www-form-urlencod", "/healthz")
    // 如果成功连接到 Kubelet，则容器容易受到 Kubelet 漏洞影响
    if succeedConnectionToKubelet && err == nil {
        fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to %s\n",Kubelet)
        // 修改漏洞映射
        modifyVulnerabilityMap(Kubelet,"")
    }
}

//https://linoxide.com/understanding-each-entry-of-linux-fstab-etcfstab-file/
//https://community.hpe.com/t5/General/mount-only-root-can-do-that-why/td-p/4467747#.YS5F6o4zYZB
func mountBreakoutTest() {
    // 打印开始 MountBreakOut 漏洞测试
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of %s vulnerability test \n",MountBreakOut)
    // 获取容器的能力映射
    capMap,err := getCap()
    if err != nil {
        return
    }

    // 如果用户没有 sys_admin 能力，则容器不受 MountBreakOut 漏洞影响
    if _, ok := capMap[CAP_SYS_ADMIN.String()]; !ok {
        fmt.Printf(red+"[!]"+defaultColor+" the container is not "+red+"vulnerable"+defaultColor+" to %s exploit, user doesn't have sys_admin cap \n",MountBreakOut)
        return
    }

    // 获取根文件系统设备
    device, errRootFS := getRootFSDevice()
    if errRootFS != nil {
        return
    }
}
    # 如果设备为空，则打印提示信息并返回
    if device == "" {
        fmt.Printf(red+"[!]"+defaultColor+" The container is not "+red+"vulnerable"+defaultColor+" to %s exploit, doesn't expose to the root FS device \n",MountBreakOut)
        return
    }

    # 检查是否为 root 用户
    isRootCheck, errRoot := isRoot()
    if errRoot != nil {
        return
    }

    # 如果是 root 用户
    if  isRootCheck {
        # 测试用户命名空间映射
        errUserNS := TestMappingUserNS()
        if errUserNS != nil {
            # 如果容器不是在主机用户命名空间中的 root 用户，则打印提示信息并返回
            fmt.Printf(red+"[!]"+defaultColor+" The container is not root in the host user NS, therefore it depends if the device has user mount option in the host /etc/fstab\n")
            modifyVulnerabilityMap(MountBreakOut,"depends if the device has user mount option in the host /etc/fstab\n")
            modifyByAppArmorSeccomp(MountBreakOut, "Mount")
            return
        }

    }else{
        # 如果容器不是 root 用户，则打印提示信息并返回
        fmt.Printf(red+"[!]"+defaultColor+" The container is not root, therefore it depends if the device has user mount option in the host /etc/fstab\n")
        modifyVulnerabilityMap(MountBreakOut,"depends if the device has user mount option in the host /etc/fstab\n")
        modifyByAppArmorSeccomp(MountBreakOut, "Mount")
        return
    }

    # 修改 AppArmor 和 Seccomp 配置
    modifyByAppArmorSeccomp(MountBreakOut, "Mount")
// 定义一个名为 varLogTest 的函数，接受一个类型为 string 的参数 nodeIp
func varLogTest(nodeIp string){
    // 打印带有颜色的提示信息
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of var log escape vulnerability test \n")
    // 声明变量 err
    var err error
    // 声明变量 succeedConnectionToKubelet
    var succeedConnectionToKubelet bool
    // 声明变量 defaultGateway
    var defaultGateway string
    // 调用 setKubernetesToken 函数，并将返回值赋给 err
    err = setKubernetesToken()
    // 如果 err 不为空，则返回
    if err != nil {
        return
    }

    // 如果 nodeIp 不为空
    if nodeIp != "" {
        // 调用 testConnectionToKubelet 函数，并将返回值赋给 succeedConnectionToKubelet 和 err
        succeedConnectionToKubelet, err = testConnectionToKubelet(nodeIp,"Authorization", GlobalToken, "/logs/")
    }else {
        // 调用 getDefaultGateway 函数，并将返回值赋给 defaultGateway 和 err
        defaultGateway, err = getDefaultGateway()
        // 如果 err 不为空，则返回
        if err != nil {
            return
        }
        // 调用 testConnectionToKubelet 函数，并将返回值赋给 succeedConnectionToKubelet 和 err
        succeedConnectionToKubelet, err = testConnectionToKubelet(defaultGateway,"Authorization", GlobalToken, "/logs/")
    }

    // 如果 succeedConnectionToKubelet 为假，或者 err 不为空，则返回
    if !succeedConnectionToKubelet || err != nil {
        return
    }

    // 调用 TestMappingUserNS 函数，并将返回值赋给 errUserNS
    errUserNS := TestMappingUserNS()
    // 调用 checkMountPath 函数，并将返回值赋给 path 和 errMount
    path, errMount := checkMountPath("/var/log","")
    // 调用 isRoot 函数，并将返回值赋给 isRootCheck 和 errRoot
    isRootCheck, errRoot := isRoot()
    // 如果 errUserNS、errMount、errRoot 都为空，且 path 不为空，且 isRootCheck 为真
    if  errUserNS == nil && errMount == nil && errRoot == nil && path != "" && isRootCheck {
        // 打印带有颜色的提示信息
        fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to var log escape")
        // 调用 modifyVulnerabilityMap 函数，传入参数 VarLogEscape 和空字符串
        modifyVulnerabilityMap(VarLogEscape,"")
    }else{
        // 如果 errRoot 不为空，则返回
        if errRoot != nil {
            return
        }
    }
}

// 定义一个名为 CVE20195736Test 的函数
func CVE20195736Test(){
    // 打印带有颜色的提示信息
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of CVE-2019-5736 vulnerability test \n")
    // 调用 TestMappingUserNS 函数，并将返回值赋给 errUserNS
    errUserNS := TestMappingUserNS()
    // 调用 isRoot 函数，并将返回值赋给 isRootCheck 和 errRoot
    isRootCheck, errRoot := isRoot()
    // 如果 errRoot 为空，且 isRootCheck 为假
    if  errRoot == nil && isRootCheck == false {
        // 打印带有颜色的提示信息
        fmt.Printf(red+"[!]"+defaultColor+" Not root user on the host and requires root privilege on the host to overwrite the runC binary \n")
        // 返回
        return
    }
}
    # 如果 errUserNS 不为空，说明容器在主机用户命名空间中不是 root，并且需要在主机上具有 root 权限才能覆盖 runC 二进制文件
    if errUserNS != nil:
        # 打印警告信息
        fmt.Printf(red+"[!]"+defaultColor+" The container is not root in the host user NS and requires root privilege on the host to overwrite the runC binary \n")
        # 返回
        return

    # 如果 errRoot 不为空，直接返回
    if errRoot != nil:
        return

    # 打印提示信息，说明容器容易受到 CVE20195736 的影响
    fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to %s \n",CVE20195736)
    # 调用 modifyVulnerabilityMap 函数，更新容器的漏洞信息
    modifyVulnerabilityMap(CVE20195736,"Depends if your Docker version is below 18.09.2 and runC version is below 1.0-rc6")
}

// cGroupsEscape 函数用于执行 CGroupEscape 漏洞测试
func cGroupsEscape() {
    // 打印开始 CGroupEscape 漏洞测试的信息
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of %s vulnerability tests \n", CGroupEscape)
    // 检查当前用户是否为 root 用户
    isRootCheck, errRoot := isRoot()
    if errRoot == nil && isRootCheck {
        // 获取当前进程的能力集合
        capMap, err := getCap()
        if err != nil {
            return
        }
        // 如果没有 CAP_SYS_ADMIN 权限，则检查 cgroup RDMA 是否为读写
        if _, ok := capMap[CAP_SYS_ADMIN.String()]; !ok {
            fmt.Printf(cyan+"[i]"+defaultColor+" No CAP_SYS_ADMIN, Check if the cgroup RDMA is read-write \n")
            // 执行命令检查 cgroup RDMA 是否为读写
            cmd := `cat /proc/self/mountinfo | grep -q '^[^[:space:]]*[[:space:]][^[:space:]]*[[:space:]][^[:space:]]*[[:space:]][^[:space:]]*[[:space:]]/sys/fs/cgroup/rdma[[:space:]]rw[[:space:],]'`
            _, err := exec.Command("sh", "-c", cmd).Output()
            if err != nil {
                fmt.Printf(red+"[!]"+defaultColor+" Cgroup RDMA is not mounted read-write. Ending test\n")
            } else {
                fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to %s \n", CGroupEscape)
                modifyVulnerabilityMap(CGroupEscape,"")
            }
            return
        }

        // 检查内核是否编译了 cgroup RDMA 模块
        cmd := `cat /proc/cgroups | grep -q "rdma"`
        _, err = exec.Command("sh","-c", cmd).Output()
        if err != nil {
            fmt.Printf (red+"[!]"+defaultColor+" Cgroup RDMA is not compiled into the kernel. Ending test \n")
            return
        }

        // 如果存在 CAP_SYS_ADMIN 权限，则可能会被 apparmor 阻止挂载系统调用
        modifyByAppArmorSeccomp(CGroupEscape, "Mount")
    }
}

// capSysModule 函数用于执行 CapSysExploit 漏洞测试
func capSysModule(){
    // 打印开始 CapSysExploit 漏洞测试的信息
    fmt.Printf(cyan+"[i]"+defaultColor+" Start of %s vulnerability tests \n", CapSysExploit)
    // 测试执行 make 命令
    errMake := testExecuteCommand("make")
    // 测试执行 insmod 命令
    errInsmod := testExecuteCommand("insmod")
    if errMake != nil || errInsmod != nil {
        return
    }

    // 执行命令检查是否存在指定目录
    cmd := `
    RED=$(tput bold)$(tput setaf 1)
    DEFAULT_COLOR=$(tput sgr0)
    if ! [ -d "/lib/modules/$(uname -r)" ]; then
    # 输出提示信息，指出需要 /lib/modules/$(uname -r) 目录才能运行该漏洞利用程序
    echo "${RED}[i] ${DEFAULT_COLOR} The directory /lib/modules/$(uname -r) is required to run this exploit."
    # 退出程序，返回错误码 1
    exit 1
    fi
    
    # 如果 /lib/modules/$(uname -r)/build 目录不存在，则输出提示信息并退出程序
    if ! [ -d "$(readlink -f  /lib/modules/$(uname -r)/build)" ]; then
        echo "${RED}[i] ${DEFAULT_COLOR}$(readlink -f  /lib/modules/$(uname -r)/build) are required to run this exploit."
        exit 1
    fi
    
    # 如果 /lib/modules/$(uname -r)/build/Makefile 所在的目录不存在，则输出提示信息并退出程序
    if ! [ -d "$(dirname $(readlink -f $(readlink -f  /lib/modules/$(uname -r)/build)/Makefile))" ]; then
        echo "${RED}[i] ${DEFAULT_COLOR}$(dirname $(readlink -f $(readlink -f  /lib/modules/$(uname -r)/build)/Makefile)) are required to run this exploit."
        exit 1
    fi
    
    # 执行 shell 命令，并获取输出结果和错误信息
    out, err := exec.Command("sh", "-c", cmd).Output()
    
    # 如果执行命令出错，则输出错误信息并结束测试
    if err != nil {
        fmt.Println(string(out))
        fmt.Printf(red+"[!]"+defaultColor+" Ending test\n")
        return
    }
    
    # 获取容器的能力映射
    capMap,err := getCap()
    if err != nil {
        return
    }
    
    # 如果容器具有 CAP_SYS_MODULE 能力，则修改漏洞映射并输出提示信息
    if _, ok := capMap[CAP_SYS_MODULE.String()]; ok {
        modifyVulnerabilityMap(CapSysExploit,"")
        fmt.Printf(yellow+"[+]"+defaultColor+" The container is "+red+"vulnerable"+defaultColor+" to %s \n", CapSysExploit)
    }
// 定义控制台输出颜色的常量
const red string = "\u001B[1;31m"
const green string= "\u001B[1;32m"
const yellow string= "\u001B[1;33m"
const blue string = "\u001B[1;34m"
const cyan string = "\u001B[1;36m"
const defaultColor string = "\u001B[0m"

// 主函数，接收一个节点 IP 地址作为参数
func mainfunc(nodeIp string){
    // 输出日志标题
    fmt.Printf("\n"+ blue +"========= "+green+"LOGS"+blue+" ========="+defaultColor+"\n")
    // 调用测试 Seccomp 和 AppArmor 的函数
    testSeccompAndAppArmor()
    // 初始化 HTTP 客户端
    InitHttpClient()
    // 测试 Docker Sock
    dockerSockTest()
    // 测试 kubelet
    kubeletTest(nodeIp)
    // 测试挂载点突破
    mountBreakoutTest()
    // 测试 var/log
    varLogTest(nodeIp)
    // 测试 CVE-2019-5736
    CVE20195736Test()
    // 测试 cGroups 逃逸
    cGroupsEscape()
    // 测试 capSysModule
    capSysModule()

    // 输出结果标题
    fmt.Printf("\n"+ blue +"========= "+green+"RESULTS"+blue+" ========="+defaultColor+"\n")
    // 如果全局漏洞映射不为空
    if len(GlobalVulnerabilityMap) != 0 {
        // 输出容器易受攻击的漏洞信息
        fmt.Printf(green+"The container is vulnerable to the following exploits:\n")
        for _, info := range GlobalVulnerabilityMap {
            fmt.Printf(yellow+"[+]"+green+" %s\n",info)
        }
        return
    }

    // 输出容器不易受攻击的信息
    fmt.Printf(cyan+"[i]"+defaultColor+" The container is not "+red+"vulnerable"+defaultColor+" to non of kubesploit exploits")
}
//
//func main (){
//    //
//    //InitHttpClient()
//    //testSeccompAndAppArmor()
//    //mainfunc("127.0.0.1")
//
//}
```